{"./":{"url":"./","title":"Django打造大型企业","keywords":"","body":"打造大型企业 "},"第四章：数据库/001django mysql安装及其一些软件.html":{"url":"第四章：数据库/001django mysql安装及其一些软件.html","title":"001django mysql安装及其一些软件","keywords":"","body":"mysql的安装 1、在官网下载mysql文件https://dev.mysql.com/downloads/windows/installer/5.7.html 2、然后双击安装，如果出现一下错误，则到安装netdramework框架 3、安装的时候回让你选择版本 4、上面直接全部安装的，安装完成之后会有一个mysql5.7 command line client终端直接打开 5、show databases;查看数据库,记得后边的分号 6、采用navicat（图形化界面）来操作数据库，可以连接多种数据库 破解方法网址：https://www.cnblogs.com/runw/p/11802455.html此破解方法是12版本的 1、 下载navicat Premium12 网址https://www.navicat.com.cn这里下载的是12版本的 2、暂时用的是试用版 mysql驱动程序安装 1、使用django来操作mysql，pip install mysqlclient安装 常见的mysql驱动： mysql-python：C语言操作mysql数据库的简单封装，只支持python2不支持python3 mysqlclient：支持python并且修复了一些bug pymysql：纯python实现的一个驱动。因为是纯python写的，效率不如mysql-python，但可以和python代码无缝衔接。 mysql Connector/Python：mysql官方退出纯python连接mysql驱动。因为是纯python开发的，效率不高。 "},"第四章：数据库/002django使用原生sql语句操作数据库.html":{"url":"第四章：数据库/002django使用原生sql语句操作数据库.html","title":"002django使用原生sql语句操作数据库","keywords":"","body":"django使用原生sql语句操作数据库 django配置连接数据库 在setting.py 里面的DATABASES进行配置 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), #这里的name表示引用的是db.sqlite3的文件，前面是路径 } } 数据库的配置 DATABASES = { 'default': { #数据库引擎(sqlite3/mysql/orcale等) 'ENGINE': 'django.db.backends.mysql', #数据库的名字 'NAME': 'django_db1', #连接数据库的用户名 'USER':'root', #连接数据库的密码 'PASSWORD':'123456', #连接数据库的主机地址 'HOST':'127.0.0.1', #连接数据库的端口 'PORT':'3306' } } 默认模板 TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], #系统的位置 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 连接数据库 在django中使用原生sql语句操作，就是使用python db api的接口操作。如果mysql驱动使用的是pymysql那么就是使用pymysql操作。 插入数据库数据 def index(request): #连接游标 cursor = connection.cursor() cursor.execute(\"insert into book(id , name ,author) values(null,'三国演义','罗贯中')\") return render(request,'index.html') #查找数据 cursor = connection.cursor() #cursor.execute(\"insert into book(id , name ,author) values(null,'三国演义','罗贯中')\") cursor.execute('select id,name,author from book') rows = cursor.fetchall() for row in rows: print(row) Python DB api 规范 可以查看官方的文档 "},"第四章：数据库/003mysql图书管理系统.html":{"url":"第四章：数据库/003mysql图书管理系统.html","title":"003mysql图书管理系统","keywords":"","body":"实现了一个图书管理系统 1、可以发布图书，同时也可以删除图书以及查看图书详情 控制部分代码如下： from django.shortcuts import render,redirect,reverse# 渲染 跳转 反转 from django.db import connection #引入数据库连接 # Create your views here. def get_cursor(): #定义了一个获取数据库游标的函数 return connection.cursor() def index(request): cursor = get_cursor() #cursor.execute(\"select id,name,author from book\") #books = cursor.fetchall() #返回的是[(1,'三国演义,'罗贯中'),(2,)....] #cursor.execute(\"insert into book(id,name,author) values(null,'三国演义','罗贯中')\") #可以插入数据，但是不能获取数据 cursor.execute('select * from book')#从book表中，查询所有的数据 books = cursor.fetchall()#查询所有的结果((id,name,author),(id,name,author)...) context = { 'books':books, } return render(request,'index.html',context=context) def add_book(request): if request.method =='GET': return render(request,'add_book.html') else: name = request.POST.get(\"name\") author = request.POST.get(\"author\") cursor = get_cursor() cursor.execute(\"insert into book(id,name,author) values(null,'%s','%s')\"% (name,author)) return redirect(reverse('index')) def book_detail(request,book_id): cursor = get_cursor() cursor.execute(\"select id,name,author from book where id = %s \"% book_id) book = cursor.fetchone()#查询一条数据 context = { 'book':book, } return render(request,'book_detail.html',context=context) def delete_book(request): if request.method == 'POST':#判断post请求还是get请求 很重要 book_id = request.POST.get('book_id') cursor = get_cursor() cursor.execute(\"delete from book where id=%s \"% book_id) return redirect(reverse('index')) else: raise RuntimeError(\"删除图书的method错误\") urls.py的代码如下： from django.urls import path from front import views urlpatterns = [ path('', views.index,name='index'), path('add_book/', views.add_book,name='add_book'), #repath('book_detail/(?P\\d+/))',views.book_detail,name='book_detail') path('book_detail//',views.book_detail,name='book_detail'), path('delete_book/',views.delete_book,name = 'delete_book') ] 模板代码如下： {% load static %}#这里需要加载静态页面，load static加载 图书管理系统 #加载static下面的静态css文件 首页 发布图书 {% block content %}{% endblock %}#定义了一个，在子模板中可以代替内容，继承里面的用{{super()}} {% extends 'base.html' %} {% block content %} 序号 书名 作者 {% for book in books %} {{ forloop.counter }} {{ book.1 }} {{ book.2 }} {% endfor %} {% endblock %} {% extends 'base.html' %} {% block content %} 书名: 作者: {% endblock %} {% extends 'base.html' %} {% block content %} 书名:{{ book.1 }} 作者:{{ book.2 }} {% endblock %} css样式代码如下： *{ margin:0; padding:0; } .nav{ background: #3a3a3a; height: 65px; overflow:hidden; } .nav li{ float:left; list-style: none; margin:0px 20px; line-height: 65px; } .nav li a{ color: white; text-decoration: none; } .nav li a:hover{ color:blue; } .index_table td{ border:1px red dashed; } 注意事项 1、POST提交的时候报错 CSRF 解决：可以从setting.py的MIDDLEWARE中将django.middleware.csrf.CsrfViewMiddleware这行代码注释掉。 2、mysql数据库的连接 解决：在setting.py中找到DATABASES配置代码如下： DATABASES = { 'default': { #'ENGINE': 'django.db.backends.sqlite3', 'ENGINE': 'django.db.backends.mysql',#表示mysql引擎 #'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 'NAME': 'book_manager',#数据库名称 'USER':'root',#数据库用户名 'PASSWORD':'123456',#数据库密码 'HOST':'127.0.0.1',#数据库ip地址 'PORT':'3306',#数据库端口 } } "},"第四章：数据库/004ORM模型.html":{"url":"第四章：数据库/004ORM模型.html","title":"004ORM模型","keywords":"","body":"ORM模型操作数据库 随着项目越大，原生sql的方式会出现大量的SQl语句： 1、语句重复利用率不高，越复杂SQL语句条件越多代码越长 2、修改逻辑比较码放 3、SQL忽略WEB安全问题，给未来造成隐患。如SQL注入 ORM，全称Objet Relational Maping，中文叫做对象关系映射。通过表映射成类，把行作实例，把字段作属性。 在models模型中创建： 在使用django mysql的时候，尽量使用orm模型。 ORM的好处： 1、易用性，使用orm数据库的开发可以有效的减少重复sql语句的概念，写出来的模型也更加直观、清晰。 2、性能损耗小：ORM转成底层数据库操作指令确实会有一些开销，但实际的情况这种性能损耗很少不足5%，只要不表示对性能有严苛的要求，综合考虑开发效率，代码的阅读性，带来的好处远远大于性能损耗，而且项目越大作用越明显。 3、设计灵活：可以轻松的写出复杂的查询 4、可移植性：django封装底层的数据库实现，支持福讴歌关系数据库引擎，包括与流行的mysql、postgreSQL和SQLite。可以非常轻松的切换数据库。 创建ORM模型： ORM模型一般创建在app下的models.py中 配置数据库在setting.py中 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'orm_intro', 'USER':'root', 'PASSWORD':'123456', 'HOST':'127.0.0.1', 'PORT':'3306', } } 创建app 在项目目录中，cmd窗口输入python manage.py startapp book 在book文件夹中创建models.py文件,输入代码 from django.db import models # Create your models here. #如果要将一个普通的类变成一个可以映射到数据库中的模型 #那么必须要将父类设置为models.Model或者其他的子类 class Book(models.Model): #1、id：int类型自增长 id = models.AutoField(primary_key = True)#自动增长，主键 #2、name：varchar(100)图书的名字 name = models.CharField(max_length=100,null=False)#长度最长不超过100,不能为空 #3、author：varchar(100) 图书的作者 author = models.CharField(max_length=100,null=False) #4、price:float 图书的价格 price = models.FloatField(null=False,default=0)#不能为空，默认为0 #对应好了之后就要映射到数据库,添加app到installed_apps中 #python manage.py makemigrations 使用makemigrations生成迁移脚本文件 #python manage.py migrate 使用migrate将文件生成的迁移脚本文件映射到数据库中 class Publisher(models.Model): #默认生成id主键的 name = models.CharField(max_length=100,null=False) address = models.CharField(max_length=100,null=False) #python manage.py makemigrations #python manage.py migrate app一定要在setting.py 中添加instaled_app中添加app 在当前虚拟环境下，cmd中执行语句python manage.py makemigrations 然后执行语句python manage.py migrate 上面生成的代码，都是注册在installed_app中的应用。如果还要生成其他的数据表同样在cmd中执行上面的两行语句。 python manage.py makemigrations python manage.py migrate 生成的数据表： 问题：为什么表名为book_book? 答：如果没有给表名的话，前面book表示app的名字，后面的book表示app应用的名称。 "},"第四章：数据库/005ORM模型基本的增删改查操作.html":{"url":"第四章：数据库/005ORM模型基本的增删改查操作.html","title":"005ORM模型基本的增删改查操作","keywords":"","body":"ORM模型的增删改查 添加数据： 只要使用ORM模型创建一个对象，然后再调用这个ORM模型的save方法就可以保存了。 示例代码如下： from django.http import HttpResponse # Create your views here. def index(request): #使用ORM添加一条数据到数据库中 book = Book(name='西游记',author='吴承恩',price=100) book.save() return HttpResponse(\"书籍添加成功\") 查找数据 所有的查找工作都是使用模型上的objects属性来完成的 当然也可以自定义查询对象，这部分功能会在后边讲到 1、根据主键进行查找，使用主键进行查找。可以使用objects方法，然后传递pk=xx 的方式进行查找，示例代码如下： book = Book.objects.get(pk=2) 2、根据其他字段进行查找：可以使用objects.filter代码进行查找，示例代码如下： book = Book.objects.filter(name='西游记') #返回全部为西游记的书籍 #>]> book = Book.objects.filter(name='西游记').first() #返回第一条 使用fillter方法返回的是一个QuerySet对象，这个对象类似于列表，我们可以使用这个对象的first方法来获取第一个值。 删除数据 首先查找对应的数据模型，然后再执行这个模型的delete方法即可删除，示例代码如下： book = Book.objects.get(pk=1) book.delete() 修改数据 首先查找到对应的数据模型，然后修改这个模型上的属性上的模型的值。在执行save方法即可修改完成。示例代码如下： book = Book.objects.get(pk=2) book.price = 200 book.save() class类返回样式（打印类） from django.db import models # Create your models here. class Book(models.Model): #id会自动生成的 主键 自增 name = models.CharField(max_length=100,null=False) author = models.CharField(max_length=100,null=False) price = models.FloatField(default=0) def __str__(self): # return ''.format(name=self.name,author=self.author,price=self.price) _str_()是class的默认方法，可以自定义打印的样式。 "},"第四章：数据库/006ORM常用Filed详解.html":{"url":"第四章：数据库/006ORM常用Filed详解.html","title":"006ORM常用Filed详解","keywords":"","body":"模型常用属性 常用字段： 在Django中，定义了一些Field来与数据库表中的字段类型来进行映射。以下将介绍那些常用的字段类型。 AutoField： 映射到数据库中int类型，可以有自动增长的特性。一般不需要使用这个类型，如果不指定主键，那么模型会自动的生成一个叫id的自动增长的主键，如果你想指定一个其他名字的并且具有自动增长的主键，使用AutoField也是可以的。 BigAutoField 64位的整型，类似于AutoFiled，只不过是产生的数据的范围是从1-9223372036854775807 BooleanField 在模型层面接受的是True/False。在数据库层面是tinyint类型。如果没有指定默认值，默认值是None。 CharFiled 在数据库层面是varchar类型。在python层面就是普通的字符串，这个类型在使用的时候必须要指定最大的长度，也即必须要传递max_length这个关键字参数进去。 DateField 日期类型：在python中是datatime.date类型，可以记录年月日，在映射到数据库中也是date类型。使用这个field可以传递以下几个参数： 1、auto_now在每次这个数据保存的时候后，都使用当前的时间，比如作为一个记录修改日期的字段，可以将这个属性设置为True 2、auto_now_add在每次数据第一次添加进去的时候，都使用当前时间，比如作为一个记录第一次入库的字段，可以将这个属性设置为True。 DateTimeField： 日期时间类型，类似于DataField。不仅仅存储日期，还可以存储时间。映射到数据库中datetime类型，这个filed也可以使用auto_now和auto_now_add两个属性。 TimeField： 时间类型。在数据库中是time类型。在python中是datetime.time类型。 EmailField: 类似于CharField。在数据库底层也是一个varchar类型。最大长度是254字符。 EmailField在数据库层面并不会限制字符串一定要满足邮箱格式 只是以后再使用modelForm等表单相关操作的时候回起作用 FileField 用来存储文件的，这个参考后面的文件上传文章节部分。 ImageFiled 用来存储图片文件的，这个请参考后面的图片上传章节部分。 FloatField 浮点类型。映射到数据库中是float类型。 IntegerField 整型。值得区间是-2147483648——2147483647. BigInterField 大整型。值的区间是-9223372036854775808——9223372036854775807. PositiveIntegerField 正整型。值得区间是0-2147483647 SmallIntegerField: 小整型，值得区间是-32768-32767 PositiveSmallIntegerField: 正小整型。值得区间是0-32767 TextField: 大量的文本类型。映射到数据库中是longtext类型。 UUIDField 只能存储uuid格式的字符串，uuid是一个32位的全球唯一的字符串，一般用来作为主键。 URLField 类似于CharField，只不过能用来存储url格式的字符串，并且默认的max_length是200. 如果想查看更多的字段，选择某个字段Ctrl+左单击就可以看到！ Field的常用参数： null: null = True 如果设置为True，Django将会在映射表的时候指定是否为空。默认是为Flase。在使用字符串相关的Field（CharField/TextField)的时候，官方推荐尽量不要使用这个参数，也就是保持默认值Flase.因为Django在处理字符串相关的Field的时候，及时这个Field的null=False，如果你没有给这个Field传递任何值，那么Django也会使用一个空的字符串''来作为默认值存储进去，因此如果再使用null=True,Django会产生两种空值得情形（NULL或者空字符串）。如果想要在表单验证的时候允许这个字符串为空，那么建议使用blank=True。如果你的Field是BooleanField，那么对应的可空的字段则为NullBooleanField。 #models.py class Author(models.Model): username = models.CharField(max_length=100)#默认不能为空 age = models.IntegerField(null = True) #views.py def null_text_field(request): author = Author(username='') author.save() return HttpResponse('null') blank 标识这个字段在表单验证的时候是否可以为空，默认是False。 这个和null是有区别的，null是一个纯数据库级别的，而blank是表单验证级别的。 db_column: 这个歌字段在数据库中的名字，如果没有设置这个参数，那么将会使用模型中属性的名字。 age = models.IntegerField(null = True,db_column='author_age') #db_column='author_age'加入这个参数，就会将数据表中的age改变为author_age default： 默认值，可以为一个值，或者是一个函数，但是不支持lambda表达式，并且不支持列表/字典/集合等可变得数据结构。 age = models.IntegerField(null = True,db_column='author_age',default =0) #default =0,字段默认为0 如果不给值得时候就会默认为0 now() 调用default = now 后面不需要括号，这样才是调用函数 auto_now_add auto_now_add= ture 自动加入创建的时间 primary_key 是否为主键，默认是False。 unique 在表中这个字段的值是否唯一。一般是设置手机号码/邮箱等。 telephone = models.CharField(max_length=11,unique =True,null=True) 解决之前存在数据唯一的问题，添加null = True 其他字段可以查看官方文档： https://docs.djangoproject.com/zh-hans/2.0/ref/models/fields "},"第四章：数据库/007navie时间和aware时间详解.html":{"url":"第四章：数据库/007navie时间和aware时间详解.html","title":"007navie时间和aware时间详解","keywords":"","body":"navie时间和aware时间 什么是naive时间，什么是aware时间 1、不知道自己的时间是表示的是哪个时区的，也就是不知道自己几斤几两，比较幼稚。 2、aware时间：知道自己的时间表示的是哪个时区的，也就是比较清醒。 pytz库： 专门用来处理时区的库，这个库会经常更新一些时区的数据，不需要我们担心。并且这个库在安装django的时候回默认的安装，如果没有安装，那么可以通过pip install pytz的方式进行安装。 astimezone方法： 将一个时区的时间转换为另外一个时区的时间。这个方法只能被aware类型的时间调用，不能被naive类型的时间调用。 import pytz from datetime import datetime now = datetime.now() #这是一个naive类型的时间 utc_timezone = pytz.timezone(\"UTC\")#定义UTC的时区对象 utc_now = now.astimezone(utc_timezone)#将当前的时间转换为UTC时区的时间 #>>ValueError:astimezone()cannot be applied to a naive datetime #会抛出一个异常，原因就是因为navie类型的时间不能调用astimezone方法 now = now.replace(tzinfo = pytz.timezone('Asia/Shanhai')) utc_now = now.astimezone(utc_timezone) #这时候就可以正确的转换 USE_TZ = True 如果 USE_TZ 设置为false，那么django获取到当前时间就是一个naive类型的时间 建议设置为True from django.shortcuts import render from django.http import HttpResponse from .models import Article from django.utils.timezone import now # Create your views here. def index(request): import pytz from datetime import datetime now = datetime.now() utc_timezone = pytz.timezone(\"UTC\") utc_now = now.astimezone(utc_timezone) print(utc_now)#2020-04-06 10:20:42.961093+00:00 return HttpResponse('success') replace方法： 可以将一个时间的某些属性进行更改 Django.utils.timezone.now方法： 会根据settings.py中是否设置了USE_TZ=True获取当前的时间，如果设置了，那么就获取一个aware类型的UTC时间。如果没有设置，那么会获取一个navie类型的时间。 django.utils.timezone.localtime方法： navie和aware介绍以及在django中的用法 https://docs.djangoproject.com/en/2.0/topics/i18n/timezones/ 时间的用法 models from django.db import models # Create your models here. class Article(models.Model): #付过想要使用自己定义的Field来作为主键，那么必须设置primary_key=True id = models.BigAutoField(primary_key = True) #BooleanField 布尔类型 #如果没有指定null=True，那么默认情况下，null=False #就是不能为空null #如果想要使用可以为null的BooleanField，那么使用NullBooleanField来代替 #removed = models.BooleanField() removed = models.NullBooleanField()#改过字段要重新映射 #charField如果是超过了254个字符就不建议使用了 #就推荐使用TextField：longtext title = models.CharField(max_length=200) create_time = models.DateTimeField(auto_now_add=True) #自动获取当前对象auto_now_add=True #创建时间 auto_now_add=True 是在第一次添加数据进去的时候会自动获取当前的时间 #更新时间 auto_now =True:每次这个对象条用save方法的时候都会将当前的方法更新 #python manage.py makemigrations #migrate views from django.shortcuts import render from django.http import HttpResponse from .models import Article from django.utils.timezone import now,localtime #localtime可以根据timezone时间转换 # Create your views here. def index(request): import pytz from datetime import datetime now = datetime.now() utc_timezone = pytz.timezone(\"UTC\") utc_now = now.astimezone(utc_timezone) print(utc_now)#2020-04-06 10:20:42.961093+00:00 #插入了两条数据 article = Article(title='abc',create_time=now()) article.save() # article = Article.objects.get(pk=7) # 如果数据库中没有id =7 的数据就会报错 create_time = article.create_time print('='*30) print(create_time) print(localtime(create_time)) print('=' * 30) # ''' # ============================== # 2020-04-08 08:37:06.122458+00:00 # [08/Apr/2020 16:45:04] \"GET / HTTP/1.1\" 200 7 # 2020-04-08 16:37:06.122458+08:00 # ============================== # ''' return HttpResponse('success') context = { 'create_time':create_time, } return render(request,'index.html',context=context) #======================================= article = Article(title='bcd') article.save() return HttpResponse('success') 记得在添加model的时候要运行： python manage.py makemigrations 在运行这句话的会后，如果字段以前的数据没有设置，要先进行设置 python manage.py migrate "},"第四章：数据库/008meta类中常见配置.html":{"url":"第四章：数据库/008meta类中常见配置.html","title":"008meta类中常见配置","keywords":"","body":"Meta类中常见配置 对于一些模型级别的配置，我们可以在模型中自定义一个类，叫做Meta。然后在这个类中添加一些类属性来控制模型的作用。比如我们想要在数据库映射的时候使用自己指定的表名，而不是使用模型的名称。那么我们可以在meta类中添加一个db_table的属性，示例代码如下： class Author(models.Model): username = models.CharField(max_length=100,null=True)#默认不能为空 age = models.IntegerField(null = True) #db_column='author_age'加入这个参数，就会将数据表中的age改变为author_age #在类里面进行定义Meta类 Rename table for author to author class Meta: db_table = 'author' db_table 这个模型映射到数据库中的表明，如果没有指定这个参数，那么在映射的时候会将使用模型名来作为默认的表名。 ordering 设置在提取数据的排序方式，后面章节会讲到如何查找数据，比如我想在查找数据的时候根据添加的时间排序，那么代码如下： class Author(models.Model): username = models.CharField(max_length=100,null=True)#默认不能为空 age = models.IntegerField(null = True) #db_column='author_age'加入这个参数，就会将数据表中的age改变为author_age #在类里面进行定义Meta类 Rename table for author to author def __str__(self): return \"\" %(self.id,self.create_time) class Meta: db_table = 'author' ordering = ['pub_date','id']#可以多个参数 #如果变为 -pub_date,前面加负号就表示反向了 #先按照第一个参数排序在按照后面的参数 def order_view(request): authors = Author.objects.all() for author in authors: # print(author) return HttpResponse('success') Meta类定义在数据表的类中： class Meta: ​ pass "},"第四章：数据库/009外链和表关系.html":{"url":"第四章：数据库/009外链和表关系.html","title":"009外链和表关系","keywords":"","body":"外链和表关系 外键 在Mysql中，表有两种引擎，一种是InnoDB，另外一种是myisam。如果使用的是InnoDB引擎，是支持外键约束的，外键的存在使得ORM框架在处理表关系的时候异常的强大，因此这里我们首先来介绍下外键在Django中使用。 类定义为class ForeignKey(to,on_delete,**options)第一个参数是引用的是哪个模型，第二个参数是在使用外键引用的模型数据被删除了，这个字段该如何处理，比如有CASCADE、SET_NULL等。这里以一个实际案例来说明，比如有一个User和一个Article两个模型。一个User可以发表多篇文章，一个Article只能由一个Author并且通过外键进行引用，那么相关的示例代码如下： class User(models.Model): username = models.CharField(max_length = 20) password = models.CharField(max_length = 100) class Article(models.Model): title = models.CharField(max_length = 100) content = models.TextField() author = models.ForeignKey(\"user\",on_delete=models.CASCADE) 以上使用ForeignKey来定义模型之间的关系，即在article的实例中可以通过author属性来操作对应的User模型。这样使用起来非常的方便，代码如下： #models.py from django.db import models # Create your models here. class Category(models.Model): name = models.CharField(max_length=100) class Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() category = models.ForeignKey(\"Category\",on_delete=models.CASCADE) #cascade表示的是级别删除的意思 ForeignKey 表示外键 author = models.ForeignKey(\"frontuser.FrontUser\",on_delete=models.CASCADE,null = True) #外键在其他app中 app.模型的名字 #category: id ,name #1,最新 #article #id,title,category #1,xxx,1 #views.py from django.shortcuts import render from .models import Category,Article from django.http import HttpResponse # Create your views here. def index(request): category = Category(name='最新文章') category.save() article = Article(title='abc',content='123') article.category = category article.save() return HttpResponse('success') #article/urls.py from django.urls import path from . import views app_name = 'article' urlpatterns = [ path('',views.index,name='index'), ] #demo/urls.py from django.urls import path,include urlpatterns = [ path('',include('article.urls')), ] article = Article.objects.first() print(article.category.name) #article表的category表的名字，category做了外键 return HttpResponse('success') 如果模型的外键引用的是本身自己这个模型，那么to参数可以为self，或者是这个模型的名字，在论坛开发中，一般评论都可以进行二级评论，即可以针对另外一个评论进行评论，那么在定义模型的时候就需要使用外键来引用自身。代码如下： class Comment(models.Model): content = models.TextField() origin_comment = models.ForeignKey('self',on_delete=models.CASCADE) 外键删除操作： 如果一个模型使用了外链，那么在对方哪个模型被删掉后，该进行什么样的操作。可以通过on_delete来指定，乐意指定的类型如下： 1、CASCADE：级联操作，如果外链对应的那条数据被删除了，那么这条数据会被删除。 2、PROTECT：受保护。即只要这条数据引用了外键的那条数据，那么既不能删除外链的那条数据。 3、SET_NULL：设置为空，如果外链的那条数据被删除了，那么本条数据上就将这个字段设置为默认值。如果设置这个选项，前提是要指定这个字段可以为空。null = True 4、SET_DEFAULT:设置默认值，如果外链的那条数据被删除了，那么本条数据上就将这个字段设置为默认值，如果设置这个选项，前提是要指定这个字段一个默认值。on_delete = models.SET_DEFAULT,default =Category.objects.get(pk=4)使用id为4的默认值。 5、SET()：如果外键的那条数据被删除了，那么将会获取SET函数中的值来作为这个外键的值，SET函数可以接受一个可以调用的对象（比如函数或者方法），如果可以条用的对象，那么会将这个对象调用后的结果作为值返回回去。on_delete = models.SET(Category.objects.get(pk=4)) 6、DO_NOTHING：不采用任何行为，一切全看数据库级别的约束。 on_delete = models.DO_NOTHING sql的级别操作！ #models.py class Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() category = models.ForeignKey(\"Category\",on_delete=models.CASCADE) #cascade表示的是级别删除的意思 ForeignKey 表示外键 author = models.ForeignKey(\"frontuser.FrontUser\",on_delete=models.CASCADE,null = True) #测试时候的def方法 def delete_view(request): category = Category.objects.get(pk = 1)#删除主键为1的数据 category.delete()#执行删除 return HttpResponse('delete success') 以上这个选项只是Django级别的，数据级别依旧是RESTRICT! django数据库层面 Foreign外键，可以查阅资料了解更多 表关系： 表之间的关系都是通过外键来进行关联的，而表之间的关系，无非就是三种关系：一对一、一对多（多对一）、多对多等。以下将讨论以下三种关系的应用场景及其实现方式。 一对多： 1、应用场景：比如文章和作者之间的关系。一个文章只能由一个作者编写，但是一个作者可以写多篇文章，文章和作者之间的关系就是典型的多对一的关系。 2、实现方式：一对多或者多对一，都是通过ForeignKey来实现的，还是以文章和作者的案例进行讲解。 class User(models.Model): username = models.CharField(max_length = 20) password = models.CharField(max_length = 100) class Article(models.Model): title = models.CharField(max_length = 100) content = models.TextField() author = models.ForeignKey(\"User\",on_delete = models.CASCADE) 那么以后在给Article对象指定author，就可以使用以下代码来完成： article = Article(title = 'abc',content = '123') author = User(username = 'zhiliao',password = '111111') #要先保存到数据库中 auhtor.save() article.author = author article.save() 并且以后如果想要获取某个用户下所有的文章，可以通过article_set来实现，示例代码如下： user = User.objects.first() #获取第一个用户写的所有文章 artilcles = user.article_set.all() for article in articels: print(article) def one_to_many_view(request): article = Article(title= '钢铁是怎样炼成的',content='abc') category = Category.objects.first() author = FrontUser.objects.first() #获取第一条数据 article.category = category article.author = author article.save() return HttpResponse('yes') #数据表如下图 #文章查找 # 2、获取分类下的所有文章 category = Category.objects.first()#获取分类的第一条数据 #RelatedManager #article = category.article_set.first()#获取所以的文章，也可.all() articles = category.article_set.all()#获取所以的文章，也可.all() #因为使用了外键就会生成category.article_set属性 for article in articles: print(article) return HttpResponse('success') 一对一 1、应用场景：比如一个用户表和一个用户信息表。在实际网站中，可能需要保存用户的许多信息，但是有些信息是不经常用的。如果把所有信息都存放到一张表中可能会影响查询效率，因此可以把用户的一些不常用的信息存放到另外一张表中我们叫做UserExtension。但是用户表User和用户信息表UserExtension就是典型的一对一了。 2、实现方式：Django为一对一提供了一个专门的Field叫做OneToOneField来实现一对一操作。示例代码如下： class User(models.Model): username = models.CharField(max_length=20) password = models.CharField(max_length=100) class UserExtension(models.Model): birthday = models.DateTimeField(null=True) school = models.CharField(blank=True,max_length=50) user = models.OneToOneField(\"User\", on_delete=models.CASCADE) 在UserExtension模型上增加了一个一对一的关系映射。其实底层是在UserExtension这个表上增加了一个user_id，来和user表进行关联，并且这个外键数据在表中必须是唯一的，来保证一对一。 一对一： 在Django中一对一是通过models.OneToOneField来实现的，这个OneToOneField其实本质上就是一个外链，只不过这个外键有一个唯一约束(unique key)来实现一对一 2.以后如果想要反向引用，那么是通过引用的模型的名字转换为小写的形式进行访问，比如以下模型： from django.db import models # Create your models here. class FrontUser (models.Model): username = models.CharField(max_length=100) def __str__(self): return \"\"%(self.id,self.school,self.user_id) # views.py def one_to_one_view(request): # user = FrontUser.objects.first() # #print(user.id,user.username)#1 李白 # extension = UserExtension(school ='清华') # extension.user = user # extension.save() #extension = UserExtension.objects.first() #print(extension.user)# UserExtension的对象可以通过user来访问到对应的user对象，并且FrontUser对象可以使用Userextension来访问对应的UserExtension对象.如果不想使用Django默认的引用属性名字，那么可以在OneToOneField中添加一个related_name参数。示例代码如下： #OneToOneField 就相当于外键的作用 user = models.OneToOneField(\"FrontUser\",on_delete=models.CASCADE,related_name='extension') #因为定义了onetoone索引用户只能是一个 def __str__(self): return \"\"%(self.id,self.school,self.user_id) #views.py #在models中定义了related_name= 'extension' print(user.extension)#此时userextension将会报错 那么以后就FrontUser的对象就可以通过Extension属性来访问到对应的UserExtension对象。 多对多： 1、应用场景：比如文章和标签的关系。一篇文章可以有多个标签，一个标签可以被多个文章所引用。因此标签和文章的关系是典型的多对多的关系。 2、实现方式：Django为这种多对多的实现提供了专门的Field。叫做ManyToManyField。还是拿文章和标签为例进行讲解。示例代码如下： class Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() tags = models.ManyToManyField(\"Tag\",related_name=\"articles\") class Tag(models.Model): name = models.CharField(max_length=50) #views.py def many_to_many_view(request): article = Article.objects.first() tag = Tag(name='冷门文章') tag.save() article.tag_set.add(tag) tag = Tag.objects.get(pk=1) article = Article.objects.get(pk=11) tag.article.add(article) #tag里加文章 article = Article.objects.get(pk=11) tags = article.tags.all() for tag in tags: print(tag) return HttpResponse('sucess') 在数据库层面，实际上Django是为这种多对多的关系建立了一个中间表。这个中间表分别定义了两个外键，引用到article和tag两张表的主键。 多对多add属性没有 bulk参数 related_name 和related_query_name: related_name: category = models.ForeignKey(\"Category\",on_delete=models.CASCADE,null = True,related_name='articles') #因为使用了外键就会生成category.article_set属性 #views.py #在models加入related_name ='articles' article_set属性将会失效使用下面的代码 articles = category.articles.all() article = Article(title='aaa',content='123') article.author = FrontUser.objects.first() article.save() category.articles.add(article) category.save() articles = category.articles.all() #查询category_id 为2的所有数据 for article in articles: print(article) 如果想要将文章添加到某个分类中，可以使用以下方式： category = Category.objects.first() article =Article(title = 'bbb',content = 'ccc') article.author = FrontUser.objects.first() category.article_set.add(article,bulk = Flase) #bulk为false就表示自动保存，否则需要自己提前保存 使用bulk = False,那么Django会自动的保存article，而不需要在添加到category之前先保存article 或者是另外一种解决方式是，在添加category_article_set中之前，先将article保存到数据库中，但是如果article_category不能为空，那么就产生一种死循环了，article没有category不能保存，而将article添加到category.article_set中，又需要article之前是已经存在存储到数据库中的。 "},"第四章：数据库/010ORM查询条件.html":{"url":"第四章：数据库/010ORM查询条件.html","title":"010ORM查询条件","keywords":"","body":"查询操作 查找是数据库操作中一个非常重要的技术。查询一般就是使用filter、exculde以及get三个方法来实现，我们可以在调用这些方法的时候传递不同的参数来实现查询需求。在ORM层面，这些查询条件都是使用field+__+condition的方式来使用的。以下将那些常用的查询条件来--解释。 #创建数据库 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'orm_lookup_demo', 'HOST':'127.0.0.1', 'PORT':'3306', 'USER':'root', 'PASSWORD':'123456', } } #app需要在installed_app中添加 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'front' ] #在models.py中生成数据模型 from django.db import models class Article(models.Model): title = models.CharField(max_length=200) content = models.TextField() class Meta: db_table = 'article' #如果没有这个类 则生成 front_article数据表 # 有Meta这个类就会生成 article这个名字的表 #执行以下脚本 # python manage.py makemigrations # python manage.py migrate 就会生成 pycharm连接数据库出错 Server returns invalid timezone. Go to 'Advanced' tab and set 'serverTimezone'解决办法如下： 时区错误，MySQL默认的时区是UTC时区，比北京时间晚8个小时。 所以要修改mysql的时长 在mysql的命令模式下，输入： set global time_zone='+8:00'; ##提示错误 点击左边MYSQL https://dev.mysql.com/downloads/connector/j/ 下载 mysql-connector-java-5.1.46的文件 将刚下载好的文件bin.jar结尾的 JDBC.driver就会出现跳出选择框。 在pycharm中添加数据后：Ctrl+Enter 查询条件 exact: 精确的提供条件。如果提供的是一个None，那么在SQL层面就是被解释为NULL，示例代码如下： article = Article.objects.get(id__exact = 14) article = Article.objects.get(id__exact = None) article = Article.objects.filter(id__exact=1) # __exact这个写不写其实是无所谓的 print(article.query)#输出Query语句 #SELECT `article`.`id`, `article`.`title`, `article`.`content` FROM `article` WHERE `article`.`id` = 1 article1 = Article.objects.filter(title__exact='Helloworld') print(article1.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content` FROM `article` WHERE `article`.`title` = helloworld article2 = Article.objects.filter(title__exact=None) print(article2.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content` FROM `article` WHERE `article`.`title` IS NULL 以上的两个查找在翻译为SQL语句为如下： select...from article where id = 14; select...from article where id IS NULL; utf8-bin大小写敏感，utf8-ggeneral_ci大小写不敏感 相对于mysql的 iexact: 使用like进行查找，示例代码如下： article =Article.objects.filter(title__iexact='helloworld') 那么以上的查询就等价于以下的SQL语句： select ... from article where title like 'hello world'; 注意上面这个sql语句，因为mysql中，没有一个叫做ilike的，所有exact和iexact的区别实际上就是LIKE和=的区别，在大部分collation=utf8_general_ci情况下都是一样的(collation是用来对字符串比较的)。 article3 = Article.objects.filter(title__iexact='helloworld') print(article3.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content` FROM `article` WHERE `article`.`title` LIKE helloworld #因为helloworld 前后没有% 所以是精确的查找 exact与iexact他们的区别其实就是LIKE和=的区别，因为exact会被翻译成=，而iexact会被翻译成LIKE。 QuerySet.query:query可以用来查看这个ORM查询语句最终被翻译成SqL语句，但是query只能被用在QuerySet对象上，不能用在普通的ORM模型上，因此如果你的查询语句是通过get来获取数据的，那么就不能使用query，因为get返回的是满足条件的ORM模型，而不是QuerySet。如果你是通过filter等其他返回QuerySet的方法查询的，那么就可以使用Query。 cotains： 大小写敏感，判断某个字段是否包含了某个数据。示例代码如下： articles = Article.objects.filter(title__contains='hello') article = Article.objects.filter(title__contains='hello world') print(article.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content` FROM `article` WHERE `article`.`title` LIKE BINARY %hello world% # LIKE BINARY 表示大小写敏感 print(article) #>]> 在翻译成SQL语句为如下： select ... where title like binary '%hello%' 要注意的是，在使用contains的时候，翻译成的sql语句左右两边是有百分号的，意味着使用的是模糊查询，而exact翻译成sql语句左右两边是没有百分号的，意味着使用的是精确查询。 icontains 大小写不敏感的匹配查询。示例代码如下： article = Article.objects.filter(title__icontains='hello') article1 = Article.objects.filter(title__icontains='Hello') print(article1.query) # SELECT `article`.`id`, `article`.`title`, `article`.`content` FROM `article` WHERE `article`.`title` LIKE %Hello% print(article1) #>]> 在翻译成SQL语句为如下： `article`.`content` FROM `article` WHERE `article`.`title` LIKE %Hello% icontains中的i表示ignore忽略大小写 %Hello% % 表示 前面可以出现任意字符，后面也表示可以出现任意字符 contains和icontains:在被翻译成SQL的时候使用的是%hello%，就是只要整个字符串中出现了hello都能够被找到，而iexact没有百分号，那么意味着只有完全相等的时候才会被匹配到。 in： 提取那些给定的field的值是否在给定的容器中，容器可以为list、tuple或者任何一个可以迭代的对象，包括QuerySet对象：示例代码如下： article = Article.objects.filter(id__in=[1,2,3]) articles = Article.objects.filter(id__in=[1,2,3]) for article in articles: print(article) ''' ''' return HttpResponse('success') 以上代码在翻译成SQL语句为如下: select ... where id in (1,2,3) 当然也可以传递一个QuerySet对象进去，示例代码如下： inner_qs = Article.objects.filter(title__contains = 'hello') categories = Category.objects.filter(article__in=inner_qs) categories=Category.objects.filter(article__id__in=[1,2,3]) #[1,2,3] 可以为列表也可以是元组或者queryset #如果写成article__in也表示article__id__in print(categories.query) #SELECT `category`.`id`, `category`.`name` FROM `category` INNER JOIN `article` ON (`category`.`id` = `article`.`category_id`) WHERE `article`.`id` IN (1, 2, 3) for category in categories: print(category) #Category object (1) #Category object (1) #Category object (2) 如果要判断相关联的表的字段，那么也是通过__来连接。并且在做反向引用的时候，不需要写models_set直接使用模型的名字的小写化就可以了。比如通过分类去查找相应的文章，那么通过article__id__in就可以了，而不是写成article_set__id__in的形式。 当然，如果你不想使用默认的形式，可以在外键定义的时候传递related_query_name来指定反向引用的名字，示例代码如下： class Category(models.Model): name = models.CharField(max_length=100) class Meta: db_table = 'category' class Article(models.Model): title = models.CharField(max_length=200) content = models.TextField() category =models.ForeignKey(\"Category\",on_delete=models.CASCADE,null=True,related_query_name='articles') def __str__(self): return\"\"%(self.title,self.content) class Meta: db_table = 'article' 因为在category的ForeignKey中制定了related_query_name为articles，因此你不能使用article来进行反向查询了，这时候就需要通过article__id__in来进行反向查询。 并且，如果在做反向查询的时候，如果查询的字段就是模型的主键，那么可以省略掉这个字段，直接写成article__in就可以了，不需要这个id了。 以上代码的意思是获取那些文章标题包含hello的所有分类。 将翻译成以下SQL语句，示例代码如下： select ... from category where article.id in (select id from article where title like '%hello%') articles1 = Article.objects.filter(title__icontains='hello') categories1 = Category.objects.filter(articles__in=articles1) print(categories1.query) #SELECT `category`.`id`, `category`.`name` FROM `category` INNER JOIN `article` ON (`category`.`id` = `article`.`category_id`) WHERE `article`.`id` IN (SELECT U0.`id` FROM `article` U0 WHERE U0.`title` LIKE %hello%) for category in categories1: print(category) #Category object (2) in不仅仅可以指定列表/元组，还可以为QuerySet，比如要查询标题中含有hello的虽有分类可以通过以下代码来实现它： articles1 = Article.objects.filter(title__icontains='hello') categories1 = Category.objects.filter(articles__in=articles1) print(categories1.query) #SELECT `category`.`id`, `category`.`name` FROM `category` INNER JOIN `article` ON (`category`.`id` = `article`.`category_id`) WHERE `article`.`id` IN (SELECT U0.`id` FROM `article` U0 WHERE U0.`title` LIKE %hello%) for category in categories1: print(category) #Category object (2) #注意理解 文章反向查询 #反向查询是讲模型名字小写化，比如'article__in',可以通过’related_query_name'来指定自己的方式，而不使用默认的方式。 #反向引用是讲模型名字小写化，然后再加上'_set',比如`article_set`,可以通过'related_name'来指定自己的方式，而不是用默认的方式。 gt gte lt lte: 某个field的值要大于给定的值，示例代码如下： #查找id大于2的所有文章 #gt: greater than 大于 articles = Article.objects.filter(id__gt=2) print(articles) print(articles.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id` FROM `article` WHERE `article`.`id` > 2 #gte:greater than equal 大于等于 articles1 = Article.objects.filter(id__gte=2) print(articles1) print(articles1.query) # lt:lower than 小于 articles2 = Article.objects.filter(id__lt=2) print(articles2) print(articles2.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id` FROM `article` WHERE `article`.`id` startwith: 判断某个字段的值是否以某个值开始的，大小写敏感。示例代码如下： articles = Article.objects.filter(title__startwith = 'hello') 以上代码的意思是提取所有标题以hello字符串开头的文章。 将翻译成以下SQL语句： select ... where title like 'hello%' istartwith: 类似于startwith，但是大小写是不敏感的。 endswith： 判断某个字段的值是否以某个值结束，大小写敏感；示例代码如下： articles = Article.objects.filter(title__endstartwith='world') 以上代码的意思是提取所有标题以world字符串结尾的文章。 将翻译成以下SQL语句： select ... where title like '%world' iendswith #startswith 以什么开头，对大小写敏感 article = Article.objects.filter(title__startswith='hello') print(article) print(article.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id` FROM `article` WHERE `article`.`title` LIKE BINARY hello% # istartswith 以什么开头，对大小写不敏感 i ignore忽略 article1 = Article.objects.filter(title__istartswith='Hello') print(article1) print(article1.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id` FROM `article` WHERE `article`.`title` LIKE Hello% #endswith：以什么结尾，对大小写敏感 article2 = Article.objects.filter(title__endswith='world') print(article2) print(article2.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id` FROM `article` WHERE `article`.`title` LIKE BINARY %world #iendswith：以什么结尾，对大小不敏感 i ignore忽略 article3 = Article.objects.filter(title__iendswith='woRld') print(article3) print(article3.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id` FROM `article` WHERE `article`.`title` LIKE %woRld 时间的过滤条件 range 判断某个field的值是否在给定的区间中，示例代码如下： from django.utils.timezone import make_aware from datetime import datetime 建议开启USE_TE = True TIME_ZONE = 'Asia/Shanghai' range: 可以指定一个时间段，并且时间应该标记为aware时间，不然Django会报警告。示例代码如下： from datetime import datetime from django.utils.timezone import make_aware def index6(request): start_time = make_aware(datetime(year=2020,month=4,day=11,hour=5,minute=0,second=0)) #end_time = datetime(year=2020,month=4,day=11,hour=17,minute=52,second=0) end_time = make_aware(datetime(year=2020,month=4,day=11,hour=17,minute=52,second=0)) articles =Article.objects.filter(create_time__range=(start_time,end_time)) print(articles.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE `article`.`create_time` BETWEEN 2020-04-10 21:00:00 AND 2020-04-11 09:52:00 print(articles) #>]>返回数据 return HttpResponse('index6') date 用年月日来进行过滤，如果想要使用这个过滤条件，那么前提必须要在MYSQL中添加好那些时区文件，如何添加呢？下面有介绍。 https://dev.mysql.com/downloads/timezones.html网址下载`[timezone_2019c_posix.zip](https://downloads.mysql.com/general/timezone_2019c_posix.zip)`文件，将里面的文件替换data下mysql C:\\ProgramData\\MySQL\\MySQL Server 5.7\\Data\\mysql里面的文件，注意备份原mysql里面文件。 def index7(request): articles = Article.objects.filter(create_time__date=datetime(year=2020,month=4,day=11)) print(articles.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE DATE(CONVERT_TZ(`article`.`create_time`, 'UTC', 'Asia/Shanghai')) = 2020-04-10 print(articles) return HttpResponse('index7') 针对某些date或者datetime类型的字段，可以指定date的范围，并且这个时间过滤，还可以使用链式调用。示例代码如下： def index7(request): articles = Article.objects.filter(create_time__date=datetime(year=2020,month=4,day=11)) print(articles.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE DATE(CONVERT_TZ(`article`.`create_time`, 'UTC', 'Asia/Shanghai')) = 2020-04-11 print(articles) return HttpResponse('index7') 以上代码的意思是查找时间为2010/4/11这一天发表的所有文章。SQL语句如下： SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE DATE(CONVERT_TZ(`article`.`create_time`, 'UTC', 'Asia/Shanghai')) = 2020-04-11 注意，因为默认情况下MySQL的表中是没有存储时区相关的信息的，因此我们需要下载一些时区表的文件，然后添加到mysql的配置路径中，如果你用的是windows操作系统，那么在http://dev.mysql.com/downloads/timezones.html下载`timezone_2019c_posix.zip`，然后将下载下来的所有文件拷贝到`C:\\ProgramData\\MySQL\\MySQL Server 5.7\\Data\\mysql`中，如果提示文件名重复，那么选择覆盖即可。 如果用的是linux或者mac系统，那么在命令行中执行以下命令：mysql_tzinfo_to_sql /user/share/zoneinfo | mysql -D mysql -u root -p，然后输入密码，从系统中加载时区文件更新到mysql中。 year 根据年份进行查找，示例代码如下： articles = Article.objects.filter(create_time__date=datetime(year=2020,month=4,day=11)) print(articles.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE DATE(CONVERT_TZ(`article`.`create_time`, 'UTC', 'Asia/Shanghai')) = 2020-04-10 print(articles) articles1 = Article.objects.filter(create_time__year=2020) #articles1 = Article.objects.filter(create_time__year__gte=2020) #gte表示大于等于2020年的都可以 #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE `article`.`create_time` BETWEEN 2019-12-31 16:00:00 AND 2020-12-31 15:59:59.999999 print(articles1.query) print(articles1) month: 同year，根据月份进行查找。 day： 同year，根据日期进行查找 week_day： Django 1.11新增的查找方式，同year根据星期几进行查找，1表示的是星期天，7表示星期六，2-6代表的是星期一到星期五。 articles2 = Article.objects.filter(create_time__week_day=7) print(articles2.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE DAYOFWEEK(CONVERT_TZ(`article`.`create_time`, 'UTC', 'Asia/Shanghai')) = 7 print(articles2) #>, >, >, >]> time 因为秒数后面有小数，所以就要用区间。 start_time = time(hour=21,minute=46,second=21) end_time = time(hour=21,minute=46,second=22) articles3 = Article.objects.filter(create_time__time__range=(start_time,end_time)) print(articles3.query) print(articles3) isnull: 根据值是否为空进行查找，示例代码如下： articles = Article.objects.filter(pub_date__isnull = False) articles = Article.objects.filter(create_time__isnull=False)#True #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE `article`.`create_time` IS NULL print(articles.query) print(articles) return HttpResponse('index8') 以上的代码的意思是获取所有发布日期不为空的文章。 将来翻译成SQL语句如下： select ... where pub_date is not null; regex和iregex: 大小写敏感和大小写不敏感的正则表达式。示例代码如下： articles = Article.objects.filter(title__regex=r'^hello') articles1 = Article.objects.filter(title__regex=r'^hello') #大小写区分 print(articles1.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE `article`.`title` REGEXP BINARY ^hello print(articles1) 以上代码的意思是提取所有标题以hello字符串开头的文章，将翻译成以下的SQL语句： select ... where title regex binary '^hello'; iregex是大小写不敏感的。 根据关联的表进行查询： 假如现在有两个ORM模型，一个是Article，一个是Category代码如下： class Category(models.Model): ```文章分类 name = models.CharField(max_length = 100) class Article(models.Model): ```文章表``` title = models.CharField(max_length=100,null= True) category = models.ForeignKey(\"Category\",on_delete=models.CASCADE) 比如想要获取文章标题中包含'hello'的所有分类，那么可以通过以下代码来实现： ```python category = Category.objects.filter(article__title__contains(\"hello\")) "},"第四章：数据库/011ORM聚合函数.html":{"url":"第四章：数据库/011ORM聚合函数.html","title":"011ORM聚合函数","keywords":"","body":"聚合函数 配置数据库 创建APP 如果你用原生SQL，则可以使用聚合函数来提取数据，比如提取某个商品销售的数量，那么可以使用Count，如果想要知道商品的销售的平均价格，那么可以使用Avg. 聚合函数是通过aggregate方法来实现的。在讲解这些聚合函数用法的时候，都是基于以下的模型对象来实现的。 #models.py from django.db import models class Author(models.Model): '''作者模型''' name = models.CharField(max_length=100) age = models.IntegerField() email = models.EmailField() class Meta: db_table = 'author' class Publisher(models.Model): '''出版社模型''' name = models.CharField(max_length=300) class Meta: db_table = 'publisher' class Book(models.Model): '''图书模型''' name = models.CharField(max_length=300) pages = models.IntegerField() price = models.FloatField() rating = models.FloatField() author = models.ForeignKey(Author,on_delete=models.CASCADE) publisher = models.ForeignKey(Publisher,on_delete=models.CASCADE) class Meta: db_table = 'book' class BookOrder(models.Model): '''图书订单模型''' book = models.ForeignKey(\"Book\",on_delete=models.CASCADE) price = models.FloatField() class Meta: db_table = 'book_order' 1、Avg：求平均值。比如想要获取所有图书的价格平均值，那么可以使用以下代码实现。 from django.db.models import Avg result = Book.objects.aggregate(Avg('price')) print(result) 以上的打印结果是： {\"price__avg\":23} 1、所有的聚合函数都是放在'django.db,models'下面。 2、聚合函数不能够单独的执行，需要放在一些可以执行聚合函数的方法下面去执行。比如aggregate示例代码如下： def index(request): #获取所有图书定价的平均价格 #result = Book.objects.aggregate(Avg(\"price\")) result = Book.objects.aggregate(price_avg = Avg(\"price\")) #price_avg 交做它的别名 print(result)#result 是一个字典类型 #{'price_avg': 97.25} #字典调用方法 如下： print(result['price_avg']) print(connection.queries) #[{'sql': 'SELECT @@SQL_AUTO_IS_NULL', 'time': '0.000'}, {'sql': 'SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED', 'time': '0.000'}, {'sql': 'SELECT AVG(`book`.`price`) AS `price__avg` FROM `book`', 'time': '0.000'}] #django在执行sql语句的时候执行了其他的语句 return HttpResponse('success') 3、聚合函数执行完成后，给这个聚合函数的值个名字，取名字的规则，默认是filed+__+聚合函数名字形成的。比如以上代码形成的名字叫做price_avg。如果不想使用默认的名字，那么可以在使用聚合函数的时候传递关键字参数进去，参数的名字就是聚合函数执行完成的名字。示例代码如下： result = Book.objects.aggregate(price_avg = Avg(\"price\")) 以上传递了关键字参数price_avg = Avg('price')，那么以后Avg聚合函数执行完成的名字就叫做Avg 4、aggregate这个方法不会返回一个QuerySet对象，而是返回一个字典。这个字典中的key就是聚合函数的名字，值就是聚合函数执行后的结果。 aggregate和annotate的区别： def index2(request): #我要获取每一本图书销售的平均价格 #result = Book.objects.aggregate(avg=Avg('bookorder__price')) #print(result)#{'avg': 91.0} #print(connection.queries) #[{'sql': 'SELECT @@SQL_AUTO_IS_NULL', 'time': '0.000'}, {'sql': 'SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED', 'time': '0.000'}, {'sql': 'SELECT AVG(`book_order`.`price`) AS `avg` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`)', 'time': '0.000'}] books = Book.objects.annotate(avg=Avg('bookorder__price')) print(books) #, , , ]> print('+'*40) for book in books: print('%s/%s' % (book.name,book.avg)) ''' 三国演义/89.33333333333333 水浒传/93.5 西游记/None 红楼梦/None ''' print(connection.queries) #{'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, AVG(`book_order`.`price`) AS `avg` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY NULL LIMIT 21' # {'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, AVG(`book_order`.`price`) AS `avg` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY NULL' return HttpResponse('index2') aggregate和annotate的相同和不同： 相同：这两个方法都可以执行聚合函数。 不同： aggregate 返回的是一个字典，在这个字典中存储的是这个聚合函数执行的结果，而annotate返回的是一个QuerySet 对象，并且会在查找的模型上添加一个聚合函数的属性。 aggregate不会做分组，而annotate会使用group by子句进行分组，只有调用了group by子句，才能对每一条数据求聚合函数的值。 Count：用来求某个数据的个数，比如要求所有图书的数量，那么可以使用以下代码： #book表中总共有多少本书，（book表中总共有多少个书） result = Book.objects.aggregate(book_nums=Count('id',distinct=True)) #distinct=True 表示不统计重复的值 print(result) #{'book_nums': 4} print(connection.queries) #[ {'sql': 'SELECT COUNT(`book`.`id`) AS `book_nums` FROM `book`', 'time': '0.031'}] result1 = Author.objects.aggregate(email_nums = Count('email',distinct=True)) #'SELECT COUNT(DISTINCT `book`.`id`) AS `book_nums` FROM `book`', 'time': '0.000'}, {'sql': 'SELECT COUNT(DISTINCT `author`.`email`) AS `email_nums` FROM `author`', 'time': '0.000'} print(result1) print(connection.queries) 并且Count可以传递distinct=True参数，用来剔除那些重复的值，只保留一个。 比如要获取作者表中，不同邮箱的个数，那么这时候可以使用distinct=True。 示例代码如下： result1 = Author.objects.aggregate(email_nums = Count('email',distinct=True)) #'SELECT COUNT(DISTINCT `book`.`id`) AS `book_nums` FROM `book`', 'time': '0.000'}, {'sql': 'SELECT COUNT(DISTINCT `author`.`email`) AS `email_nums` FROM `author`', 'time': '0.00'} #===annotate 先分组 #统计每本书的销量 books = Book.objects.annotate(book_nums=Count('bookorder'))#默认bookorder__id for book in books: print('%s/%s'% (book.name,book.book_nums)) ''' 三国演义/3 水浒传/2 西游记/0 红楼梦/0 ''' print(connection.queries) #{'sql': 'SELECT COUNT(DISTINCT `author`.`email`) AS `email_nums` FROM `author`', 'time': '0.000'}, {'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, COUNT(`book_order`.`id`) AS `book_nums` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY NULL'}] 3、Max和Min：获取指定对象的最大值和最小值。比如想要获取Author表中，最大的年龄和最小的年龄分别是多少，那么可以通过以下代码来实现： from django db.models import Max,Min result = Author.objects.aggregate(Max('age'),Min('age')) 如果最大的年龄是88最小的年龄是18，那么以上的result将为： {'age__max':88,'age__min':18} result = Author.objects.aggregate(max=Max('age'),min = Min('age')) print(result) #{'max': 46, 'min': 28} print(connection.queries) #'sql': 'SELECT MAX(`author`.`age`) AS `max`, MIN(`author`.`age`) AS `min` FROM `author` #获取每一本图书售卖的时候最大的价格和最小的价格 books = Book.objects.annotate(max=Max('bookorder__price'),min =Min('bookorder__price')) for book in books: print('%s/%s/%s'%(book.name,book.max,book.min)) ''' 三国演义/95.0/85.0 水浒传/94.0/93.0 西游记/None/None 红楼梦/None/None ''' print(connection.queries) #'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, MAX(`book_order`.`price`) AS `max`, MIN(`book_order`.`price`) AS `min` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY NULL' 4、Sum：求指定对象的总和。比如要求图书的销售总额，那么可以使用以下代码实现：`` from django db.models import Sum result = Book.objects.annotate(total=Sum(\"bookstore__price\")).values('name','total') def index5(request): #1.求所有图书的销售总额 result = BookOrder.objects.aggregate(total=Sum('price')) print(result) #{'total': 455.0} print(connection.queries) #'SELECT SUM(`book_order`.`price`) AS `total` FROM `book_order`' #求每一本书的销售总额 books = Book.objects.annotate(total=Sum(\"bookorder__price\")) for book in books: print(\"%s/%s\"%(book.name,book.total)) ''' 三国演义/268.0 水浒传/187.0 西游记/None 红楼梦/None ''' print(connection.queries) #'sql': 'SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED', 'time': '0.000'}, {'sql': 'SELECT SUM(`book_order`.`price`) AS `total` FROM `book_order`', 'time': '0.016'}, {'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, SUM(`book_order`.`price`) AS `total` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY NULL' #3、求2020年度每一本图书销售总额 result = BookOrder.objects.filter(create_time__year=2020).aggregate(total=Sum('price')) print(result) #{'total': 455.0} print(connection.queries) #'sql': 'SELECT SUM(`book_order`.`price`) AS `total` FROM `book_order`' #'sql': \"SELECT SUM(`book_order`.`price`) AS `total` FROM `book_order` WHERE `book_order`.`create_time` BETWEEN '2020-01-01 00:00:00' AND '2020-12-31 23:59:59.999999'\" #求每一本图书在2020年度销售总额 books = Book.objects.filter(bookorder__create_time__year=2020).annotate(total=Sum(\"bookorder__price\")) for book in books: print('%s/%s' % (book.name, book.total)) ''' 三国演义/268.0 水浒传/187.0 ''' print(connection.queries) #'sql': \"SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, SUM(`book_order`.`price`) AS `total` FROM `book` INNER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) WHERE `book_order`.`create_time` BETWEEN '2020-01-01 00:00:00' AND '2020-12-31 23:59:59.999999' GROUP BY `book`.`id` ORDER BY NULL\" return HttpResponse('index5') aggregate和annotate方法可以在任何的QuerySet对象上调用，因此只要返回了QuerySet兑现，那么就可以进行链式调用，比如要获取2020度销售总额，可以先过滤年份，再求聚合函数，示例代码如上。 "},"第四章：数据库/012F表达式和Q表达式.html":{"url":"第四章：数据库/012F表达式和Q表达式.html","title":"012F表达式和Q表达式","keywords":"","body":"F表达式和Q表达式 F表达式 F表达式是用来优化orm曹组偶数据库的，比如我们要将公司所有员工的薪水都增加1000元，如果按照正常的流程，用该是先从数据库中提取所有的员工工资到python内存中，然后使用python内存中做完运算，之后再保存到数据库中。示例代码如下： employees = Employee.objets.all() for employee in employees: employee.salary+=1000 employee.save() 而我们的F表达式就可以优化这个流程，他可以不需要先把数据从数据库中提取出来，让计算完成后再保存回去，他可以直接执行SQL语句，就将员工的工资增加1000元。示例代码如下： from django.db.models import F Employee.object.update(salary=F(\"salary\")+1000) ################################################ #给每一本图书的售价增加10元 Book.objects.update(price=F('price')+10) print(connection.queries[-1]) return HttpResponse('index6') F表达式并不会马上从数据库中获取数据，而是在生成SQL语句的时候，动态的获取传给F表达式的值。 比如如果想要获取作者中，name和email相同的作者数据。如果不适用F表达式，那么需要使用以下代码来完成： authors = Author.objects.all() for author in authors: if author.name == author.email: print(author) 利用F的应用： authors = Author.objects.filter(name=F('email')) for author in authors: print('%s/%s'%(author.name,author.email)) #wce@qq.com/wce@qq.com print(connection.queries[-1]) #{'sql': 'SELECT `author`.`id`, `author`.`name`, `author`.`age`, `author`.`email` FROM `author` WHERE `author`.`name` = `author`.`email`', 'time': '0.016'} Q表达式： 如果想要实现所有价格高于100元，并且评分达到9.0以上评分的图书。那么可以通过以下代码来实现： books =Book.objects.filter(price__get=100,rating__get=9) 以上这个案例是一个并集查询，可以简单的通过传递多个条件进去来实现。 但是如果想要实现一些复杂的查询语句，比如要查询所有价格低于10，或者是评分低于9分的图书。那就没有办法通过传递多个条件进去实现了。这时候需要使用Q表达式来实现了。示例代码如下： from django.db.models import Q books = Book.objects.filter(Q(price__lte=10)|Q(rating__lte=9)) 以上是进行或运算，当然还可以进行其他的运算，比如与&和~等。一些用Q表达式的例子如下： #3.获取价格低于100元或者评分低于4分的图书 books2 = Book.objects.filter(Q(price__lt=127)|Q(rating__lt=4.85)) for book in books2: print(\"%s/%s/%s\" % (book.name, book.price, book.rating)) ''' 三国演义/128.0/4.8 水浒传/127.0/4.83 西游记/125.0/4.85 ''' Q可以做 与 或 非运算！ #4.价格大于100，并且图书名字中不包含'记'字的图书 books = Book.objects.filter(Q(price__gte=100)&~Q(name__icontains='传')) for book in books: print(\"%s/%s/%s\" % (book.name, book.price, book.rating)) #水浒传/127.0/4.83 如果~ 这是 非 ''' 三国演义/128.0/4.8 西游记/125.0/4.85 红楼梦/129.0/4.9 ''' "},"第四章：数据库/013Query Set API.html":{"url":"第四章：数据库/013Query Set API.html","title":"013Query Set API","keywords":"","body":"Query Set API 我们通常做查询操作的时候，都是通过模型名字.objects的方式进行操作。其实模型名字.objects是一个django.db.models.manager.Manager对象，而manager这个类是一个\"空壳\"的类，他本身没有任何的属性和方法的，他的方法全部都是通过python动态添加的方式，从QuerySet类中拷贝多来的。示例图如下： 以我们如果想要学习ORM模型的查找操作，必须首先要学会QuerySet上的一些API的使用。 返回新的QuerySet的方法： 在使用QuerySet进行查找操作的时候，可以提供多种操作，比如过滤完后还要根据某个字段进行排序，那么这一系列的操作我们可以通过一个非常流畅的链式调用的方法进行。比如要从文章中获取标题为123，并且提取后要将结果根据发布的时间进行排序，那么可以使用以下方式来完成： articles = Article.objects.filter(title='123').order_by('create_time') #可以先进行过滤 books = Book.objects.filter(id__gte=2) books.filter(id !=3) books.filter(~Q(id=3)) #id等于3然后反转 #可以进行两个filter books = Book.objects.filter(id__gte=2).filter(~Q(id=3)) 可以看到order_by方法是直接在filter执行后调用的。这说明filter返回的对象是一个拥有order_by方法的对象。而这个对象正是一个新的QuerySet对象。因此可以使用order_by方法。 那么以下将介绍在那些会返回新的QuerySet对象的方法。 1、filter：将满足条件的数据提取出来，返回一个新的QuerySet。具体的filter可以提供什么条件查询。请见查询操作章节。 2、exclude：排除满足条件的数据，返回一个新的QuerySet。示例代码如下： Article.objects.exclude(title__contains='hello') #排除掉id为3的数据 books =Book.objects.filter(id__gte=2).exclude(id=3) 以上代码的意思是提取那些标题不包含hello的图书。 3、annotate：给QuerySet中的每个对象都添加一个使用查询表达式（聚合函数、F表达式、Q表达式、Func表达式等）的新字段。示例代码如下： articles = Article.objects.annotate(author_name=F(\"author__name\")) #会调用出图书的作者名字，有外键数据表 books = Book.objects.annotate(author_name=F(\"author__name\")) 以上代码将在每个对象中都添加一个author__name的字段，用来显示这个文章的作者的年龄。 4、order_by：指定将查询的结果根据某个字段进行排序。如果要倒叙排序，那么可以在这个字段的前面加一个负号。示例代码如下： # 根据创建的时间正序排序 articles = Article.objects.order_by(\"create_time\") # 根据创建的时间倒序排序，在字段的前面加一个 - 号 articles = Article.objects.order_by(\"-create_time\") # 根据作者的名字进行排序 articles = Article.objects.order_by(\"author__name\") # 首先根据创建的时间进行排序，如果时间相同，则根据作者的名字进行排序 articles = Article.objects.order_by(\"create_time\",'author__name') #================================================================ #根据create_time从小到大进行排序 orders = BookOrder.objects.order_by('price') for order in orders: print('%s/%s'% (order.id,order.price)) ''' 2/85.0 3/88.0 5/93.0 4/94.0 1/95.0 ''' print(connection.queries[-1]) #'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` ORDER BY `book_order`.`price` ASC' orders = BookOrder.objects.order_by('-price')#从大到小排序 for order in orders: print(order.price) ''' 95.0 94.0 93.0 88.0 85.0 ''' print(connection.queries[-1]) #'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` ORDER BY `book_order`.`price` DESC' #首先根据book_id从大到小排序，如果一样那么根据price从大到小进行排序 orders = BookOrder.objects.order_by('-book_id','-price') for order in orders: print(order.book_id,',',order.price) ''' 2 , 94.0 2 , 93.0 1 , 95.0 1 , 88.0 1 , 85.0 ''' #提取图书数据，根据图书的销量进行排序（从大到小进行排序） books = Book.objects.annotate(order_nums=Count('bookorder__id')).order_by('-order_nums') for book in books: print(book.name,book.order_nums) ''' 三国演义 3 水浒传 2 西游记 0 红楼梦 0 ''' print(connection.queries[-1]) #'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, COUNT(`book_order`.`id`) AS `order_nums` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY `order_nums` DESC' return HttpResponse('index3') 一定要注意的一点是，多个order_by，会把前面排序的规则给打乱，而使用后面的排序方式。比如以下代码： articles = Article.objects.order_by(\"create_time\").order_by(\"author__name\") 他会根据作者的名字进行排序，而不是使用文章的创建时间。 values：用来指定在提取数据出来，需要提取哪些字段。默认情况下会把表中所有的字段全部都提取出来，可以使用values来进行指定，并且使用了values方法后，提取出的QuerySet中的数据类型不是模型，而是在values方法中指定的字段和值形成的字典： articles = Article.objects.values(\"title\",'content') for article in articles: print(article) books = Book.objects.values('id','name').all() #queryset里面存储的是 字典 for book in books: print(book['id'],book['name']) ''' 1 三国演义 2 水浒传 3 西游记 4 红楼梦 ''' 以上打印出来的article是类似于{\"title\":\"abc\",\"content\":\"xxx\"}的形式。 如果在values中没有传递任何参数，那么将会返回这个恶模型中所有的属性。 values的返回值同样也是一个QuerySet对象，但是返回值是一个字典类型! 如果我们想要提取的是这个模型上关联的对象的属性，那么也是可以的，查找顺序跟filter的用法是一样的。示例代码如下： books = Book.objects.values('id', 'name',author_name = F('author__name')).all() # queryset里面存储的是 字典 # F表达式经常用于动态的查找 for book in books: print(book) ''' {'id': 1, 'name': '三国演义', 'author__name': '罗贯中'} {'id': 2, 'name': '水浒传', 'author__name': '施耐庵'} {'id': 3, 'name': '西游记', 'author__name': '吴承恩'} {'id': 4, 'name': '红楼梦', 'author__name': '曹雪芹'} 利用F表达式后： {'id': 1, 'name': '三国演义', 'author_name': '罗贯中'} {'id': 2, 'name': '水浒传', 'author_name': '施耐庵'} {'id': 3, 'name': '西游记', 'author_name': '吴承恩'} {'id': 4, 'name': '红楼梦', 'author_name': '曹雪芹'} ''' 以上将会提取author的name字段，如果我们不想要这个名字，想要更改这个名字，那么可以使用关键字参数。F表达式取得名字不能与已有字段重复，否则会出错！示例代码如上！ 在values中也是可以使用聚合函数的，代码如下： #使用count聚合函数 books = Book.objects.values('id','name',order_nums=Count('bookorder__id')) for book in books: print(book) ''' {'id': 1, 'name': '三国演义', 'order_nums': 3} {'id': 2, 'name': '水浒传', 'order_nums': 2} {'id': 3, 'name': '西游记', 'order_nums': 0} {'id': 4, 'name': '红楼梦', 'order_nums': 0} ''' print(connection.queries[-1]) #'SELECT `book`.`id`, `book`.`name`, COUNT(`book_order`.`id`) AS `order_nums` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY NULL' values_list：类似于values。只不过返回的QuerySet中，存储的不是字典，而是元组。示例代码如下： articles = Article.objects.values_list(\"id\",\"title\") print(articles) books = Book.objects.values_list() print(type(books)) # for book in books: print(book) '''返回的是元组数据 (1, '三国演义', 987, 98.0, 4.8, 3, 1) (2, '水浒传', 967, 97.0, 4.83, 4, 1) (3, '西游记', 1004, 95.0, 4.85, 2, 2) (4, '红楼梦', 1007, 99.0, 4.9, 1, 2) ''' print('=' * 50) books = Book.objects.values_list('name',flat=True) #只获取到name这个字段 print(type(books)) # for book in books: print(book) '''返回的是元组数据,如果元组只有一个元素，那么后边就会有一个逗号 ('三国演义',) ('水浒传',) ('西游记',) ('红楼梦',) 使用flat=True后的数据，如果有两个字段就会出现错误 三国演义 水浒传 西游记 红楼梦 ''' 那么在打印articles后，结果为`等。 如果在values_list中只有一个字段。那么你可以传递flat=True`来将结果扁平化。示例代码如下： articles1 = Article.objects.values_list(\"title\") >> articles2 = Article.objects.values_list(\"title\",flat=True) >> 看上面的代码 一定要注意的是，flat只能用在只有一个字段的情况下，否则就会报错！ 7、all：获取这个ORM模型的QuerySet对象。all在实际的应用中使用的比较少！ 这个返回简单的返回一个QuerySet对象，这个QuerySet对象没有经过任何的修改（比如：过滤）等。 def index5(request): books = Book.objects.all() for book in books: print(book)#Book object (1)输出的是一个对象 print(book.id,book.name)#这里可以输出数据 4 红楼梦等 return HttpResponse(\"index5\") 8、select_related：在提取某个模型的数据的同时，也提前将相关联的数据提取出来。比如提取文章数据，可以使用select_related将author信息提取出来，以后再次使用article.author的时候就不需要再次去访问数据库了。可以减少数据库查询的次数。示例代码如下： article = Article.objects.get(pk=1) >> article.author # 重新执行一次查询语句 article = Article.objects.select_related(\"author\").get(pk=2) >> article.author # 不需要重新执行查询语句了 def index6(requeset): #books = Book.objects.all()#应该是book关联的author字段中的名字，此时每次都需要查询语句有点浪费资源 books = Book.objects.select_related(\"author\",\"publisher\")#在一次查询中讲author查询出来了,这个地方只能使用外键的字段 for book in books: #print(book.name) print(book.author.name) print(book.publisher.name) ''' 罗贯中 中国邮电出版社 施耐庵 中国邮电出版社 吴承恩 清华大学出版社 曹雪芹 清华大学出版社 ''' print(connection.queries[-1]) #'SELECT `author`.`id`, `author`.`name`, `author`.`age`, `author`.`email` FROM `author` WHERE `author`.`id` = 1 LIMIT 21' selected_related只能用在一对多或者一对一中，不能用在多对多或者多对一中。只能用在外键关联的对象身上。比如可以提前获取文章的作者，但是不能通过作者获取这个作者的文章，或者是通过某篇文章获取这个文章所有的标签。 9、prefetch_related：这个方法和select_related非常的类似，就是在访问多个表中的数据的时候，减少查询的次数。这个方法是为了解决多对一和多对多的关系的查询问题。比如要获取标题中带有hello字符串的文章以及他的所有标签，示例代码如下： from django.db import connection articles = Article.objects.prefetch_related(\"tag_set\").filter(title__contains='hello') print(articles.query) # 通过这条命令查看在底层的SQL语句 for article in articles: print(\"title:\",article.title) print(article.tag_set.all()) # 通过以下代码可以看出以上代码执行的sql语句 for sql in connection.queries: print(sql) def index7(request): # books = Book.objects.all() # for book in books: # print('='*30) # print(book.name) # orders = book.bookorder_set.all()#sql语句查询的次数多了 # #对象.模型类小写_set.all 访问1对多模型 # for order in orders: # print(order.id) # ''' # 三国演义 # 1 # 2 # 3 # ============================== # 水浒传 # 4 # 5 # ============================== # 西游记 # ============================== # 红楼梦 # ''' print('*'*80) # books = Book.objects.prefetch_related(\"bookorder_set\") # #将所有的book查询出来，更具book ID将订单查询出来！做了两次查询 # for book in books: # print('='*30) # print(book.name) # orders = book.bookorder_set.all()#sql语句查询的次数多了 # #对象.模型类小写_set.all 访问1对多模型 # for order in orders: # print(order.id) # #print(connection.queries) # #{'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id` FROM `book`', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE `book_order`.`book_id` IN (1, 2, 3, 4)', 'time': '0.000'} # # books = Book.objects.prefetch_related('author') # for book in books: # print(book.author.name) # ''' # 罗贯中 # 施耐庵 # 吴承恩 # 曹雪芹 # ''' # print(connection.queries) #'SELECT `author`.`id`, `author`.`name`, `author`.`age`, `author`.`email` FROM `author` WHERE `author`.`id` IN (1, 2, 3, 4)' #=========================================================== #过滤价格大于90元的 #传统做法 # books =Book.objects.prefetch_related('bookorder_set') # #如果使用prefetch_related的时候，就不能使用类似filter产生新sql语句的方法 # for book in books: # print('='*50) # print(book.name) # orders = book.bookorder_set.filter(price__gte=90)#因使用filter，所以prefetch_related失效 # for order in orders: # print(order.id) # print(connection.queries) ''' 三国演义 1 ================================================== 水浒传 4 5 ================================================== 西游记 ================================================== 红楼梦 [{'sql': 'SELECT @@SQL_AUTO_IS_NULL', 'time': '0.000'}, {'sql': 'SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED', 'time': '0.000'}, {'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id` FROM `book`', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE `book_order`.`book_id` IN (1, 2, 3, 4)', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE (`book_order`.`book_id` = 1 AND `book_order`.`price` >= 90.0e0)', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE (`book_order`.`book_id` = 2 AND `book_order`.`price` >= 90.0e0)', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE (`book_order`.`book_id` = 3 AND `book_order`.`price` >= 90.0e0)', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE (`book_order`.`book_id` = 4 AND `book_order`.`price` >= 90.0e0)', 'time': '0.000'}] ''' #解决办法，使用Prefetch类 prefetch = Prefetch('bookorder_set',queryset=BookOrder.objects.filter(price__gte=90)) books = Book.objects.prefetch_related(prefetch) for book in books: print('='*50) print(book.name) orders = book.bookorder_set.all() for order in orders: print(order.id) print(connection.queries) #{'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id` FROM `book`', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE (`book_order`.`price` >= 90.0e0 AND `book_order`.`book_id` IN (1, 2, 3, 4))', 'time': '0.000'} return HttpResponse('index7') 但是如果在使用article.tag_set的时候，如果又创建了一个新的QuerySet那么会把之前的SQL优化给破坏掉。比如以下代码： tags = Tag.obejcts.prefetch_related(\"articles\") for tag in tags: articles = tag.articles.filter(title__contains='hello') #因为filter方法会重新生成一个QuerySet，因此会破坏掉之前的sql优化 # 通过以下代码，我们可以看到在使用了filter的，他的sql查询会更多，而没有使用filter的，只有两次sql查询 for sql in connection.queries: print(sql) 那如果确实是想要在查询的时候指定过滤条件该如何做呢，这时候我们可以使用django.db.models.Prefetch来实现，Prefetch这个可以提前定义好queryset。示例代码如下： tags = Tag.objects.prefetch_related(Prefetch(\"articles\",queryset=Article.objects.filter(title__contains='hello'))).all() for tag in tags: articles = tag.articles.all() for article in articles: print(article) for sql in connection.queries: print('='*30) print(sql) 因为使用了Prefetch，即使在查询文章的时候使用了filter，也只会发生两次查询操作。 defer：在一些表中，可能存在很多的字段，但是一些字段的数据量可能是比较庞大的，而此时你又不需要，比如我们在获取文章列表的时候，文章的内容我们是不需要的，因此这时候我们就可以使用defer来过滤掉一些字段。这个字段跟values有点类似，只不过defer返回的不是字典，而是模型。示例代码如下： articles = list(Article.objects.defer(\"title\")) for sql in connection.queries: print('='*30) print(sql) 在看以上代码的sql语句，你就可以看到，查找文章的字段，除了title，其他字段都查找出来了。当然，你也可以使用article.title来获取这个文章的标题，但是会重新执行一个查询的语句。示例代码如下： articles = list(Article.objects.defer(\"title\")) for article in articles: # 因为在上面提取的时候过滤了title # 这个地方重新获取title，将重新向数据库中进行一次查找操作 print(article.title) for sql in connection.queries: print('='*30) print(sql) 10、defer虽然能过滤字段，但是有些字段是不能过滤的，比如id，即使你过滤了，也会提取出来。返回一个QuerySet对象,并且返回一个模型，而不是字典。 books = Book.objects.defer(\"name\") for book in books: print(book.id) #print(book.name)会查询到但是会重新查询数据库了，会浪费资源 print(type(book))# 类的模型 print(connection.queries) #'sql': 'SELECT `book`.`id`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id` FROM `book` #上面的sql语句过滤掉了 book.id语句 11、only：跟defer类似，只不过defer是过滤掉指定的字段，而only是只提取指定的字段。同样会查询id返回一个QuerySet对象,并且返回一个模型，而不是字典。 books = Book.objects.only(\"name\")#只提取一个name for book in books: print(book.id,book.name) print(type(book))# 类的模型 print(connection.queries) # {'sql': 'SELECT `book`.`id`, `book`.`name` FROM `book`', 'time': '0.000'} only和defer两个方法，如果没有指定的字段，后面请求的话，也会重新发起一次请求。是可以查询的，但是会影响资源，要谨慎使用！ 12、get：获取满足条件的数据。这个函数只能返回一条数据，并且如果给的条件有多条数据，那么这个方法会抛出MultipleObjectsReturned错误，如果给的条件没有任何数据，那么就会抛出DoesNotExit错误。所以这个方法在获取数据的时候，只能有且只有一条。 def index9(request): book = Book.objects.get(pk = 2) #满足的条件只能有一个当有多个的时候或者没有值得时候就会报错！ print(book) #Book object (2) #水浒传 print(book.name) #Book object (1) print(connection.queries) #'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id` FROM `book` WHERE `book`.`id` = 1 LIMIT 21' return HttpResponse('index9') 13、create：创建一条数据，并且保存到数据库中。这个方法相当于先用指定的模型创建一个对象，然后再调用这个对象的save方法。示例代码如下： article = Article(title='abc') article.save() # 下面这行代码相当于以上两行代码 article = Article.objects.create(title='abc') #============================================ def index10(request): #publisher = Publisher(name='知了出版社') #publisher.save() #print(connection.queries[2:]) #[{'sql': \"INSERT INTO `publisher` (`name`) VALUES ('知了出版社')\", 'time': '0.032'}] publisher = Publisher.objects.create(name='知了课堂出版社')#相当于上面的两行代码 print(connection.queries[2:]) #[{'sql': \"INSERT INTO `publisher` (`name`) VALUES ('知了课堂出版社')\", 'time': '0.031'}] return HttpResponse('index10') 14、get_or_create：根据某个条件进行查找，如果找到了那么就返回这条数据，如果没有查找到，那么就创建一个。示例代码如下： obj,created= Category.objects.get_or_create(title='默认分类') models.py def publisher_default(): return Publisher.objects.get_or_create(name ='默认的出版社') class Book(models.Model): name = models.CharField(max_length=300) pages = models.IntegerField() price = models.FloatField() rating = models.FloatField() author = models.ForeignKey(Author, models.DO_NOTHING) publisher = models.ForeignKey('Publisher', on_delete=models.SET_DEFAULT,default=publisher_default) views.py def index11(request): result = Publisher.objects.get_or_create(name = '知了出版社') #(, False) 知了出版社存在，就不会创建 print(result) #如果数据不存在 result = Publisher.objects.get_or_create(name='知了ABC出版社') #(, True) print(result) return HttpResponse('index11') 如果有标题等于默认分类的分类，那么就会查找出来，如果没有，则会创建并且存储到数据库中。 这个方法的返回值是一个元组，元组的第一个参数obj是这个对象，第二个参数created代表是否创建的。 15、bulk_create：一次性创建多个数据。示例代码如下： #创建多个出版社 publisher = Publisher.objects.bulk_create( [ Publisher(name = '123出版社'), Publisher(name='abc出版社'), ] ) #注意：如果数据库中存在，同样会继续创建 16、count：获取提取的数据的个数。如果想要知道总共有多少条数据，那么建议使用count，而不是使用len(articles)这种。因为count在底层是使用select count(*)来实现的，这种方式比使用len函数更加的高效。 count = Book.objects.count() print(count)#4 print(connection.queries) #SELECT COUNT(*) AS `__count` FROM `book` 17、first和last：返回QuerySet中的第一条和最后一条数据。 18、aggregate：使用聚合函数。 19、exists：判断某个条件的数据是否存在。如果要判断某个条件的元素是否存在，那么建议使用exists，这比使用count或者直接判断QuerySet更有效得多。示例代码如下： result = Book.objects.filter(name = '三国演义').exists() print(result)#True 如果数据存在则返回True否则返回False print(connection.queries) #\"SELECT (1) AS `a` FROM `book` WHERE `book`.`name` = '三国演义' LIMIT 1\" if Article.objects.filter(title__contains='hello').exists():#效率最高的 print(True) 比使用count更高效： if Article.objects.filter(title__contains='hello').count() > 0: print(True) 也比直接判断QuerySet更高效： if Article.objects.filter(title__contains='hello'): print(True) 20、distinct：去除掉那些重复的数据。这个方法如果底层数据库用的是MySQL，那么不能传递任何的参数。比如想要提取所有销售的价格超过80元的图书，并且删掉那些重复的，那么可以使用distinct来帮我们实现，示例代码如下： books = Book.objects.filter(bookorder__price__gte=80).distinct() 需要注意的是，如果在distinct之前使用了order_by，那么因为order_by会提取order_by中指定的字段，因此再使用distinct就会根据多个字段来进行唯一化，所以就不会把那些重复的数据删掉。示例代码如下： orders = BookOrder.objects.order_by(\"create_time\").values(\"book_id\").distinct() 那么以上代码因为使用了order_by，即使使用了distinct，也会把重复的book_id提取出来。 21、update：执行更新操作，在SQL底层走的也是update命令。比如要将所有category为空的article的article字段都更新为默认的分类。示例代码如下： Article.objects.filter(category__isnull=True).update(category_id=3) def index14(request): #一般de books = Book.objects.all() # for book in books: # book.price = book.price + 5 # book.save() Book.objects.update(price=F('price')+5)#F('price') 获取原来的价格 + 5元 print(connection.queries) #'UPDATE `book` SET `price` = (`book`.`price` + 5)' return HttpResponse('index14') 注意这个方法走的是更新的逻辑。所以更新完成后保存到数据库中不会执行save方法，因此不会更新auto_now设置的字段。 一次性可以把所有的数据都更新完。 22、delete：删除所有满足条件的数据。删除数据的时候，要注意on_delete指定的处理方式。 Author.objects.filter(id__gte=3).delete() 23、切片操作：有时候我们查找数据，有可能只需要其中的一部分。那么这时候可以使用切片操作来帮我们完成。QuerySet使用切片操作就跟列表使用切片操作是一样的。示例代码如下： books = Book.objects.all()[1:3] for book in books: print(book) def index15(request): #0,1 = [0:2] books = Book.objects.get_queryset()[0:2] for book in books: print(book.name) ''' 三国演义 水浒传 ''' print(connection.queries) #'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id` FROM `book` LIMIT 2' #用all的方法 books = Book.objects.all()[0:3] for book in books: print(book) ''' Book object (1) Book object (2) Book object (3) ''' return HttpResponse('index15') 切片操作并不是把所有数据从数据库中提取出来再做切片操作。而是在数据库层面使用LIMIE和OFFSET来帮我们完成。所以如果只需要取其中一部分的数据的时候，建议大家使用切片操作。 什么时候Django会将QuerySet转换为SQL去执行 生成一个QuerySet对象并不会马上转换为SQL语句去执行。 比如我们获取Book表下所有的图书： books = Book.objects.all() print(connection.queries) 我们可以看到在打印connection.quries的时候打印的是一个空的列表。说明上面的QuerySet并没有真正的执行。 在以下情况下QuerySet会被转换为SQL语句执行： 迭代：在遍历QuerySet对象的时候，会首先先执行这个SQL语句，然后再把这个结果返回进行迭代。比如以下代码就会转换为SQL语句： for book in Book.objects.all(): print(book) 使用步长做切片操作：QuerySet可以类似于列表一样做切片操作。做切片操作本身不会执行SQL语句，但是如果如果在做切片操作的时候提供了步长，那么就会立马执行SQL语句。需要注意的是，做切片后不能再执行filter方法，否则会报错。 调用len函数：调用len函数用来获取QuerySet中总共有多少条数据也会执行SQL语句。 调用list函数：调用list函数用来将一个QuerySet对象转换为list对象也会立马执行SQL语句。 判断：如果对某个QuerySet进行判断，也会立马执行SQL语句。 "},"第四章：数据库/014ORM作业.html":{"url":"第四章：数据库/014ORM作业.html","title":"014ORM作业","keywords":"","body":"ORM作业 准备工作 更改语言和时间区域 配置数据库 使用之前学到过的操作实现下面的查询操作 1、查询平均成绩大于60分的id和平均成绩 def index1(request): #1、查询平均成绩大于60分的id和平均成绩 students = Student.objects.annotate(score_avg=Avg('score__number')).filter(score_avg__gt=60).values('id','score_avg') for student in students: print(student) ''' {'id': 1, 'score_avg': 83.33333333333333} {'id': 3, 'score_avg': 91.0} {'id': 4, 'score_avg': 64.75} ''' print(connection.queries[2:]) #'SELECT `student`.`id`, AVG(`score`.`number`) AS `score_avg` FROM `student` LEFT OUTER JOIN `score` ON (`student`.`id` = `score`.`student_id`) GROUP BY `student`.`id` HAVING AVG(`score`.`number`) > 60.0e0 ORDER BY NULL' return HttpResponse('index1') 2、查询所有同学的id、姓名、选课的数量、总成绩 def index2(request): #2、查询所有同学的id、姓名、选课的数量、总成绩 students = Student.objects.annotate(course_nums=Count('score__id'),total=Sum('score__number')).values('id','name','course_nums','total') for student in students: print(student) ''' {'id': 1, 'name': '张三', 'course_nums': 3, 'total': 250.0} {'id': 2, 'name': '李四', 'course_nums': 4, 'total': 178.0} {'id': 3, 'name': '王五', 'course_nums': 4, 'total': 364.0} {'id': 4, 'name': '赵六', 'course_nums': 4, 'total': 259.0} ''' print(connection.queries[2:]) ''' 'SELECT `student`.`id`, `student`.`name`, COUNT(`score`.`id`) AS `course_nums`, SUM(`score`.`number`) AS `total` FROM `student` LEFT OUTER JOIN `score` ON (`student`.`id` = `score`.`student_id`) GROUP BY `student`.`id` ORDER BY NULL' ''' return HttpResponse('index2') 3、查询姓“李”的老师的个数 def index3(request): count = Teacher.objects.filter(name__startswith='李').count() print(count)# 1 姓李的老师只有一个 return HttpResponse('index3') 4、查询没学过“李老师”课的同学的id、姓名 def index4(request): students = Student.objects.exclude(score__course__teacher__name='李老师').values('id','name') for student in students: print(student) #{'id': 1, 'name': '张三'} print(connection.queries) #\"SELECT `student`.`id`, `student`.`name` FROM `student` WHERE NOT (`student`.`id` IN (SELECT U1.`student_id` FROM `score` U1 INNER JOIN `course` U2 ON (U1.`course_id` = U2.`id`) INNER JOIN `teacher` U3 ON (U2.`teacher_id` = U3.`id`) WHERE U3.`name` = '李老师'))\" return HttpResponse('index4') 5、查询学过课程id为2的所有同学的id和姓名 def index5(request): #查询学过课程id为1和2的所有同学的id和姓名 students = Student.objects.filter(score__course__in=[1,2]).values('id','name') for student in students: print(student) ''' {'id': 1, 'name': '张三'} {'id': 1, 'name': '张三'} {'id': 2, 'name': '李四'} {'id': 2, 'name': '李四'} {'id': 3, 'name': '王五'} {'id': 3, 'name': '王五'} {'id': 4, 'name': '赵六'} {'id': 4, 'name': '赵六'} ''' students = Student.objects.filter(score__course__in=[1, 2]).values('id', 'name').distinct() for student in students: print(student) ''' {'id': 1, 'name': '张三'} {'id': 2, 'name': '李四'} {'id': 3, 'name': '王五'} {'id': 4, 'name': '赵六'} ''' print(connection.queries[2:]) return HttpResponse('index5') 6、查询学过‘黄老师’所教的‘所有课’的同学的id和姓名 def index6(request): #查询学过‘黄老师’所教的‘所有课’的同学的id和姓名 #1、先找到每一位学生学习黄老师课程的数量 A #2、在课程表中找到黄老师教的课程的数量 B #3、判断A是否等于B，如果相等，那么意味着这位学生学完黄老师的所有课程 annotate相当于生成一个新的字段 students = Student.objects.annotate(nums = Count(\"score__course\",filter=Q(score__course__teacher__name='李老师'))).filter(nums =Course.objects.filter(teacher__name='李老师').count()).values('id','name') for student in students: print(student) ''' {'id': 1, 'name': '张三'} {'id': 2, 'name': '李四'} {'id': 3, 'name': '王五'} {'id': 4, 'name': '赵六'} ''' print(connection.queries[2:]) #[{'sql': \"SELECT COUNT(*) AS `__count` FROM `course` INNER JOIN `teacher` ON (`course`.`teacher_id` = `teacher`.`id`) WHERE `teacher`.`name` = '黄老师'\", 'time': '0.000'}, {'sql': \"SELECT `student`.`id`, `student`.`name` FROM `student` LEFT OUTER JOIN `score` ON (`student`.`id` = `score`.`student_id`) LEFT OUTER JOIN `course` ON (`score`.`course_id` = `course`.`id`) LEFT OUTER JOIN `teacher` ON (`course`.`teacher_id` = `teacher`.`id`) GROUP BY `student`.`id` HAVING COUNT(CASE WHEN (`teacher`.`name` = '黄老师') THEN `score`.`course_id` ELSE NULL END) = 2 ORDER BY NULL\", 'time': '0.000'}] return HttpResponse('index6') 7、查询所有课程成绩小于60分的同学的id和姓名 def index7(request): #查询所有课程成绩小于60分的同学的id和姓名 students = Student.objects.exclude(score__number__gte=60).values('id','name') for student in students: print(student) #{'id': 2, 'name': '李四'} print(connection.queries) #'SELECT `student`.`id`, `student`.`name` FROM `student` WHERE NOT (`student`.`id` IN (SELECT U1.`student_id` FROM `score` U1 WHERE U1.`number` >= 60.0e0)) return HttpResponse('index7') 8、查询没有学全所有课程的同学id、姓名 def index8(request): #查询没有学全所有课程的同学id、姓名 students = Student.objects.annotate(num = Count(F('score__course'))).filter(num__lt=Course.objects.count()).values('id','name') for student in students: print(student) #{'id': 1, 'name': '张三'} print(connection.queries) #{'sql': 'SELECT COUNT(*) AS `__count` FROM `course`', 'time': '0.000'}, {'sql': 'SELECT `student`.`id`, `student`.`name` FROM `student` LEFT OUTER JOIN `score` ON (`student`.`id` = `score`.`student_id`) GROUP BY `student`.`id` HAVING COUNT(`score`.`course_id`) 9、查询所有学生的姓名、平均分，并且按照平均分从高到低排序 def index9(request): #查询所有学生的姓名、平均分，并且按照平均分从高到低排序 students = Student.objects.annotate(avg = Avg('score__number')).order_by('-avg').values('name','avg') for student in students: print(student) ''' {'name': '王五', 'avg': 91.0} {'name': '张三', 'avg': 83.33333333333333} {'name': '赵六', 'avg': 64.75} {'name': '李四', 'avg': 42.0} ''' print(connection.queries) #'SELECT `student`.`name`, AVG(`score`.`number`) AS `avg` FROM `student` LEFT OUTER JOIN `score` ON (`student`.`id` = `score`.`student_id`) GROUP BY `student`.`id` ORDER BY `avg` DESC' return HttpResponse('index9') 10、查询各科成绩的最高分和最低分，以如下形式显示：课程ID、课程名称、最高分、最低分 def index10(request): #查询各科成绩的最高分和最低分，以如下形式显示：课程ID、课程名称、最高分、最低分 courses = Course.objects.annotate(min =Min(\"score__number\"),max=Max(\"score__number\")).values('id','name','min','max') for course in courses: print(course) ''' {'id': 1, 'name': 'Python', 'min': 40.0, 'max': 104.0} {'id': 2, 'name': '前端', 'min': 40.0, 'max': 90.0} {'id': 3, 'name': 'Java', 'min': 54.0, 'max': 94.0} {'id': 4, 'name': '安卓', 'min': 34.0, 'max': 90.0} ''' print(connection.queries) #{'sql': 'SELECT `course`.`id`, `course`.`name`, MIN(`score`.`number`) AS `min`, MAX(`score`.`number`) AS `max` FROM `course` LEFT OUTER JOIN `score` ON (`course`.`id` = `score`.`course_id`) GROUP BY `course`.`id` ORDER BY NULL', 'time': '0.000'} return HttpResponse('index10') 11、查询每门课程的平均成绩，按照平均分成绩进行排序 def index11(request): #查询每门课程的平均成绩，按照平均分成绩进行排序 courses = Course.objects.annotate(avg = Avg('score__number')).order_by('avg').values('name','avg') for course in courses: print(course) ''' {'name': '安卓', 'avg': 67.66666666666667} {'name': '前端', 'avg': 68.25} {'name': 'Python', 'avg': 70.0} {'name': 'Java', 'avg': 71.25} ''' print(connection.queries) #{'sql': 'SELECT `course`.`name`, AVG(`score`.`number`) AS `avg` FROM `course` LEFT OUTER JOIN `score` ON (`course`.`id` = `score`.`course_id`) GROUP BY `course`.`id` ORDER BY `avg` ASC', 'time': '0.000'} return HttpResponse('index11') 12、统计总共有多少女生，多少男生 def index12(request): #统计总共有多少女生，多少男生 rows = Student.objects.aggregate(male_num=Count('gender',filter=Q(gender =1)),female_num=Count('gender',filter=Q(gender =2))) print(rows) #{'male_num': 2, 'female_num': 2} print(connection.queries) #{'sql': 'SELECT COUNT(CASE WHEN `student`.`gender` = 1 THEN `student`.`gender` ELSE NULL END) AS `male_num`, COUNT(CASE WHEN `student`.`gender` = 2 THEN `student`.`gender` ELSE NULL END) AS `female_num` FROM `student`', 'time': '0.000'} return HttpResponse('index12') 13、将‘黄老师’的每一门课程都在原来的基础之上加5分 def index13(request): #将‘黄老师’的每一门课程都在原来的基础之上加5分 rows = Score.objects.filter(course__teacher__name='黄老师').update(number = F(\"number\")+5) print(rows)#8 print(connection.queries) #{'sql': \"SELECT `score`.`id` FROM `score` INNER JOIN `course` ON (`score`.`course_id` = `course`.`id`) INNER JOIN `teacher` ON (`course`.`teacher_id` = `teacher`.`id`) WHERE `teacher`.`name` = '黄老师'\", 'time': '0.000'}, {'sql': 'UPDATE `score` SET `number` = (`score`.`number` + 5) WHERE `score`.`id` IN (1, 5, 9, 13, 3, 7, 11, 15)', 'time': '0.015'} return HttpResponse('index13') 14、查询两门以上不及格的同学的id、姓名、以及不及格课程数 def index14(request): #查询两门以上不及格的同学的id、姓名、以及不及格课程数 students = Student.objects.annotate(bad_count = Count('score__number',filter=Q(score__number__lt=60))).filter(bad_count__gte=2).values('id','name','bad_count') for student in students: print(student) #{'id': 2, 'name': '李四', 'bad_count': 3} print(connection.queries) #{'sql': 'SELECT `student`.`id`, `student`.`name`, COUNT(CASE WHEN `score`.`number` = 2 ORDER BY NULL', 'time': '0.000'} return HttpResponse('index14') 15、查询每门课的选课人数 def index15(request): #查询每门课的选课人数 courses = Course.objects.annotate(student_nums =Count('score__student')).values('id','name','student_nums') for course in courses: print(course) ''' {'id': 1, 'name': 'Python', 'student_nums': 4} {'id': 2, 'name': '前端', 'student_nums': 4} {'id': 3, 'name': 'Java', 'student_nums': 4} {'id': 4, 'name': '安卓', 'student_nums': 3} ''' print(connection.queries) #{'sql': 'SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED', 'time': '0.000'}, {'sql': 'SELECT `course`.`id`, `course`.`name`, COUNT(`score`.`student_id`) AS `student_nums` FROM `course` LEFT OUTER JOIN `score` ON (`course`.`id` = `score`.`course_id`) GROUP BY `course`.`id` ORDER BY NULL', 'time': '0.000'} return HttpResponse('index15') "},"第四章：数据库/015ORM模型迁移.html":{"url":"第四章：数据库/015ORM模型迁移.html","title":"015ORM模型迁移","keywords":"","body":"ORM模型迁移 迁移命令： makemigrations：将模型生成迁移脚本。模型所在的app，必须放在settings.py中的INSTALLED_APPS中。这个命令有以下几个常用选项： app_label：后面可以跟一个或者多个app，那么就只会针对这几个app生成迁移脚本。如果没有任何的app_label，那么会检查INSTALLED_APPS中所有的app下的模型，针对每一个app都生成响应的迁移脚本。python manage.py makemigrations app_name 如果后面没有app_name将会执行所有的app --name：给这个迁移脚本指定一个名字。 python manage.py makemigrations article --name \"remove_article_content_createtime\" --empty：生成一个空的迁移脚本。如果你想写自己的迁移脚本，可以使用这个命令来实现一个空的文件，然后自己再在文件中写迁移脚本。 migrate：将新生成的迁移脚本。映射到数据库中。创建新的表或者修改表的结构。以下一些常用的选项： app_label：将某个app下的迁移脚本映射到数据库中。如果没有指定，那么会将所有在INSTALLED_APPS中的app下的模型都映射到数据库中。 app_label migrationname：将某个app下指定名字的migration文件映射到数据库中。 --fake：可以将指定的迁移脚本名字添加到数据库中。但是并不会把迁移脚本转换为SQL语句，修改数据库中的表。 数据库中没有但代码中有 python manage.py migrate article --fake --fake-initial：将第一次生成的迁移文件版本号记录在数据库中。但并不会真正的执行迁移脚本。 python manage.py migrate article --fake-init 执行migrate命令的时候报错的解决办法： 原因： 执行migrate命令会报错的原因是，数据库的'django_migrations'表中的迁移版本记录和代码中的迁移脚本不一致导致的。 解决办法： 使用--fake参数，首先对比数据库中迁移脚本和代码中的迁移脚本。然后找到那个不同，之后在使用--fake,将代码中迁移脚本添加到django_migrations中，但是并不会执行sql语句，这样就可以避免每次执行migrate的时候，都执行一些重复的迁移脚本。 终极解决方案 如果代码中迁移脚本和数据库中的迁移脚本实在太多，就是搞不清了。那么这时候就可以使用终极解决方案： 1、终极解决方案原理：就是将之前的那些迁移脚本都不用了，重新来过，要将出问题的app下的所有模型的字段，和数据库中相对应表的字段保持一致。重新映射。 2、将出问题的app下的所有模型，都和数据库中的表保持一致。 3、将出问题app下的所有迁移脚本文件都删掉，再在django_migrations将出问题的app相关的迁移记录都删掉。 4、使用makemigrations重新将模型生成一个迁移脚本。 5、使用migrate --fake-init参数，将刚刚生成的迁移脚本，标记为已经完成（因为这些模型相对应的表，其实都已经在数据库中存在，不需要重新填写。 showmigrations：查看某个app下的迁移文件。如果后面没有app，那么将查看INSTALLED_APPS中所有的迁移文件。 sqlmigrate：查看某个迁移文件在映射到数据库中的时候，转换的SQL语句。 migrations中的迁移版本和数据库中的迁移版本对不上怎么办？ 找到哪里不一致，然后使用python manage.py --fake [版本名字]，将这个版本标记为已经映射。 删除指定app下migrations和数据库表django_migrations中和这个app相关的版本号，然后将模型中的字段和数据库中的字段保持一致，再使用命令python manage.py makemigrations重新生成一个初始化的迁移脚本，之后再使用命令python manage.py makemigrations --fake-initial来将这个初始化的迁移脚本标记为已经映射。以后再修改就没有问题了。 更多关于迁移脚本的。请查看官方文档：https://docs.djangoproject.com/en/2.0/topics/migrations/ 根据已有的表自动生成模型： 在实际开发中，有些时候可能数据库已经存在了。如果我们用Django来开发一个网站，读取的是之前已经存在的数据库中的数据。那么该如何将模型与数据库中的表映射呢？根据旧的数据库生成对应的ORM模型，需要以下几个步骤： Django给我们提供了一个inspectdb的命令，可以非常方便的将已经存在的表，自动的生成模型。想要使用inspectdb自动将表生成模型。首先需要在settings.py中配置好数据库相关信息。不然就找不到数据库。示例代码如下： DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': \"migrations_demo\", 'HOST': '127.0.0.1', 'PORT': '3306', 'USER': 'root', 'PASSWORD': 'root' } } 比如有以下表： article表： tag表： article_tag表： front_user表： 那么通过python manage.py inspectdb，就会将表转换为模型后的代码，显示在终端： from django.db import models class ArticleArticle(models.Model): title = models.CharField(max_length=100) content = models.TextField(blank=True, null=True) create_time = models.DateTimeField(blank=True, null=True) author = models.ForeignKey('FrontUserFrontuser', models.DO_NOTHING, blank=True, null=True) class Meta: managed = False db_table = 'article_article' class ArticleArticleTags(models.Model): article = models.ForeignKey(ArticleArticle, models.DO_NOTHING) tag = models.ForeignKey('ArticleTag', models.DO_NOTHING) class Meta: managed = False db_table = 'article_article_tags' unique_together = (('article', 'tag'),) class ArticleTag(models.Model): name = models.CharField(max_length=100) class Meta: managed = False db_table = 'article_tag' class FrontUserFrontuser(models.Model): username = models.CharField(max_length=100) telephone = models.CharField(max_length=11) class Meta: managed = False db_table = 'front_user_frontuser' 以上代码只是显示在终端。如果想要保存到文件中。那么可以使用>重定向输出到指定的文件。比如让他输出到models.py文件中。示例命令如下： python manage.py inspectdb > models.py 以上的命令，只能在终端执行，不能在pycharm->Tools->Run manage.py Task...中使用。 如果只是想要转换一个表为模型。那么可以指定表的名字。示例命令如下： python manage.py inspectdb article_article > models.py 修正模型：新生成的ORM模型有些地方可能不太适合使用。比如模型的名字，表之间的关系等等。那么以下选项还需要重新配置一下： 模型名：自动生成的模型，是根据表的名字生成的，可能不是你想要的。这时候模型的名字你可以改成任何你想要的。 模型所属app：根据自己的需要，将相应的模型放在对应的app中。放在同一个app中也是没有任何问题的。只是不方便管理。 模型外键引用：将所有使用ForeignKey的地方，模型引用都改成字符串。这样不会产生模型顺序的问题。另外，如果引用的模型已经移动到其他的app中了，那么还要加上这个app的前缀。 让Django管理模型：将Meta下的managed=False删掉，如果保留这个，那么以后这个模型有任何的修改，使用migrate都不会映射到数据库中。 当有多对多的时候，应该也要修正模型。将中间表注视了，然后使用ManyToManyField来实现多对多。并且，使用ManyToManyField生成的中间表的名字可能和数据库中那个中间表的名字不一致，这时候肯定就不能正常连接了。那么可以通过db_table来指定中间表的名字。示例代码如下： class Article(models.Model): title = models.CharField(max_length=100, blank=True, null=True) content = models.TextField(blank=True, null=True) author = models.ForeignKey('front.User', models.SET_NULL, blank=True, null=True) # 使用ManyToManyField模型到表，生成的中间表的规则是：article_tags # 但现在已经存在的表的名字叫做：article_tag # 可以使用db_table，指定中间表的名字 tags = models.ManyToManyField(\"Tag\",db_table='article_tag') class Meta: db_table = 'article' 表名：切记不要修改表的名字。不然映射到数据库中，会发生找不到对应表的错误。 执行命令python manage.py makemigrations生成初始化的迁移脚本。方便后面通过ORM来管理表。这时候还需要执行命令python manage.py migrate --fake-initial，因为如果不使用--fake-initial，那么会将迁移脚本会映射到数据库中。这时候迁移脚本会新创建表，而这个表之前是已经存在了的，所以肯定会报错。此时我们只要将这个0001-initial的状态修改为已经映射，而不真正执行映射，下次再migrate的时候，就会忽略他。 将Django的核心表映射到数据库中：Django中还有一些核心的表也是需要创建的。不然有些功能是用不了的。比如auth相关表。如果这个数据库之前就是使用Django开发的，那么这些表就已经存在了。可以不用管了。如果之前这个数据库不是使用Django开发的，那么应该使用migrate命令将Django中的核心模型映射到数据库中。 验证数据表 def index(request): # article = Article(title='abc',content='1234') # author = User.objects.create(username='zhiliao',password='12334') # article.author = author # article.save() article =Article.objects.first() tag1 = Tag.objects.create(name='python') tag2 = Tag.objects.create(name='php') article.tags.add(tag1,tag2) article.save() return HttpResponse('success') "},"第五章：高级视图/5.1 第一节：限制请求method.html":{"url":"第五章：高级视图/5.1 第一节：限制请求method.html","title":"5.1 第一节：限制请求method","keywords":"","body":"限制请求Method 常用的请求method： ET请求：GET请求一般用来向服务器索取数据，但不会向服务器提交数据，不会对服务器的状态进行更改。比如向服务器获取某篇文章的详情。 POST请求：POST请求一般是用来向服务器提交数据，会对服务器的状态进行更改。比如提交一篇文章给服务器。 限制请求装饰器： Django内置的视图装饰器可以给视图提供一些限制。比如这个视图只能通过GET的method访问等。以下将介绍一些常用的内置视图装饰器。 django.http.decorators.http.require_http_methods：这个装饰器需要传递一个允许访问的方法的列表。比如只能通过GET的方式访问。那么示例代码如下： from django.views.decorators.http import require_http_methods @require_http_methods([\"GET\"]) def my_view(request): pass django.views.decorators.http.require_GET：这个装饰器相当于是require_http_methods(['GET'])的简写形式，只允许使用GET的method来访问视图。示例代码如下： from django.views.decorators.http import require_GET @require_GET def my_view(request): pass django.views.decorators.http.require_POST：这个装饰器相当于是require_http_methods(['POST'])的简写形式，只允许使用POST的method来访问视图。示例代码如下： from django.views.decorators.http import require_POST @require_POST def my_view(request): pass django.views.decorators.http.require_safe：这个装饰器相当于是require_http_methods(['GET','HEAD'])的简写形式，只允许使用相对安全的方式来访问视图。因为GET和HEAD不会对服务器产生增删改的行为。因此是一种相对安全的请求方式。示例代码如下： from django.views.decorators.http import require_safe @require_safe def my_view(request): pass "},"第五章：高级视图/5.2 第二节：页面重定向.html":{"url":"第五章：高级视图/5.2 第二节：页面重定向.html","title":"5.2 第二节：页面重定向","keywords":"","body":"重定向 重定向分为永久性重定向和暂时性重定向，在页面上体现的操作就是浏览器会从一个页面自动跳转到另外一个页面。比如用户访问了一个需要权限的页面，但是该用户当前并没有登录，因此我们应该给他重定向到登录页面。 永久性重定向：http的状态码是301，多用于旧网址被废弃了要转到一个新的网址确保用户的访问，最经典的就是京东网站，你输入www.jingdong.com的时候，会被重定向到www.jd.com，因为jingdong.com这个网址已经被废弃了，被改成jd.com，所以这种情况下应该用永久重定向。 暂时性重定向：http的状态码是302，表示页面的暂时性跳转。比如访问一个需要权限的网址，如果当前用户没有登录，应该重定向到登录页面，这种情况下，应该用暂时性重定向。 在Django中，重定向是使用redirect(to, *args, permanent=False, **kwargs)来实现的。to是一个url，permanent代表的是这个重定向是否是一个永久的重定向，默认是False。关于重定向的使用。请看以下例子： ![202053180513](C:/Users/Administrator/Desktop/202053180513.giffrom django.shortcuts import reverse,redirect def profile(request): if request.GET.get(\"username\"): return HttpResponse(\"%s，欢迎来到个人中心页面！\") else: return redirect(reverse(\"user:login\")) #from django.shortcuts import render,redirect,reverse from django.http import HttpResponse # Create your views here. def index(request): #如果没有登录，那么就重定向到注册页面 #如果在URL中传递了username参数，那么久认为是登录了，否则就没有 #/?username=xxx #request.GET 获取的是一个字典，get是方法 username = request.GET.get(\"username\") if username: return HttpResponse(f'您的用户名为：{username}') else: return redirect(reverse('signup')) #reverse('signup') 翻转到signup名字的url地址 def signup(request): return HttpResponse('注册页') 301与302状态码？ 301是永久性的重定向，302是临时性的重定向。 "},"第五章：高级视图/5.4 第四节：HttpResponse对象.html":{"url":"第五章：高级视图/5.4 第四节：HttpResponse对象.html","title":"5.4 第四节：HttpResponse对象","keywords":"","body":"HttpResponse对象 Django服务器接收到客户端发送过来的请求后，会将提交上来的这些数据封装成一个HttpRequest对象传给视图函数。那么视图函数在处理完相关的逻辑后，也需要返回一个响应给浏览器。而这个响应，我们必须返回HttpResponseBase或者他的子类的对象。而HttpResponse则是HttpResponseBase用得最多的子类。那么接下来就来介绍一下HttpResponse及其子类。 常用属性： 1、content：返回的内容。 # response = HttpResponse() # response.content='知了课堂' response = HttpResponse('知了课堂1') 2、status_code：返回的HTTP响应状态码。 response.status_code = 400 3、content_type：返回的数据的MIME类型，默认为text/html。浏览器会根据这个属性，来显示数据。如果是text/html，那么就会解析这个字符串，如果text/plain，那么就会显示一个纯文本。常用的Content-Type 如下： text/html（默认的，html文件） text/plain（纯文本） text/css（css文件） text/javascript（js文件） multipart/form-data（文件提交） application/json（json传输） application/xml（xml文件） 设置请求头：response['X-Access-Token'] = 'xxxx'。 response = HttpResponse('知了课堂',content_type='text/plain;charset=utf-8') #知了课堂 被当做普通的代码处理 #请求头 response['PASSWORD']='zhile' 常用方法： set_cookie：用来设置cookie信息。后面讲到授权的时候会着重讲到。 delete_cookie：用来删除cookie信息。 write：HttpResponse是一个类似于文件的对象，可以用来写入数据到数据体（content）中。 response.write('知了') #知了课堂知了 #用来写入content中 JsonResponse类： 用来对象dump成json字符串，然后返回将json字符串封装成Response对象返回给浏览器。并且他的Content-Type是application/json。示例代码如下： from django.http import JsonResponse def index(request): return JsonResponse({\"username\":\"zhiliao\",\"age\":18}) ###手打代码 from django.http import JsonResponse import json def jsonresponse_view(request): person ={ 'username':'zhiliao', 'age':18, 'height':170 } person_str = json.dumps(person) response = HttpResponse(person_str,content_type='application/json') #return response #{\"username\": \"zhiliao\", \"age\": 18, \"height\": 170} #下面的代码是上面代码的缩写 response = JsonResponse(person) return response #{\"username\": \"zhiliao\", \"age\": 18, \"height\": 170} 默认情况下JsonResponse只能对字典进行dump，如果想要对非字典的数据进行dump，那么需要给JsonResponse传递一个safe=False参数。示例代码如下： from django.http import JsonResponse def index(request): persons = ['张三','李四','王五'] return HttpResponse(persons) 以上代码会报错，应该在使用HttpResponse的时候，传入一个safe=False参数，示例代码如下： return HttpResponse(persons,safe=False) ###手打代码 from django.http import JsonResponse import json def jsonresponse_view(request): person =[ { 'username': 'zhiliao', 'age': 18, 'height': 170 }, { 'username': 'zhiliao', 'age': 20, 'height': 172 } ] person_str = json.dumps(person) response = HttpResponse(person_str,content_type='application/json') #return response #{\"username\": \"zhiliao\", \"age\": 18, \"height\": 170} #下面的代码是上面代码的缩写 response = JsonResponse(person,safe=False) return response #[{\"username\": \"zhiliao\", \"age\": 18, \"height\": 170}, {\"username\": \"zhiliao\", \"age\": 20, \"height\": 172}] "},"第五章：高级视图/5.5 第五节：生成csv文件.html":{"url":"第五章：高级视图/5.5 第五节：生成csv文件.html","title":"5.5 第五节：生成csv文件","keywords":"","body":""},"第五章：高级视图/5.6 第六节：类视图.html":{"url":"第五章：高级视图/5.6 第六节：类视图.html","title":"5.6 第六节：类视图","keywords":"","body":""},"第五章：高级视图/5.7 第七节：错误处理.html":{"url":"第五章：高级视图/5.7 第七节：错误处理.html","title":"5.7 第七节：错误处理","keywords":"","body":""},"第六章：表单/6.1 第一节：表单概述.html":{"url":"第六章：表单/6.1 第一节：表单概述.html","title":"6.1 第一节：表单概述","keywords":"","body":""},"第六章：表单/6.2 第二节：用表单验证数据.html":{"url":"第六章：表单/6.2 第二节：用表单验证数据.html","title":"6.2 第二节：用表单验证数据","keywords":"","body":""},"第六章：表单/6.3 第三节：ModelForm.html":{"url":"第六章：表单/6.3 第三节：ModelForm.html","title":"6.3 第三节：ModelForm","keywords":"","body":""},"第六章：表单/6.4 第四节：文件上传.html":{"url":"第六章：表单/6.4 第四节：文件上传.html","title":"6.4 第四节：文件上传","keywords":"","body":""}}