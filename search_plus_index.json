{"./":{"url":"./","title":"笔记文档介绍","keywords":"","body":"studynote 学习笔记,争取一直上传下去！ git的使用 gitbook的使用 html+css php python scratch python常用的库学习 software cracking tutorial 乐高编程EV3 每一次的学习都需要做笔记123 "},"git的使用/git的使用.html":{"url":"git的使用/git的使用.html","title":"git的使用","keywords":"","body":"git的使用教程 安装地址：http://git-scm.com 1、安装完之后，右键git bash here 输入git --version 当看到版本号的时候，说明已经安装成功。 2、设置用户名和邮箱，尽量和github账号一致 git config --global user.name topljd(您的用户名) git config --global user.email 820230548@qq.com(您的邮箱) 3、创建工作区，在文件夹内右键 git bash 创建工作区的时候，要在想要创建的文件夹内！ 如果我要在G:\\git下创建工作区，.git是隐藏的文件夹，里面的文件不用管就可以了！ git的使用，举例 1、创建readme.txt文件，并增加到缓存区 git add readme.txt //将readme.txt这个文件增加到 暂存区 git add . //这个 点 表示当前目录下的所有文件 2、commit提交到版本区 git commit -m \"1、添加readme.txt文件\" //后面引号内的内容为 注释 3、推送到远程的服务器 git remote add origin https://github.com/topljd/blog.git 远程连接仓库 git push -u origin master 推送到服务器 4、其他 git log //查看记录 git status //查看当前状态 二、在github上创建服务器 github地址，注册账号 地址：https://github.com 创建仓库 //create a new repository on the command line git init 创建git项目 git add readme.txt 将版本说明添加到 暂存库 git commit -m 'first commit' 提交到版本库，后面的为说明注释 git remote add origin https://github.com/topljd/blog.git 远程连接仓库 git push -u origin master 推送到服务器 git log git log --pretty=online 6a59ff31 //查看版本 git reset --hard 6a59ff31 //回滚到某个版本 git使用常见的问题 1、提交不了的时候，显示 入校错误！ failed to push some refs to 'https://github.com/topljd/studynote.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 答：因为此时版本中没有给readme.txt文件，解决办法 可以通过如下命令进行代码合并【注：pull=fetch+merge] git pull --rebase origin master 此时将会把库里的文件下载到本地当前文件夹！ 然后在进行提交 git push -m study master 2、如何删除github项目 点击setting 找到Danger Zone最下买你的delete this repository 确认是否真的要删除！ 3、如何删除github库里面的某个文件 因为在github上不能直接删除某个文件，所以必须用git命令去删除，在上传的的项目文件里打开git，找到要删除的文件。202002101581332439512796.png git pull --rebase origin master或者git pull origin master将github上的额文件重新拉下来，其中origin是别名，master是分支。 然后输入命令dir查看目录下的而文件，如下图： 再输入命令git rm -r --cache 202002101581332439512796.png删除磁盘上的该图片 再输入git commit -m '删除了202002101581332439512796.png'提交添加说明如下图： 最后输入git push -u origin master更新github仓库，如下图： 文件已经被删除了！ 4、当出现master warning: LF will be replaced by CRLF in www/css/style.css.> git config --global core.autocrlf false 一般的还是远程仓库中的文件与本地的文件不一样，需要先将远程仓库中的代码拉去到本地种！ 5、创建分支 $ git checkout -b iss53 Switched to a new branch \"iss53\" 上面是下面的简写 $ git branch iss53 $ git checkout iss53 6、出现上传不了错误提示如下： ​ error: cannot pull with rebase: You have unstaged changes. ​ error: please commit or stash them. 解决办法： 1.git pull –rebase 理解 这个命令做了以下内容： a.把你 commit 到本地仓库的内容，取出来放到暂存区(stash)（这时你的工作区是干净的） b.然后从远端拉取代码到本地，由于工作区是干净的，所以不会有冲突 c.从暂存区把你之前提交的内容取出来，跟拉下来的代码合并 所以 rebase 在拉代码前要确保你本地工作区是干净的，如果你本地修改的内容没完全 commit 或者 stash，就会 rebase 失败。 2.还是要听 git 提示的话，要理智，有什么不清楚的，就输入 git status 根据人家提示的来，该提交的提交，stash 的 stash。 3.删除文件后需要 git add -A, 光 git add. 不行，区别如下： git add 的几种参数区别 git add -A 保存所有的修改 git add . 保存新的添加和修改，但是不包括删除 git add -u 保存修改和删除，但是不包括新建文件。 7、切换分支的时候里面本地文件夹中的文件也会发生变化 8、名字和分支的用法 9、git删除本地分支、删除远程分支 1、查看所有分支 git branch -a $ git branch -a coding-pages gh-pages * master # * 表示当前分支 # 下面是远程分支 remotes/origin/gh-pages remotes/origin/master remotes/origin_coding/coding-pages remotes/origin_coding/master remotes/origin_gitee/master ######## $ git branch -r #查看远程分支 origin/gh-pages origin/master origin_coding/coding-pages origin_coding/master origin_gitee/master 2、查看当前所在分支 git branch 3、删除本地的XXX分支 git branch -d XXX 4、删除远程的XXX分支 git push origin --delete XXX远程的话一般是双- 10、拉取远程分支并创建本地分支 1、git checkout -b 本地分支名x origin/远程分支名x 使用该方式会在本地新建分支x，并自动切换到该本地分支x。 2、git fetch origin 远程分支名x:本地分支名x 使用该方式会在本地新建分支x，但是不会自动切换到该本地分支x，需要手动checkout。 3、git branch -vv查看本地分支与远程分支映射关系 $ git branch -vv coding-pages df545e4 [origin/coding-pages: gone] 删除所有pages文件 gh-pages 6d2697e [origin/gh-pages] 2020年5月7日10:42:39 * master cdb916a [origin_coding/master: ahead 1] 2020年5月7日10:26:37 提交ignore 4、git branch -u origin/addFile或git branch --set-upstream-to origin/addFile建立当前分支与远程分支的映射。 查看当前本地分支与远程分支映射关系结果如下： 此时再次拉取，成功信息如下： git pull Already up-to-date 再次推送，成功信息如下： git push Everything up-to-date 5、撤销本地分支与远程分支的映射关系 git branch --unset-upstream使用git branch -vv查看映射关系 6、可以本地分支A名和远程分支B名建立映射关系 并且此时可以把本地分支A提交到分支B分支中去： 11、failed to push some refs 当push上传不了出现如下提示的时候 解决方案：远程仓库与本地仓库代码不一样，上传不了！（远程仓库有其他的文件) 方法：1、git pull origin master将远程文件拉取到本地。再次执行git add .等系列动作上传。此时一切正常！ 12、上传时出现fatal: 拒绝合并无关的历史 ```shell 本地初始化的项目 与 github 版本不一致, 导致无法提交 $ git pull origin master branch master -> FETCH_HEAD fatal: 拒绝合并无关的历史 解决方法 在pull 时候, 添加–allow-unrelated-histories参数 即可. $ git pull origin master --allow-unrelated-histories来自 https://github.com/itaken/python-login-demo branch master -> FETCH_HEAD Merge made by the 'recursive' strategy. LICENSE | 21 +++++++++++++++++++++ 1 file changed, 21 insertions(+) create mode 100644 LICENSE ``` 苹果电脑，上传到github的时候，会发现很多._的文件？ 答：其实这些是因为磁盘的格式不是afhs格式自动生成的隐藏文件。 对于clone的仓库 1、执行 git clone 地址 2、正常git add . 就可以了 "},"gitbook的使用/快速使用gitbook.html":{"url":"gitbook的使用/快速使用gitbook.html","title":"gitbook的使用","keywords":"","body":"快速使用gitbook 安装 1、下载地址：https://nodejs.org/en/ 2、下载完成的样子 3、点击安装，右键安装（一路安装） 在cmd窗口，输入node -v 将会看到版本号！ 切换npm源的方法 $ npm install -g nrm 安装 输入nrm ls列出安装源地址 * npm ---- https://registry.npmjs.org cnpm --- http://r.cnpmjs.org/ taobao -http://registry.npm.taobao.org/ eu ----- http://registry.npmjs.eu/ au ----- http://registry.npmjs.org.au/ sl ----- http://npm.strongloop.com/ nj ----- https://registry.nodejitsu.com/ 带*的是当前使用的源，上面的输出表明当前源是官方源。 $ nrm use taobao Registry has beensetto: http://registry.npm.taobao.org/ 使用淘宝安装源 nrm最常用的命令 1.nrm ls 查看已有的源 2.nrm add 新增源 3.nrm use 切换到现有的源 4.nrm test 测速 4、安装GItBook，命令行输入下述命令 管理员身份运行CMD npm install gitbook-cli -g #如果是mac系统linux安装出错可能需要权限执行以下代码 sudo npm install gitbook-cli -g 安装速度有点慢，需要等一会儿！安装示例图： 5、查看是否安装成功，命令行输入下述命令，出现版本号则已安装，否则无 gitbook -V(注意这里的v是大写) 安装此时安装CLI版本，安装完的样子为 GitBook创建以及预览使用 一、gitbook init 1、进入到指定的文件夹执行cmd命令，初始化文件夹，会自动生成两个必要的文件README.md和SUMMARY.md README.md:书的介绍文字，如前言，简介，在章节中也可作为章节的简介 SUMMARY.md：定制书籍的章节结构和顺序。 2、在gitbook的使用文件夹下面增加其他章节的文件，文件目录如下： 3、GitBook使用SUMMARY.md文件作为书记的目录结构，可以用来制作书籍目录。 4、预览 a、执行命令git server,gitbook会启动一个4000端口用于预览 b、第二种预览方式，运行gitbook build命令狗会在书籍文件夹中生成一个_book文件夹的内容即为生成的html文件，生成网页不需要开启服务器。 注意： 当执行gitbook serve后保存找不到fontsettings.js 一般的降低版本 其他解决办法：先执行一次gitbook build,在执行gitbook serve就不会报错了！ 安装插件 安装插件只需要在书籍目录下增加book.json文件，例如增加折叠目录的插件，需要在book.json内增加下面代码： { \"plugins\": [\"expandable-chapters-small\"], \"pluginsConfig\": { \"expandable-chapters-small\":{} } } //常用插件 { \"plugins\": [ \"back-to-top-button\",//回到顶部插件 \"expandable-chapters\",//目录扩展，还可以 \"splitter\"//安装的时候次软件没有安装成功 \"-lunr\", \"-search\", \"search-pro\",//这3个支持中文搜索 ] } 然后终端执行install来安装插件即可。 gitbook install 至于插件可以再https://www.npmjs.com/search?q=gitbook进行搜索安装 常见问题 1、gitbook渲染的时候出现错误 template。比如在渲染django模板的时候 出现问题？ 解决办法：在代码的最前面和最后面添加代码区域 2、如何将文档上传到coding？ 解决办法： 3、gitbook新版本\"gitbook build\"命令导出的html本地不能跳转的问题解决 解决办法：在导出的文件夹目录下找到gitbook->theme.js文件 找到下面的代码（搜索 if(m)for(n.handler&&） 将if(m)改成if(false) "},"django/django打造大型企业/":{"url":"django/django打造大型企业/","title":"django打造大型企业","keywords":"","body":"章节说明 "},"django/django打造大型企业/第一章：学前准备/第一节：虚拟环境.html":{"url":"django/django打造大型企业/第一章：学前准备/第一节：虚拟环境.html","title":"第一节：虚拟环境","keywords":"","body":"虚拟环境 为什么需要虚拟环境： 到目前位置，我们所有的第三方包安装都是直接通过pip install xx的方式进行安装的，这样安装会将那个包安装到你的系统级的Python环境中。但是这样有一个问题，就是如果你现在用Django 1.10.x写了个网站，然后你的领导跟你说，之前有一个旧项目是用Django 0.9开发的，让你来维护，但是Django 1.10不再兼容Django 0.9的一些语法了。这时候就会碰到一个问题，我如何在我的电脑中同时拥有Django 1.10和Django 0.9两套环境呢？这时候我们就可以通过虚拟环境来解决这个问题。 虚拟环境原理介绍： 虚拟环境相当于一个抽屉，在这个抽屉中安装的任何软件包都不会影响到其他抽屉。并且在项目中，我可以指定这个项目的虚拟环境来配合我的项目。比如我们现在有一个项目是基于Django 1.10.x版本，又有一个项目是基于Django 0.9.x的版本，那么这时候就可以创建两个虚拟环境，在这两个虚拟环境中分别安装Django 1.10.x和Django 0.9.x来适配我们的项目。 安装virtualenv： virtualenv是用来创建虚拟环境的软件工具，我们可以通过pip或者pip3来安装： pip install virtualenv pip3 install virtualenv 创建虚拟环境： 创建虚拟环境非常简单，通过以下命令就可以创建了： virtualenv [虚拟环境的名字] 如果你当前的Python3/Scripts的查找路径在Python2/Scripts的前面，那么将会使用python3作为这个虚拟环境的解释器。如果python2/Scripts在python3/Scripts前面，那么将会使用Python2来作为这个虚拟环境的解释器。 进入环境： 虚拟环境创建好了以后，那么可以进入到这个虚拟环境中，然后安装一些第三方包，进入虚拟环境在不同的操作系统中有不同的方式，一般分为两种，第一种是Windows，第二种是*nix： windows进入虚拟环境：进入到虚拟环境的Scripts文件夹中，然后执行activate。 *nix进入虚拟环境：source /path/to/virtualenv/bin/activate 一旦你进入到了这个虚拟环境中，你安装包，卸载包都是在这个虚拟环境中，不会影响到外面的环境。 退出虚拟环境： 退出虚拟环境很简单，通过一个命令就可以完成：deactivate。 创建虚拟环境的时候指定Python解释器： 在电脑的环境变量中，一般是不会去更改一些环境变量的顺序的。也就是说比如你的Python2/Scripts在Python3/Scripts的前面，那么你不会经常去更改他们的位置。但是这时候我确实是想在创建虚拟环境的时候用Python3这个版本，这时候可以通过-p参数来指定具体的Python解释器： virtualenv -p C:\\Python36\\python.exe [virutalenv name] virtualenvwrapper： virtualenvwrapper这个软件包可以让我们管理虚拟环境变得更加简单。不用再跑到某个目录下通过virtualenv来创建虚拟环境，并且激活的时候也要跑到具体的目录下去激活。 安装virtualenvwrapper： *nix：pip install virtualenvwrapper。 windows：pip install virtualenvwrapper-win。 virtualenvwrapper基本使用： 创建虚拟环境： mkvirtualenv my_env 那么会在你当前用户下创建一个Env的文件夹，然后将这个虚拟环境安装到这个目录下。 如果你电脑中安装了python2和python3，并且两个版本中都安装了virtualenvwrapper，那么将会使用环境变量中第一个出现的Python版本来作为这个虚拟环境的Python解释器。 切换到某个虚拟环境： workon my_env 退出当前虚拟环境： deactivate 删除某个虚拟环境： rmvirtualenv my_env 列出所有虚拟环境： lsvirtualenv 进入到虚拟环境所在的目录： cdvirtualenv 修改mkvirtualenv的默认路径： 在我的电脑->右键->属性->高级系统设置->环境变量->系统变量中添加一个参数WORKON_HOME，将这个参数的值设置为你需要的路径。 创建虚拟环境的时候指定Python版本： 在使用mkvirtualenv的时候，可以指定--python的参数来指定具体的python路径： mkvirtualenv --python==C:\\Python36\\python.exe hy_env "},"django/django打造大型企业/第一章：学前准备/第二节：准备工作.html":{"url":"django/django打造大型企业/第一章：学前准备/第二节：准备工作.html","title":"第二节：准备工作","keywords":"","body":"学前准备 在学习Django之前，需要做好以下准备工作： 确保已经安装Python 3.6以上的版本，教学以Python 3.6版本进行讲解。 安装virtualenvwrapper，这个是用来创建虚拟环境的包，使用虚拟环境可以让我们的包管理更加的方便，也为以后项目上线需要安装哪些包做好了准备工作。安装方式在不同的操作系统有区别。以下解释下： windows：pip instal virtualenvwrapper-win。 linux/mac：pip install virtualenvwrapper。 虚拟环境相关操作： 创建虚拟环境：mkvirtualenv --python='[python3.6文件所在路径]' [虚拟环境名字]。比如mkvirtualenv --python='C:\\Python36\\python3.6' django-env。 进入到虚拟环境：workon [虚拟环境名称]。比如workon django-env。 退出虚拟环境：deactivate。 首先进入到虚拟环境workon django-env，然后通过pip install django==2.0安装django，教学以Django 2.0版本为例进行讲解。 安装pycharm profession 2017版或者Sublime Text 3等任意一款你喜欢的编辑器。（推荐使用pycharm，如果由于电脑性能原因，可以退而求其次使用Sublime Text）。如果使用pycharm，切记一定要下载profession（专业版），community（社区版）不能用于网页开发。至于破解和正版，大家到网上搜下就知道啦。 安装最新版MySQL，windows版的MySQL的下载地址是：https://dev.mysql.com/downloads/windows/installer/5.7.html。如果你用的是其他操作系统，那么可以来到这个界面选择具体的MySQL来进行下载：https://dev.mysql.com/downloads/mysql/。 安装pymysql，这个库是Python来操作数据库的。没有他，django就不能操作数据库。安装方式也比较简单，pip install pymysql就可以啦。 建议：建议使用和课程中一样的环境来学习，避免环境问题造成一些莫名其妙的错误影响学习进度和效率。 "},"django/django打造大型企业/第一章：学前准备/第三节：Django介绍.html":{"url":"django/django打造大型企业/第一章：学前准备/第三节：Django介绍.html","title":"第三节：Django介绍","keywords":"","body":"Django介绍： Django，发音为[`dʒæŋɡəʊ]，Django诞生于2003年秋天，2005年发布正式版本，由Simon和Andrian开发。当时两位作者的老板和记者要他们几天甚至几个小时之内增加新的功能。两人不得已开发了Django这套框架以实现快速开发目的，因此Django生来就是为了节省开发者时间的。Django发展至今，被许许多多国内外的开发者使用，已经成为web开发者的首选框架。因此，如果你是用python来做网站，没有理由不学好Django。 选读： Python+Django如何支撑了7 亿月活用户的Instagram？ Django商业网站 Django版本和Python版本： web服务器和应用服务器以及web应用框架： web服务器：负责处理http请求，响应静态文件，常见的有Apache，Nginx以及微软的IIS. 应用服务器：负责处理逻辑的服务器。比如php、python的代码，是不能直接通过nginx这种web服务器来处理的，只能通过应用服务器来处理，常见的应用服务器有uwsgi、tomcat等。 web应用框架：一般使用某种语言，封装了常用的web功能的框架就是web应用框架，flask、Django以及Java中的SSH(Structs2+Spring3+Hibernate3)框架都是web应用框架。 Django和MVC： Django是一个遵循MVC设计模式的框架，MVC是Model、View、Controller的三个单词的简写。分别代表模型、视图、控制器。以下图片说明这三者之间的关系： 而Django其实也是一个MTV的设计模式。MTV是Model、Template、View三个单词的简写。分别代表模型、模版、视图。以下图片说明这三者之间的关系： 更多： Django的官网：https://www.djangoproject.com/ Django Book2.0版本的中文文档：http://djangobook.py3k.cn/2.0/chapter01/ Django2.0版本的中文文档：http://python.usyiyi.cn/translate/django2/index.html "},"django/django打造大型企业/第一章：学前准备/第四节：URL组成部分.html":{"url":"django/django打造大型企业/第一章：学前准备/第四节：URL组成部分.html","title":"第四节：URL组成部分","keywords":"","body":"URL组成部分详解： URL是Uniform Resource Locator的简写，统一资源定位符。 一个URL由以下几部分组成： scheme://host:port/path/?query-string=xxx#anchor scheme：代表的是访问的协议，一般为http或者https以及ftp等。 host：主机名，域名，比如www.baidu.com。 port：端口号。当你访问一个网站的时候，浏览器默认使用80端口。 path：查找路径。比如：www.jianshu.com/trending/now，后面的trending/now就是path。 query-string：查询字符串，比如：www.baidu.com/s?wd=python，后面的wd=python就是查询字符串。 anchor：锚点，后台一般不用管，前端用来做页面定位的。 注意：URL中的所有字符都是ASCII字符集，如果出现非ASCII字符，比如中文，浏览器会进行编码再进行传输。 "},"django/django打造大型企业/第二章：URL与视图/第一节：第一个Django项目.html":{"url":"django/django打造大型企业/第二章：URL与视图/第一节：第一个Django项目.html","title":"第一节：第一个Django项目","keywords":"","body":"第一个Django项目 创建Django项目： 用命令行的方式： 创建项目：打开终端，使用命令：django-admin startproject [项目名称]即可创建。比如：django-admin startproject first_project。 创建应用（app）：一个项目类似于是一个架子，但是真正起作用的还是app。在终端进入到项目所在的路径，然后执行python manage.py startapp [app名称]创建一个app。 用pycharm的方式： 用pycharm新建一个Django项目，新建项目的截图如下： 使用pycharm创建完项目后，还是需要重新进入到命令行单独创建app的。 运行Django项目： 通过命令行的方式：python manage.py runserver。这样可以在本地访问你的网站，默认端口号是8000，这样就可以在浏览器中通过http://127.0.0.1:8000/来访问你的网站啦。如果想要修改端口号，那么在运行的时候可以指定端口号，python manage.py runserver 9000这样就可以通过9000端口来访问啦。另外，这样运行的项目只能在本机上能访问，如果想要在其他电脑上也能访问本网站，那么需要指定ip地址为0.0.0.0。示例为：python manage.py runserver 0.0.0.0:8000。 通过pycharm运行。直接点击右上角的绿色箭头按钮即可运行。 项目结构介绍： manage.py：以后和项目交互基本上都是基于这个文件。一般都是在终端输入python manage.py [子命令]。可以输入python manage.py help看下能做什么事情。除非你知道你自己在做什么，一般情况下不应该编辑这个文件。 settings.py：本项目的设置项，以后所有和项目相关的配置都是放在这个里面。 urls.py：这个文件是用来配置URL路由的。比如访问http://127.0.0.1/news/是访问新闻列表页，这些东西就需要在这个文件中完成。 wsgi.py：项目与WSGI协议兼容的web服务器入口，部署的时候需要用到的，一般情况下也是不需要修改的。 project和app的关系： app是django项目的组成部分。一个app代表项目中的一个模块，所有URL请求的响应都是由app来处理。比如豆瓣，里面有图书，电影，音乐，同城等许许多多的模块，如果站在django的角度来看，图书，电影这些模块就是app，图书，电影这些app共同组成豆瓣这个项目。因此这里要有一个概念，django项目由许多app组成，一个app可以被用到其他项目，django也能拥有不同的app。 "},"django/django打造大型企业/第二章：URL与视图/第二节：视图与URL分发器.html":{"url":"django/django打造大型企业/第二章：URL与视图/第二节：视图与URL分发器.html","title":"第二节：准备工作","keywords":"","body":"URL分发器 视图： 视图一般都写在app的views.py中。并且视图的第一个参数永远都是request（一个HttpRequest）对象。这个对象存储了请求过来的所有信息，包括携带的参数以及一些头部信息等。在视图中，一般是完成逻辑相关的操作。比如这个请求是添加一篇博客，那么可以通过request来接收到这些数据，然后存储到数据库中，最后再把执行的结果返回给浏览器。视图函数的返回结果必须是HttpResponseBase对象或者子类的对象。示例代码如下： from django.http import HttpResponse def book_list(request): return HttpResponse(\"书籍列表！\") URL映射： 视图写完后，要与URL进行映射，也即用户在浏览器中输入什么url的时候可以请求到这个视图函数。在用户输入了某个url，请求到我们的网站的时候，django会从项目的urls.py文件中寻找对应的视图。在urls.py文件中有一个urlpatterns变量，以后django就会从这个变量中读取所有的匹配规则。匹配规则需要使用django.urls.path函数进行包裹，这个函数会根据传入的参数返回URLPattern或者是URLResolver的对象。示例代码如下： from django.contrib import admin from django.urls import path from book import views urlpatterns = [ path('admin/', admin.site.urls), path('book/',views.book_list) ] URL中添加参数： 有时候，url中包含了一些参数需要动态调整。比如简书某篇文章的详情页的url，是https://www.jianshu.com/p/a5aab9c4978e后面的a5aab9c4978e就是这篇文章的id，那么简书的文章详情页面的url就可以写成https://www.jianshu.com/p/，其中id就是文章的id。那么如何在django中实现这种需求呢。这时候我们可以在path函数中，使用尖括号的形式来定义一个参数。比如我现在想要获取一本书籍的详细信息，那么应该在url中指定这个参数。示例代码如下： from django.contrib import admin from django.urls import path from book import views urlpatterns = [ path('admin/', admin.site.urls), path('book/',views.book_list), path('book//',views.book_detail) ] 而views.py中的代码如下： def book_detail(request,book_id): text = \"您输入的书籍的id是：%s\" % book_id return HttpResponse(text) 当然，也可以通过查询字符串的方式传递一个参数过去。示例代码如下： urlpatterns = [ path('admin/', admin.site.urls), path('book/',views.book_list), path('book/detail/',views.book_detail) ] 在views.py中的代码如下： def book_detail(request): book_id = request.GET.get(\"id\") text = \"您输入的书籍id是：%s\" % book_id return HttpResponse(text) 以后在访问的时候就是通过/book/detail/?id=1即可将参数传递过去。 URL中包含另外一个urls模块： 在我们的项目中，不可能只有一个app，如果把所有的app的views中的视图都放在urls.py中进行映射，肯定会让代码显得非常乱。因此django给我们提供了一个方法，可以在app内部包含自己的url匹配规则，而在项目的urls.py中再统一包含这个app的urls。使用这个技术需要借助include函数。示例代码如下： # first_project/urls.py文件： from django.contrib import admin from django.urls import path,include urlpatterns = [ path('admin/', admin.site.urls), path('book/',include(\"book.urls\")) ] 在urls.py文件中把所有的和book这个app相关的url都移动到app/urls.py中了，然后在first_project/urls.py中，通过include函数包含book.urls，以后在请求book相关的url的时候都需要加一个book的前缀。 # book/urls.py文件： from django.urls import path from . import views urlpatterns = [ path('list/',views.book_list), path('detail//',views.book_detail) ] 以后访问书的列表的url的时候，就通过/book/list/来访问，访问书籍详情页面的url的时候就通过book/detail/来访问。 path函数： path函数的定义为：path(route,view,name=None,kwargs=None)。以下对这几个参数进行讲解。 route参数：url的匹配规则。这个参数中可以指定url中需要传递的参数，比如在访问文章详情页的时候，可以传递一个id。传递参数是通过<>尖括号来进行指定的。并且在传递参数的时候，可以指定这个参数的数据类型，比如文章的id都是int类型，那么可以这样写`，以后匹配的时候，就只会匹配到id为int类型的url，而不会匹配其他的url，并且在视图函数中获取这个参数的时候，就已经被转换成一个int`类型了。其中还有几种常用的类型： str：非空的字符串类型。默认的转换器。但是不能包含斜杠。 int：匹配任意的零或者正数的整形。到视图函数中就是一个int类型。 slug：由英文中的横杠-，或者下划线_连接英文字符或者数字而成的字符串。 uuid：匹配uuid字符串。 path：匹配非空的英文字符串，可以包含斜杠。 view参数：可以为一个视图函数或者是类视图.as_view()或者是django.urls.include()函数的返回值。 name参数：这个参数是给这个url取个名字的，这在项目比较大，url比较多的时候用处很大。 kwargs参数：有时候想给视图函数传递一些额外的参数，就可以通过kwargs参数进行传递。这个参数接收一个字典。传到视图函数中的时候，会作为一个关键字参数传过去。比如以下的url规则： from django.urls import path from . import views urlpatterns = [ path('blog//', views.year_archive, {'foo': 'bar'}), ] 那么以后在访问blog/1991/这个url的时候，会将foo=bar作为关键字参数传给year_archive函数。 re_path函数： 有时候我们在写url匹配的时候，想要写使用正则表达式来实现一些复杂的需求，那么这时候我们可以使用re_path来实现。re_path的参数和path参数一模一样，只不过第一个参数也就是route参数可以为一个正则表达式。 一些使用re_path的示例代码如下： from django.urls import path, re_path from . import views urlpatterns = [ path('articles/2003/', views.special_case_2003), re_path(r'articles/(?P[0-9]{4})/', views.year_archive), re_path(r'articles/(?P[0-9]{4})/(?P[0-9]{2})/', views.month_archive), re_path(r'articles/(?P[0-9]{4})/(?P[0-9]{2})/(?P[\\w-_]+)/', views.article_detail), ] 以上例子中我们可以看到，所有的route字符串前面都加了一个r，表示这个字符串是一个原生字符串。在写正则表达式中是推荐使用原生字符串的，这样可以避免在python这一层面进行转义。而且，使用正则表达式捕获参数的时候，是用一个圆括号进行包裹，然后这个参数的名字是通过尖括号``进行包裹，之后才是写正则表达式的语法。 include函数： 在项目变大以后，经常不会把所有的url匹配规则都放在项目的urls.py文件中，而是每个app都有自己的urls.py文件，在这个文件中存储的都是当前这个app的所有url匹配规则。然后再统一注册到项目的urls.py文件中。include函数有多种用法，这里讲下两种常用的用法。 include(pattern,namespace=None)：直接把其他app的urls包含进来。示例代码如下： from django.contrib import admin from django.urls import path,include urlpatterns = [ path('admin/', admin.site.urls), path('book/',include(\"book.urls\")) ] 当然也可以传递namespace参数来指定一个实例命名空间，但是在使用实例命名空间之前，必须先指定一个应用命名空间。示例代码如下： # 主urls.py文件： from django.urls import path,include urlpatterns = [ path('movie/',include('movie.urls',namespace='movie')) ] 然后在movie/urls.py中指定应用命名空间。实例代码如下： from django.urls import path from . import views # 应用命名空间 app_name = 'movie' urlpatterns = [ path('',views.movie,name='index'), path('list/',views.movie_list,name='list'), ] include(pattern_list)：可以包含一个列表或者一个元组，这个元组或者列表中又包含的是path或者是re_path函数。 include((pattern,app_namespace),namespace=None)：在包含某个app的urls的时候，可以指定命名空间，这样做的目的是为了防止不同的app下出现相同的url，这时候就可以通过命名空间进行区分。示例代码如下： from django.contrib import admin from django.urls import path,include urlpatterns = [ path('admin/', admin.site.urls), path('book/',include((\"book.urls\",'book')),namespace='book') ] 但是这样做的前提是已经包含了应用命名空间。即在myapp.urls.py中添加一个和urlpatterns同级别的变量app_name。 指定默认的参数： 使用path或者是re_path的后，在route中都可以包含参数，而有时候想指定默认的参数，这时候可以通过以下方式来完成。示例代码如下： from django.urls import path from . import views urlpatterns = [ path('blog/', views.page), path('blog/page/', views.page), ] # View (in blog/views.py) def page(request, num=1): # Output the appropriate page of blog entries, according to num. ... 当在访问blog/的时候，因为没有传递num参数，所以会匹配到第一个url，这时候就执行view.page这个视图函数，而在page函数中，又有num=1这个默认参数。因此这时候就可以不用传递参数。而如果访问blog/1的时候，因为在传递参数的时候传递了num，因此会匹配到第二个url，这时候也会执行views.page，然后把传递进来的参数传给page函数中的num。 url反转： 之前我们都是通过url来访问视图函数。有时候我们知道这个视图函数，但是想反转回他的url。这时候就可以通过reverse来实现。示例代码如下： reverse(\"list\") > /book/list/ 如果有应用命名空间或者有实例命名空间，那么应该在反转的时候加上命名空间。示例代码如下： reverse('book:list') > /book/list/ 如果这个url中需要传递参数，那么可以通过kwargs来传递参数。示例代码如下： reverse(\"book:detail\",kwargs={\"book_id\":1}) > /book/detail/1 因为django中的reverse反转url的时候不区分GET请求和POST请求，因此不能在反转的时候添加查询字符串的参数。如果想要添加查询字符串的参数，只能手动的添加。示例代码如下： login_url = reverse('login') + \"?next=/\" 自定义URL转换器： 之前已经学到过一些django内置的url转换器，包括有int、uuid等。有时候这些内置的url转换器并不能满足我们的需求，因此django给我们提供了一个接口可以让我们自己定义自己的url转换器。 自定义url转换器按照以下五个步骤来走就可以了： 定义一个类。 在类中定义一个属性regex，这个属性是用来保存url转换器规则的正则表达式。 实现to_python(self,value)方法，这个方法是将url中的值转换一下，然后传给视图函数的。 实现to_url(self,value)方法，这个方法是在做url反转的时候，将传进来的参数转换后拼接成一个正确的url。 将定义好的转换器，注册到django中。 比如写一个匹配四个数字年份的url转换器。示例代码如下： # 1. 定义一个类 class FourDigitYearConverter: # 2. 定义一个正则表达式 regex = '[0-9]{4}' # 3. 定义to_python方法 def to_python(self, value): return int(value) # 4. 定义to_url方法 def to_url(self, value): return '%04d' % value # 5. 注册到django中 from django.urls import register_converter register_converter(converters.FourDigitYearConverter, 'yyyy') urlpatterns = [ path('articles/2003/', views.special_case_2003), # 使用注册的转换器 path('articles//', views.year_archive), ... ] "},"django/django打造大型企业/第三章：模板/第一节：模板介绍.html":{"url":"django/django打造大型企业/第三章：模板/第一节：模板介绍.html","title":"第一节：模板介绍","keywords":"","body":"模板 在之前的章节中，视图函数只是直接返回文本，而在实际生产环境中其实很少这样用，因为实际的页面大多是带有样式的HTML代码，这可以让浏览器渲染出非常漂亮的页面。目前市面上有非常多的模板系统，其中最知名最好用的就是DTL和Jinja2。DTL是Django Template Language三个单词的缩写，也就是Django自带的模板语言。当然也可以配置Django支持Jinja2等其他模板引擎，但是作为Django内置的模板语言，和Django可以达到无缝衔接而不会产生一些不兼容的情况。因此建议大家学习好DTL。 DTL与普通的HTML文件的区别： DTL模板是一种带有特殊语法的HTML文件，这个HTML文件可以被Django编译，可以传递参数进去，实现数据动态化。在编译完成后，生成一个普通的HTML文件，然后发送给客户端。 渲染模板： 渲染模板有多种方式。这里讲下两种常用的方式。 render_to_string：找到模板，然后将模板编译后渲染成Python的字符串格式。最后再通过HttpResponse类包装成一个HttpResponse对象返回回去。示例代码如下： from django.template.loader import render_to_string from django.http import HttpResponse def book_detail(request,book_id): html = render_to_string(\"detail.html\") return HttpResponse(html) 以上方式虽然已经很方便了。但是django还提供了一个更加简便的方式，直接将模板渲染成字符串和包装成HttpResponse对象一步到位完成。示例代码如下： from django.shortcuts import render def book_list(request): return render(request,'list.html') 模板查找路径配置： 在项目的settings.py文件中。有一个TEMPLATES配置，这个配置包含了模板引擎的配置，模板查找路径的配置，模板上下文的配置等。模板路径可以在两个地方配置。 DIRS：这是一个列表，在这个列表中可以存放所有的模板路径，以后在视图中使用render或者render_to_string渲染模板的时候，会在这个列表的路径中查找模板。 APP_DIRS：默认为True，这个设置为True后，会在INSTALLED_APPS的安装了的APP下的templates文件加中查找模板。 查找顺序：比如代码render('list.html')。先会在DIRS这个列表中依次查找路径下有没有这个模板，如果有，就返回。如果DIRS列表中所有的路径都没有找到，那么会先检查当前这个视图所处的app是否已经安装，如果已经安装了，那么就先在当前这个app下的templates文件夹中查找模板，如果没有找到，那么会在其他已经安装了的app中查找。如果所有路径下都没有找到，那么会抛出一个TemplateDoesNotExist的异常。 "},"django/django打造大型企业/第三章：模板/第二节：模板变量.html":{"url":"django/django打造大型企业/第三章：模板/第二节：模板变量.html","title":"第二节：模板变量","keywords":"","body":"DTL模板语法 变量： 模板中可以包含变量，Django在渲染模板的时候，可以传递变量对应的值过去进行替换。变量的命名规范和Python非常类似，只能是阿拉伯数字和英文字符以及下划线的组合，不能出现标点符号等特殊字符。变量需要通过视图函数渲染，视图函数在使用render或者render_to_string的时候可以传递一个context的参数，这个参数是一个字典类型。以后在模板中的变量就从这个字典中读取值的。示例代码如下： # profile.html模板代码 # views.py代码 def profile(request): return render(request,'profile.html',context={'username':'huangyong'}) 模板中的变量同样也支持点(.)的形式。在出现了点的情况，比如person.username，模板是按照以下方式进行解析的： 如果person是一个字典，那么就会查找这个字典的username这个key对应的值。 如果person是一个对象，那么就会查找这个对象的username属性，或者是username这个方法。 如果出现的是person.1，会判断persons是否是一个列表或者元组或者任意的可以通过下标访问的对象，如果是的话就取这个列表的第1个值。如果不是就获取到的是一个空的字符串。 不能通过中括号的形式访问字典和列表中的值，比如dict['key']和list[1]是不支持的！ 因为使用点（.）语法获取对象值的时候，可以获取这个对象的属性，如果这个对象是一个字典，也可以获取这个字典的值。所以在给这个字典添加key的时候，千万不能和字典中的一些属性重复。比如items，items是字典的方法，那么如果给这个字典添加一个items作为key，那么以后就不能再通过item来访问这个字典的键值对了。 "},"django/django打造大型企业/第三章：模板/第三节：常用标签.html":{"url":"django/django打造大型企业/第三章：模板/第三节：常用标签.html","title":"第三节：常用标签","keywords":"","body":"常用的模板标签： if标签：if标签相当于Python中的if语句，有elif和else相对应，但是所有的标签都需要用标签符号（{%%}）进行包裹。if标签中可以使用==、!=、、>=、in、not in、is、is not等判断运算符。示例代码如下： {% if \"张三\" in persons %} 张三 {% else %} 李四 {% endif %} for...in...标签：for...in...类似于Python中的for...in...。可以遍历列表、元组、字符串、字典等一切可以遍历的对象。示例代码如下： {% for person in persons %} {{ person.name }} {% endfor %} 如果想要反向遍历，那么在遍历的时候就加上一个reversed。示例代码如下： {% for person in persons reversed %} {{ person.name }} {% endfor %} 遍历字典的时候，需要使用items、keys和values等方法。在DTL中，执行一个方法不能使用圆括号的形式。遍历字典示例代码如下： {% for key,value in person.items %} key：{{ key }} value：{{ value }} {% endfor %} 在for循环中，DTL提供了一些变量可供使用。这些变量如下： forloop.counter：当前循环的下标。以1作为起始值。 forloop.counter0：当前循环的下标。以0作为起始值。 forloop.revcounter：当前循环的反向下标值。比如列表有5个元素，那么第一次遍历这个属性是等于5，第二次是4，以此类推。并且是以1作为最后一个元素的下标。 forloop.revcounter0：类似于forloop.revcounter。不同的是最后一个元素的下标是从0开始。 forloop.first：是否是第一次遍历。 forloop.last：是否是最后一次遍历。 forloop.parentloop：如果有多个循环嵌套，那么这个属性代表的是上一级的for循环。 for...in...empty标签：这个标签使用跟for...in...是一样的，只不过是在遍历的对象如果没有元素的情况下，会执行empty中的内容。示例代码如下： {% for person in persons %} {{ person }} {% empty %} 暂时还没有任何人 {% endfor %} with标签：在模版中定义变量。有时候一个变量访问的时候比较复杂，那么可以先把这个复杂的变量缓存到一个变量上，以后就可以直接使用这个变量就可以了。示例代码如下： context = { \"persons\": [\"张三\",\"李四\"] } {% with lisi=persons.1 %} {{ lisi }} {% endwith %} 有几点需要强烈的注意： 在with语句中定义的变量，只能在{%with%}{%endwith%}中使用，不能在这个标签外面使用。 定义变量的时候，不能在等号左右两边留有空格。比如{% with lisi = persons.1%}是错误的。 还有另外一种写法同样也是支持的： {% with persons.1 as lisi %} {{ lisi }} {% endwith %} url标签：在模版中，我们经常要写一些url，比如某个a标签中需要定义href属性。当然如果通过硬编码的方式直接将这个url写死在里面也是可以的。但是这样对于以后项目维护可能不是一件好事。因此建议使用这种反转的方式来实现，类似于django中的reverse一样。示例代码如下： 图书列表页面 如果url反转的时候需要传递参数，那么可以在后面传递。但是参数分位置参数和关键字参数。位置参数和关键字参数不能同时使用。示例代码如下： # path部分 path('detail//',views.book_detail,name='detail') # url反转，使用位置参数 图书详情页面 # url反转，使用关键字参数 图书详情页面 如果想要在使用url标签反转的时候要传递查询字符串的参数，那么必须要手动在在后面添加。示例代码如下： 图书详情页面 如果需要传递多个参数，那么通过空格的方式进行分隔。示例代码如下： 图书详情页面 spaceless标签：移除html标签中的空白字符。包括空格、tab键、换行等。示例代码如下： {% spaceless %} Foo {% endspaceless %} 那么在渲染完成后，会变成以下的代码： Foo spaceless只会移除html标签之间的空白字符。而不会移除标签与文本之间的空白字符。看以下代码： {% spaceless %} Hello {% endspaceless %} 这个将不会移除strong中的空白字符。 autoescape标签：开启和关闭这个标签内元素的自动转义功能。自动转义是可以将一些特殊的字符。比如转义成html语法能识别的字符，比如会被转义成，而>会被自动转义成>。模板中默认是已经开启了自动转义的。autoescape的示例代码如下： # 传递的上下文信息 context = { \"info\":\"百度\" } # 模板中关闭自动转义 {% autoescape on %} {{ info }} {% endautoescape %} 那么就会显示百度的一个超链接。如果把on成off，那么就会显示成一个普通的字符串。示例代码如下： {% autoescape on %} {{ info }} {% endautoescape %} verbatim标签：默认在DTL模板中是会去解析那些特殊字符的。比如{%和%}以及{{等。如果你在某个代码片段中不想使用DTL的解析引擎。那么你可以把这个代码片段放在verbatim标签中。示例代码下： {% verbatim %} {{if dying}}Still alive.{{/if}} {% endverbatim %} 更多标签请参考官方文档：https://docs.djangoproject.com/en/2.0/ref/templates/builtins/ "},"django/django打造大型企业/第三章：模板/第四节：常用过滤器.html":{"url":"django/django打造大型企业/第三章：模板/第四节：常用过滤器.html","title":"第四节：常用过滤器","keywords":"","body":"模版常用过滤器 在模版中，有时候需要对一些数据进行处理以后才能使用。一般在Python中我们是通过函数的形式来完成的。而在模版中，则是通过过滤器来实现的。过滤器使用的是|来使用。比如使用add过滤器，那么示例代码如下： {{ value|add:\"2\" }} 那么以下就讲下在开发中常用的过滤器。 add 将传进来的参数添加到原来的值上面。这个过滤器会尝试将值和参数转换成整形然后进行相加。如果转换成整形过程中失败了，那么会将值和参数进行拼接。如果是字符串，那么会拼接成字符串，如果是列表，那么会拼接成一个列表。示例代码如下： {{ value|add:\"2\" }} 如果value是等于4，那么结果将是6。如果value是等于一个普通的字符串，比如abc，那么结果将是abc2。add过滤器的源代码如下： def add(value, arg): \"\"\"Add the arg to the value.\"\"\" try: return int(value) + int(arg) except (ValueError, TypeError): try: return value + arg except Exception: return '' cut 移除值中所有指定的字符串。类似于python中的replace(args,\"\")。示例代码如下： {{ value|cut:\" \" }} 以上示例将会移除value中所有的空格字符。cut过滤器的源代码如下： def cut(value, arg): \"\"\"Remove all values of arg from the given string.\"\"\" safe = isinstance(value, SafeData) value = value.replace(arg, '') if safe and arg != ';': return mark_safe(value) return value date 将一个日期按照指定的格式，格式化成字符串。示例代码如下： # 数据 context = { \"birthday\": datetime.now() } # 模版 {{ birthday|date:\"Y/m/d\" }} 那么将会输出2018/02/01。其中Y代表的是四位数字的年份，m代表的是两位数字的月份，d代表的是两位数字的日。 还有更多时间格式化的方式。见下表。 格式字符 描述 示例 Y 四位数字的年份 2018 m 两位数字的月份 01-12 n 月份，1-9前面没有0前缀 1-12 d 两位数字的天 01-31 j 天，但是1-9前面没有0前缀 1-31 g 小时，12小时格式的，1-9前面没有0前缀 1-12 h 小时，12小时格式的，1-9前面有0前缀 01-12 G 小时，24小时格式的，1-9前面没有0前缀 1-23 H 小时，24小时格式的，1-9前面有0前缀 01-23 i 分钟，1-9前面有0前缀 00-59 s 秒，1-9前面有0前缀 00-59 default 如果值被评估为False。比如[]，\"\"，None，{}等这些在if判断中为False的值，都会使用default过滤器提供的默认值。示例代码如下： {{ value|default:\"nothing\" }} 如果value是等于一个空的字符串。比如\"\"，那么以上代码将会输出nothing。 default_if_none 如果值是None，那么将会使用default_if_none提供的默认值。这个和default有区别，default是所有被评估为False的都会使用默认值。而default_if_none则只有这个值是等于None的时候才会使用默认值。示例代码如下： {{ value|default_if_none:\"nothing\" }} 如果value是等于\"\"也即空字符串，那么以上会输出空字符串。如果value是一个None值，以上代码才会输出nothing。 first 返回列表/元组/字符串中的第一个元素。示例代码如下： {{ value|first }} 如果value是等于['a','b','c']，那么输出将会是a。 last 返回列表/元组/字符串中的最后一个元素。示例代码如下： {{ value|last }} 如果value是等于['a','b','c']，那么输出将会是c。 floatformat 使用四舍五入的方式格式化一个浮点类型。如果这个过滤器没有传递任何参数。那么只会在小数点后保留一个小数，如果小数后面全是0，那么只会保留整数。当然也可以传递一个参数，标识具体要保留几个小数。 如果没有传递参数： | value | 模版代码 | 输出 | | ----- | -------- | ---- | | 34.23234 | {{ value\\|floatformat }} | 34.2 | | 34.000 | {{ value\\|floatformat }} | 34 | | 34.260 | {{ value\\|floatformat }} | 34.3 | 如果传递参数： | value | 模版代码 | 输出 | | ----- | -------- | ---- | | 34.23234 | {{value\\|floatformat:3}} | 34.232 | | 34.0000 | {{value\\|floatformat:3}} | 34.000 | | 34.26000 | {{value\\|floatformat:3}} | 34.260 | join 类似与Python中的join，将列表/元组/字符串用指定的字符进行拼接。示例代码如下： {{ value|join:\"/\" }} 如果value是等于['a','b','c']，那么以上代码将输出a/b/c。 length 获取一个列表/元组/字符串/字典的长度。示例代码如下： {{ value|length }} 如果value是等于['a','b','c']，那么以上代码将输出3。如果value为None，那么以上将返回0。 lower 将值中所有的字符全部转换成小写。示例代码如下： {{ value|lower }} 如果value是等于Hello World。那么以上代码将输出hello world。 upper 类似于lower，只不过是将指定的字符串全部转换成大写。 random 在被给的列表/字符串/元组中随机的选择一个值。示例代码如下： {{ value|random }} 如果value是等于['a','b','c']，那么以上代码会在列表中随机选择一个。 safe 标记一个字符串是安全的。也即会关掉这个字符串的自动转义。示例代码如下： {{value|safe}} 如果value是一个不包含任何特殊字符的字符串，比如`这种，那么以上代码就会把字符串正常的输入。如果value是一串html代码，那么以上代码将会把这个html`代码渲染到浏览器中。 slice 类似于Python中的切片操作。示例代码如下： {{ some_list|slice:\"2:\" }} 以上代码将会给some_list从2开始做切片操作。 stringtags 删除字符串中所有的html标签。示例代码如下： {{ value|striptags }} 如果value是hello world，那么以上代码将会输出hello world。 truncatechars 如果给定的字符串长度超过了过滤器指定的长度。那么就会进行切割，并且会拼接三个点来作为省略号。示例代码如下： {{ value|truncatechars:5 }} 如果value是等于北京欢迎您~，那么输出的结果是北京...。可能你会想，为什么不会北京欢迎您...呢。因为三个点也占了三个字符，所以北京+三个点的字符长度就是5。 truncatechars_html 类似于truncatechars，只不过是不会切割html标签。示例代码如下： {{ value|truncatechars:5 }} 如果value是等于北京欢迎您~，那么输出将是北京...。 "},"django/django打造大型企业/第三章：模板/第五节：自定义过滤.html":{"url":"django/django打造大型企业/第三章：模板/第五节：自定义过滤.html","title":"第五节：自定义过滤","keywords":"","body":"自定义模版过滤器 虽然DTL给我们内置了许多好用的过滤器。但是有些时候还是不能满足我们的需求。因此Django给我们提供了一个接口，可以让我们自定义过滤器，实现自己的需求。 模版过滤器必须要放在app中，并且这个app必须要在INSTALLED_APPS中进行安装。然后再在这个app下面创建一个Python包叫做templatetags。再在这个包下面创建一个python文件。比如app的名字叫做book，那么项目结构如下： - book - views.py - urls.py - models.py - templatetags - my_filter.py 在创建了存储过滤器的文件后，接下来就是在这个文件中写过滤器了。过滤器实际上就是python中的一个函数，只不过是把这个函数注册到模板库中，以后在模板中就可以使用这个函数了。但是这个函数的参数有限制，第一个参数必须是这个过滤器需要处理的值，第二个参数可有可无，如果有，那么就意味着在模板中可以传递参数。并且过滤器的函数最多只能有两个参数。在写完过滤器后，再使用django.template.Library对象注册进去。示例代码如下： from django import template # 创建模板库对象 register = template.Library() # 过滤器函数 def mycut(value,mystr): return value.replace(mystr) # 将函数注册到模板库中 register.filter(\"mycut\",mycut) 以后想要在模板中使用这个过滤器，就要在模板中load一下这个过滤器所在的模块的名字（也就是这个python文件的名字）。示例代码如下： {% load my_filter %} 自定义时间计算过滤器： 有时候经常会在朋友圈、微博中可以看到一条信息发表的时间，并不是具体的时间，而是距离现在多久。比如刚刚，1分钟前等。这个功能DTL是没有内置这样的过滤器的，因此我们可以自定义一个这样的过滤器。示例代码如下： # time_filter.py文件 from datetime import datetime from django import template register = template.Library() def time_since(value): \"\"\" time距离现在的时间间隔 1. 如果时间间隔小于1分钟以内，那么就显示“刚刚” 2. 如果是大于1分钟小于1小时，那么就显示“xx分钟前” 3. 如果是大于1小时小于24小时，那么就显示“xx小时前” 4. 如果是大于24小时小于30天以内，那么就显示“xx天前” 5. 否则就是显示具体的时间 2017/10/20 16:15 \"\"\" if isinstance(value,datetime): now = datetime.now() timestamp = (now - value).total_seconds() if timestamp = 60 and timestamp = 60*60 and timestamp = 60*60*24 and timestamp 在模版中使用的示例代码如下： {% load time_filter %} ... {% value|time_since %} ... 为了更加方便的将函数注册到模版库中当作过滤器。也可以使用装饰器来将一个函数包装成过滤器。示例代码如下： from django import template register = template.Library() @register.filter(name='mycut') def mycut(value,mystr): return value.replace(mystr,\"\") "},"django/django打造大型企业/第三章：模板/第六节：模板结构优化.html":{"url":"django/django打造大型企业/第三章：模板/第六节：模板结构优化.html","title":"第六节：模板结构优化","keywords":"","body":"模版结构优化 引入模版 有时候一些代码是在许多模版中都用到的。如果我们每次都重复的去拷贝代码那肯定不符合项目的规范。一般我们可以把这些重复性的代码抽取出来，就类似于Python中的函数一样，以后想要使用这些代码的时候，就通过include包含进来。这个标签就是include。示例代码如下： # header.html 我是header # footer.html 我是footer # main.html {% include 'header.html' %} 我是main内容 {% include 'footer.html' %} include标签寻找路径的方式。也是跟render渲染模板的函数是一样的。 默认include标签包含模版，会自动的使用主模版中的上下文，也即可以自动的使用主模版中的变量。如果想传入一些其他的参数，那么可以使用with语句。示例代码如下： # header.html 用户名：{{ username }} # main.html {% include \"header.html\" with username='huangyong' %} 模板继承： 在前端页面开发中。有些代码是需要重复使用的。这种情况可以使用include标签来实现。也可以使用另外一个比较强大的方式来实现，那就是模版继承。模版继承类似于Python中的类，在父类中可以先定义好一些变量和方法，然后在子类中实现。模版继承也可以在父模版中先定义好一些子模版需要用到的代码，然后子模版直接继承就可以了。并且因为子模版肯定有自己的不同代码，因此可以在父模版中定义一个block接口，然后子模版再去实现。以下是父模版的代码： {% load static %} {% block title %}我的站点{% endblock %} {% block sidebar %} 首页 博客 {% endblock %} {% block content %}{% endblock %} 这个模版，我们取名叫做base.html，定义好一个简单的html骨架，然后定义好两个block接口，让子模版来根据具体需求来实现。子模板然后通过extends标签来实现，示例代码如下： {% extends \"base.html\" %} {% block title %}博客列表{% endblock %} {% block content %} {% for entry in blog_entries %} {{ entry.title }} {{ entry.body }} {% endfor %} {% endblock %} 需要注意的是：extends标签必须放在模版的第一行。 子模板中的代码必须放在block中，否则将不会被渲染。 如果在某个block中需要使用父模版的内容，那么可以使用{{block.super}}来继承。比如上例，{%block title%}，如果想要使用父模版的title，那么可以在子模版的title block中使用{{ block.super }}来实现。 在定义block的时候，除了在block开始的地方定义这个block的名字，还可以在block结束的时候定义名字。比如{% block title %}{% endblock title %}。这在大型模版中显得尤其有用，能让你快速的看到block包含在哪里。 "},"django/django打造大型企业/第三章：模板/第七节：加载静态文件.html":{"url":"django/django打造大型企业/第三章：模板/第七节：加载静态文件.html","title":"第七节：加载静态文件","keywords":"","body":"加载静态文件 在一个网页中，不仅仅只有一个html骨架，还需要css样式文件，js执行文件以及一些图片等。因此在DTL中加载静态文件是一个必须要解决的问题。在DTL中，使用static标签来加载静态文件。要使用static标签，首先需要{% load static %}。加载静态文件的步骤如下： 首先确保django.contrib.staticfiles已经添加到settings.INSTALLED_APPS中。 确保在settings.py中设置了STATIC_URL。 在已经安装了的app下创建一个文件夹叫做static，然后再在这个static文件夹下创建一个当前app的名字的文件夹，再把静态文件放到这个文件夹下。例如你的app叫做book，有一个静态文件叫做zhiliao.jpg，那么路径为book/static/book/zhiliao.jpg。（为什么在app下创建一个static文件夹，还需要在这个static下创建一个同app名字的文件夹呢？原因是如果直接把静态文件放在static文件夹下，那么在模版加载静态文件的时候就是使用zhiliao.jpg，如果在多个app之间有同名的静态文件，这时候可能就会产生混淆。而在static文件夹下加了一个同名app文件夹，在模版中加载的时候就是使用app/zhiliao.jpg，这样就可以避免产生混淆。） 如果有一些静态文件是不和任何app挂钩的。那么可以在settings.py中添加STATICFILES_DIRS，以后DTL就会在这个列表的路径中查找静态文件。比如可以设置为: STATICFILES_DIRS = [ os.path.join(BASE_DIR,\"static\") ] 在模版中使用load标签加载static标签。比如要加载在项目的static文件夹下的style.css的文件。那么示例代码如下： {% load static %} 如果不想每次在模版中加载静态文件都使用load加载static标签，那么可以在settings.py中的TEMPLATES/OPTIONS添加'builtins':['django.templatetags.static']，这样以后在模版中就可以直接使用static标签，而不用手动的load了。 如果没有在settings.INSTALLED_APPS中添加django.contrib.staticfiles。那么我们就需要手动的将请求静态文件的url与静态文件的路径进行映射了。示例代码如下： from django.conf import settings from django.conf.urls.static import static urlpatterns = [ # 其他的url映射 ] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT) "},"django/django打造大型企业/第四章：数据库/001django mysql安装及其一些软件.html":{"url":"django/django打造大型企业/第四章：数据库/001django mysql安装及其一些软件.html","title":"001django mysql安装及其一些软件","keywords":"","body":"mysql的安装 1、在官网下载mysql文件https://dev.mysql.com/downloads/windows/installer/5.7.html 2、然后双击安装，如果出现一下错误，则到安装netdramework框架 3、安装的时候回让你选择版本 4、上面直接全部安装的，安装完成之后会有一个mysql5.7 command line client终端直接打开 5、show databases;查看数据库,记得后边的分号 6、采用navicat（图形化界面）来操作数据库，可以连接多种数据库 破解方法网址：https://www.cnblogs.com/runw/p/11802455.html此破解方法是12版本的 1、 下载navicat Premium12 网址https://www.navicat.com.cn这里下载的是12版本的 2、暂时用的是试用版 mysql驱动程序安装 1、使用django来操作mysql，pip install mysqlclient安装 常见的mysql驱动： mysql-python：C语言操作mysql数据库的简单封装，只支持python2不支持python3 mysqlclient：支持python并且修复了一些bug pymysql：纯python实现的一个驱动。因为是纯python写的，效率不如mysql-python，但可以和python代码无缝衔接。 mysql Connector/Python：mysql官方退出纯python连接mysql驱动。因为是纯python开发的，效率不高。 "},"django/django打造大型企业/第四章：数据库/002django使用原生sql语句操作数据库.html":{"url":"django/django打造大型企业/第四章：数据库/002django使用原生sql语句操作数据库.html","title":"002django使用原生sql语句操作数据库","keywords":"","body":"django使用原生sql语句操作数据库 django配置连接数据库 在setting.py 里面的DATABASES进行配置 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), #这里的name表示引用的是db.sqlite3的文件，前面是路径 } } 数据库的配置 DATABASES = { 'default': { #数据库引擎(sqlite3/mysql/orcale等) 'ENGINE': 'django.db.backends.mysql', #数据库的名字 'NAME': 'django_db1', #连接数据库的用户名 'USER':'root', #连接数据库的密码 'PASSWORD':'123456', #连接数据库的主机地址 'HOST':'127.0.0.1', #连接数据库的端口 'PORT':'3306' } } 默认模板 TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], #系统的位置 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 连接数据库 在django中使用原生sql语句操作，就是使用python db api的接口操作。如果mysql驱动使用的是pymysql那么就是使用pymysql操作。 插入数据库数据 def index(request): #连接游标 cursor = connection.cursor() cursor.execute(\"insert into book(id , name ,author) values(null,'三国演义','罗贯中')\") return render(request,'index.html') #查找数据 cursor = connection.cursor() #cursor.execute(\"insert into book(id , name ,author) values(null,'三国演义','罗贯中')\") cursor.execute('select id,name,author from book') rows = cursor.fetchall() for row in rows: print(row) Python DB api 规范 可以查看官方的文档 "},"django/django打造大型企业/第四章：数据库/003mysql图书管理系统.html":{"url":"django/django打造大型企业/第四章：数据库/003mysql图书管理系统.html","title":"003mysql图书管理系统","keywords":"","body":"实现了一个图书管理系统 1、可以发布图书，同时也可以删除图书以及查看图书详情 控制部分代码如下： from django.shortcuts import render,redirect,reverse# 渲染 跳转 反转 from django.db import connection #引入数据库连接 # Create your views here. def get_cursor(): #定义了一个获取数据库游标的函数 return connection.cursor() def index(request): cursor = get_cursor() #cursor.execute(\"select id,name,author from book\") #books = cursor.fetchall() #返回的是[(1,'三国演义,'罗贯中'),(2,)....] #cursor.execute(\"insert into book(id,name,author) values(null,'三国演义','罗贯中')\") #可以插入数据，但是不能获取数据 cursor.execute('select * from book')#从book表中，查询所有的数据 books = cursor.fetchall()#查询所有的结果((id,name,author),(id,name,author)...) context = { 'books':books, } return render(request,'index.html',context=context) def add_book(request): if request.method =='GET': return render(request,'add_book.html') else: name = request.POST.get(\"name\") author = request.POST.get(\"author\") cursor = get_cursor() cursor.execute(\"insert into book(id,name,author) values(null,'%s','%s')\"% (name,author)) return redirect(reverse('index')) def book_detail(request,book_id): cursor = get_cursor() cursor.execute(\"select id,name,author from book where id = %s \"% book_id) book = cursor.fetchone()#查询一条数据 context = { 'book':book, } return render(request,'book_detail.html',context=context) def delete_book(request): if request.method == 'POST':#判断post请求还是get请求 很重要 book_id = request.POST.get('book_id') cursor = get_cursor() cursor.execute(\"delete from book where id=%s \"% book_id) return redirect(reverse('index')) else: raise RuntimeError(\"删除图书的method错误\") urls.py的代码如下： from django.urls import path from front import views urlpatterns = [ path('', views.index,name='index'), path('add_book/', views.add_book,name='add_book'), #repath('book_detail/(?P\\d+/))',views.book_detail,name='book_detail') path('book_detail//',views.book_detail,name='book_detail'), path('delete_book/',views.delete_book,name = 'delete_book') ] 模板代码如下： {% load static %}#这里需要加载静态页面，load static加载 图书管理系统 #加载static下面的静态css文件 首页 发布图书 {% block content %}{% endblock %}#定义了一个，在子模板中可以代替内容，继承里面的用{{super()}} {% extends 'base.html' %} {% block content %} 序号 书名 作者 {% for book in books %} {{ forloop.counter }} {{ book.1 }} {{ book.2 }} {% endfor %} {% endblock %} {% extends 'base.html' %} {% block content %} 书名: 作者: {% endblock %} {% extends 'base.html' %} {% block content %} 书名:{{ book.1 }} 作者:{{ book.2 }} {% endblock %} css样式代码如下： *{ margin:0; padding:0; } .nav{ background: #3a3a3a; height: 65px; overflow:hidden; } .nav li{ float:left; list-style: none; margin:0px 20px; line-height: 65px; } .nav li a{ color: white; text-decoration: none; } .nav li a:hover{ color:blue; } .index_table td{ border:1px red dashed; } 注意事项 1、POST提交的时候报错 CSRF 解决：可以从setting.py的MIDDLEWARE中将django.middleware.csrf.CsrfViewMiddleware这行代码注释掉。 2、mysql数据库的连接 解决：在setting.py中找到DATABASES配置代码如下： DATABASES = { 'default': { #'ENGINE': 'django.db.backends.sqlite3', 'ENGINE': 'django.db.backends.mysql',#表示mysql引擎 #'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 'NAME': 'book_manager',#数据库名称 'USER':'root',#数据库用户名 'PASSWORD':'123456',#数据库密码 'HOST':'127.0.0.1',#数据库ip地址 'PORT':'3306',#数据库端口 } } "},"django/django打造大型企业/第四章：数据库/004ORM模型.html":{"url":"django/django打造大型企业/第四章：数据库/004ORM模型.html","title":"004ORM模型","keywords":"","body":"ORM模型操作数据库 随着项目越大，原生sql的方式会出现大量的SQl语句： 1、语句重复利用率不高，越复杂SQL语句条件越多代码越长 2、修改逻辑比较码放 3、SQL忽略WEB安全问题，给未来造成隐患。如SQL注入 ORM，全称Objet Relational Maping，中文叫做对象关系映射。通过表映射成类，把行作实例，把字段作属性。 在models模型中创建： 在使用django mysql的时候，尽量使用orm模型。 ORM的好处： 1、易用性，使用orm数据库的开发可以有效的减少重复sql语句的概念，写出来的模型也更加直观、清晰。 2、性能损耗小：ORM转成底层数据库操作指令确实会有一些开销，但实际的情况这种性能损耗很少不足5%，只要不表示对性能有严苛的要求，综合考虑开发效率，代码的阅读性，带来的好处远远大于性能损耗，而且项目越大作用越明显。 3、设计灵活：可以轻松的写出复杂的查询 4、可移植性：django封装底层的数据库实现，支持福讴歌关系数据库引擎，包括与流行的mysql、postgreSQL和SQLite。可以非常轻松的切换数据库。 创建ORM模型： ORM模型一般创建在app下的models.py中 配置数据库在setting.py中 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'orm_intro', 'USER':'root', 'PASSWORD':'123456', 'HOST':'127.0.0.1', 'PORT':'3306', } } 创建app 在项目目录中，cmd窗口输入python manage.py startapp book 在book文件夹中创建models.py文件,输入代码 from django.db import models # Create your models here. #如果要将一个普通的类变成一个可以映射到数据库中的模型 #那么必须要将父类设置为models.Model或者其他的子类 class Book(models.Model): #1、id：int类型自增长 id = models.AutoField(primary_key = True)#自动增长，主键 #2、name：varchar(100)图书的名字 name = models.CharField(max_length=100,null=False)#长度最长不超过100,不能为空 #3、author：varchar(100) 图书的作者 author = models.CharField(max_length=100,null=False) #4、price:float 图书的价格 price = models.FloatField(null=False,default=0)#不能为空，默认为0 #对应好了之后就要映射到数据库,添加app到installed_apps中 #python manage.py makemigrations 使用makemigrations生成迁移脚本文件 #python manage.py migrate 使用migrate将文件生成的迁移脚本文件映射到数据库中 class Publisher(models.Model): #默认生成id主键的 name = models.CharField(max_length=100,null=False) address = models.CharField(max_length=100,null=False) #python manage.py makemigrations #python manage.py migrate app一定要在setting.py 中添加instaled_app中添加app 在当前虚拟环境下，cmd中执行语句python manage.py makemigrations 然后执行语句python manage.py migrate 上面生成的代码，都是注册在installed_app中的应用。如果还要生成其他的数据表同样在cmd中执行上面的两行语句。 python manage.py makemigrations python manage.py migrate 生成的数据表： 问题：为什么表名为book_book? 答：如果没有给表名的话，前面book表示app的名字，后面的book表示app应用的名称。 "},"django/django打造大型企业/第四章：数据库/005ORM模型基本的增删改查操作.html":{"url":"django/django打造大型企业/第四章：数据库/005ORM模型基本的增删改查操作.html","title":"005ORM模型基本的增删改查操作","keywords":"","body":"ORM模型的增删改查 添加数据： 只要使用ORM模型创建一个对象，然后再调用这个ORM模型的save方法就可以保存了。 示例代码如下： from django.http import HttpResponse # Create your views here. def index(request): #使用ORM添加一条数据到数据库中 book = Book(name='西游记',author='吴承恩',price=100) book.save() return HttpResponse(\"书籍添加成功\") 查找数据 所有的查找工作都是使用模型上的objects属性来完成的 当然也可以自定义查询对象，这部分功能会在后边讲到 1、根据主键进行查找，使用主键进行查找。可以使用objects方法，然后传递pk=xx 的方式进行查找，示例代码如下： book = Book.objects.get(pk=2) 2、根据其他字段进行查找：可以使用objects.filter代码进行查找，示例代码如下： book = Book.objects.filter(name='西游记') #返回全部为西游记的书籍 #>]> book = Book.objects.filter(name='西游记').first() #返回第一条 使用fillter方法返回的是一个QuerySet对象，这个对象类似于列表，我们可以使用这个对象的first方法来获取第一个值。 删除数据 首先查找对应的数据模型，然后再执行这个模型的delete方法即可删除，示例代码如下： book = Book.objects.get(pk=1) book.delete() 修改数据 首先查找到对应的数据模型，然后修改这个模型上的属性上的模型的值。在执行save方法即可修改完成。示例代码如下： book = Book.objects.get(pk=2) book.price = 200 book.save() class类返回样式（打印类） from django.db import models # Create your models here. class Book(models.Model): #id会自动生成的 主键 自增 name = models.CharField(max_length=100,null=False) author = models.CharField(max_length=100,null=False) price = models.FloatField(default=0) def __str__(self): # return ''.format(name=self.name,author=self.author,price=self.price) _str_()是class的默认方法，可以自定义打印的样式。 "},"django/django打造大型企业/第四章：数据库/006ORM常用Filed详解.html":{"url":"django/django打造大型企业/第四章：数据库/006ORM常用Filed详解.html","title":"006ORM常用Filed详解","keywords":"","body":"模型常用属性 常用字段： 在Django中，定义了一些Field来与数据库表中的字段类型来进行映射。以下将介绍那些常用的字段类型。 AutoField： 映射到数据库中int类型，可以有自动增长的特性。一般不需要使用这个类型，如果不指定主键，那么模型会自动的生成一个叫id的自动增长的主键，如果你想指定一个其他名字的并且具有自动增长的主键，使用AutoField也是可以的。 BigAutoField 64位的整型，类似于AutoFiled，只不过是产生的数据的范围是从1-9223372036854775807 BooleanField 在模型层面接受的是True/False。在数据库层面是tinyint类型。如果没有指定默认值，默认值是None。 CharFiled 在数据库层面是varchar类型。在python层面就是普通的字符串，这个类型在使用的时候必须要指定最大的长度，也即必须要传递max_length这个关键字参数进去。 DateField 日期类型：在python中是datatime.date类型，可以记录年月日，在映射到数据库中也是date类型。使用这个field可以传递以下几个参数： 1、auto_now在每次这个数据保存的时候后，都使用当前的时间，比如作为一个记录修改日期的字段，可以将这个属性设置为True 2、auto_now_add在每次数据第一次添加进去的时候，都使用当前时间，比如作为一个记录第一次入库的字段，可以将这个属性设置为True。 DateTimeField： 日期时间类型，类似于DataField。不仅仅存储日期，还可以存储时间。映射到数据库中datetime类型，这个filed也可以使用auto_now和auto_now_add两个属性。 TimeField： 时间类型。在数据库中是time类型。在python中是datetime.time类型。 EmailField: 类似于CharField。在数据库底层也是一个varchar类型。最大长度是254字符。 EmailField在数据库层面并不会限制字符串一定要满足邮箱格式 只是以后再使用modelForm等表单相关操作的时候回起作用 FileField 用来存储文件的，这个参考后面的文件上传文章节部分。 ImageFiled 用来存储图片文件的，这个请参考后面的图片上传章节部分。 FloatField 浮点类型。映射到数据库中是float类型。 IntegerField 整型。值得区间是-2147483648——2147483647. BigInterField 大整型。值的区间是-9223372036854775808——9223372036854775807. PositiveIntegerField 正整型。值得区间是0-2147483647 SmallIntegerField: 小整型，值得区间是-32768-32767 PositiveSmallIntegerField: 正小整型。值得区间是0-32767 TextField: 大量的文本类型。映射到数据库中是longtext类型。 UUIDField 只能存储uuid格式的字符串，uuid是一个32位的全球唯一的字符串，一般用来作为主键。 URLField 类似于CharField，只不过能用来存储url格式的字符串，并且默认的max_length是200. 如果想查看更多的字段，选择某个字段Ctrl+左单击就可以看到！ Field的常用参数： null: null = True 如果设置为True，Django将会在映射表的时候指定是否为空。默认是为Flase。在使用字符串相关的Field（CharField/TextField)的时候，官方推荐尽量不要使用这个参数，也就是保持默认值Flase.因为Django在处理字符串相关的Field的时候，及时这个Field的null=False，如果你没有给这个Field传递任何值，那么Django也会使用一个空的字符串''来作为默认值存储进去，因此如果再使用null=True,Django会产生两种空值得情形（NULL或者空字符串）。如果想要在表单验证的时候允许这个字符串为空，那么建议使用blank=True。如果你的Field是BooleanField，那么对应的可空的字段则为NullBooleanField。 #models.py class Author(models.Model): username = models.CharField(max_length=100)#默认不能为空 age = models.IntegerField(null = True) #views.py def null_text_field(request): author = Author(username='') author.save() return HttpResponse('null') blank 标识这个字段在表单验证的时候是否可以为空，默认是False。 这个和null是有区别的，null是一个纯数据库级别的，而blank是表单验证级别的。 db_column: 这个歌字段在数据库中的名字，如果没有设置这个参数，那么将会使用模型中属性的名字。 age = models.IntegerField(null = True,db_column='author_age') #db_column='author_age'加入这个参数，就会将数据表中的age改变为author_age default： 默认值，可以为一个值，或者是一个函数，但是不支持lambda表达式，并且不支持列表/字典/集合等可变得数据结构。 age = models.IntegerField(null = True,db_column='author_age',default =0) #default =0,字段默认为0 如果不给值得时候就会默认为0 now() 调用default = now 后面不需要括号，这样才是调用函数 auto_now_add auto_now_add= ture 自动加入创建的时间 primary_key 是否为主键，默认是False。 unique 在表中这个字段的值是否唯一。一般是设置手机号码/邮箱等。 telephone = models.CharField(max_length=11,unique =True,null=True) 解决之前存在数据唯一的问题，添加null = True 其他字段可以查看官方文档： https://docs.djangoproject.com/zh-hans/2.0/ref/models/fields "},"django/django打造大型企业/第四章：数据库/007navie时间和aware时间详解.html":{"url":"django/django打造大型企业/第四章：数据库/007navie时间和aware时间详解.html","title":"007navie时间和aware时间详解","keywords":"","body":"navie时间和aware时间 什么是naive时间，什么是aware时间 1、不知道自己的时间是表示的是哪个时区的，也就是不知道自己几斤几两，比较幼稚。 2、aware时间：知道自己的时间表示的是哪个时区的，也就是比较清醒。 pytz库： 专门用来处理时区的库，这个库会经常更新一些时区的数据，不需要我们担心。并且这个库在安装django的时候回默认的安装，如果没有安装，那么可以通过pip install pytz的方式进行安装。 astimezone方法： 将一个时区的时间转换为另外一个时区的时间。这个方法只能被aware类型的时间调用，不能被naive类型的时间调用。 import pytz from datetime import datetime now = datetime.now() #这是一个naive类型的时间 utc_timezone = pytz.timezone(\"UTC\")#定义UTC的时区对象 utc_now = now.astimezone(utc_timezone)#将当前的时间转换为UTC时区的时间 #>>ValueError:astimezone()cannot be applied to a naive datetime #会抛出一个异常，原因就是因为navie类型的时间不能调用astimezone方法 now = now.replace(tzinfo = pytz.timezone('Asia/Shanhai')) utc_now = now.astimezone(utc_timezone) #这时候就可以正确的转换 USE_TZ = True 如果 USE_TZ 设置为false，那么django获取到当前时间就是一个naive类型的时间 建议设置为True from django.shortcuts import render from django.http import HttpResponse from .models import Article from django.utils.timezone import now # Create your views here. def index(request): import pytz from datetime import datetime now = datetime.now() utc_timezone = pytz.timezone(\"UTC\") utc_now = now.astimezone(utc_timezone) print(utc_now)#2020-04-06 10:20:42.961093+00:00 return HttpResponse('success') replace方法： 可以将一个时间的某些属性进行更改 Django.utils.timezone.now方法： 会根据settings.py中是否设置了USE_TZ=True获取当前的时间，如果设置了，那么就获取一个aware类型的UTC时间。如果没有设置，那么会获取一个navie类型的时间。 django.utils.timezone.localtime方法： navie和aware介绍以及在django中的用法 https://docs.djangoproject.com/en/2.0/topics/i18n/timezones/ 时间的用法 models from django.db import models # Create your models here. class Article(models.Model): #付过想要使用自己定义的Field来作为主键，那么必须设置primary_key=True id = models.BigAutoField(primary_key = True) #BooleanField 布尔类型 #如果没有指定null=True，那么默认情况下，null=False #就是不能为空null #如果想要使用可以为null的BooleanField，那么使用NullBooleanField来代替 #removed = models.BooleanField() removed = models.NullBooleanField()#改过字段要重新映射 #charField如果是超过了254个字符就不建议使用了 #就推荐使用TextField：longtext title = models.CharField(max_length=200) create_time = models.DateTimeField(auto_now_add=True) #自动获取当前对象auto_now_add=True #创建时间 auto_now_add=True 是在第一次添加数据进去的时候会自动获取当前的时间 #更新时间 auto_now =True:每次这个对象条用save方法的时候都会将当前的方法更新 #python manage.py makemigrations #migrate views from django.shortcuts import render from django.http import HttpResponse from .models import Article from django.utils.timezone import now,localtime #localtime可以根据timezone时间转换 # Create your views here. def index(request): import pytz from datetime import datetime now = datetime.now() utc_timezone = pytz.timezone(\"UTC\") utc_now = now.astimezone(utc_timezone) print(utc_now)#2020-04-06 10:20:42.961093+00:00 #插入了两条数据 article = Article(title='abc',create_time=now()) article.save() # article = Article.objects.get(pk=7) # 如果数据库中没有id =7 的数据就会报错 create_time = article.create_time print('='*30) print(create_time) print(localtime(create_time)) print('=' * 30) # ''' # ============================== # 2020-04-08 08:37:06.122458+00:00 # [08/Apr/2020 16:45:04] \"GET / HTTP/1.1\" 200 7 # 2020-04-08 16:37:06.122458+08:00 # ============================== # ''' return HttpResponse('success') context = { 'create_time':create_time, } return render(request,'index.html',context=context) #======================================= article = Article(title='bcd') article.save() return HttpResponse('success') 记得在添加model的时候要运行： python manage.py makemigrations 在运行这句话的会后，如果字段以前的数据没有设置，要先进行设置 python manage.py migrate "},"django/django打造大型企业/第四章：数据库/008meta类中常见配置.html":{"url":"django/django打造大型企业/第四章：数据库/008meta类中常见配置.html","title":"008meta类中常见配置","keywords":"","body":"Meta类中常见配置 对于一些模型级别的配置，我们可以在模型中自定义一个类，叫做Meta。然后在这个类中添加一些类属性来控制模型的作用。比如我们想要在数据库映射的时候使用自己指定的表名，而不是使用模型的名称。那么我们可以在meta类中添加一个db_table的属性，示例代码如下： class Author(models.Model): username = models.CharField(max_length=100,null=True)#默认不能为空 age = models.IntegerField(null = True) #db_column='author_age'加入这个参数，就会将数据表中的age改变为author_age #在类里面进行定义Meta类 Rename table for author to author class Meta: db_table = 'author' db_table 这个模型映射到数据库中的表明，如果没有指定这个参数，那么在映射的时候会将使用模型名来作为默认的表名。 ordering 设置在提取数据的排序方式，后面章节会讲到如何查找数据，比如我想在查找数据的时候根据添加的时间排序，那么代码如下： class Author(models.Model): username = models.CharField(max_length=100,null=True)#默认不能为空 age = models.IntegerField(null = True) #db_column='author_age'加入这个参数，就会将数据表中的age改变为author_age #在类里面进行定义Meta类 Rename table for author to author def __str__(self): return \"\" %(self.id,self.create_time) class Meta: db_table = 'author' ordering = ['pub_date','id']#可以多个参数 #如果变为 -pub_date,前面加负号就表示反向了 #先按照第一个参数排序在按照后面的参数 def order_view(request): authors = Author.objects.all() for author in authors: # print(author) return HttpResponse('success') Meta类定义在数据表的类中： class Meta: ​ pass "},"django/django打造大型企业/第四章：数据库/009外链和表关系.html":{"url":"django/django打造大型企业/第四章：数据库/009外链和表关系.html","title":"009外链和表关系","keywords":"","body":"外链和表关系 外键 在Mysql中，表有两种引擎，一种是InnoDB，另外一种是myisam。如果使用的是InnoDB引擎，是支持外键约束的，外键的存在使得ORM框架在处理表关系的时候异常的强大，因此这里我们首先来介绍下外键在Django中使用。 类定义为class ForeignKey(to,on_delete,**options)第一个参数是引用的是哪个模型，第二个参数是在使用外键引用的模型数据被删除了，这个字段该如何处理，比如有CASCADE、SET_NULL等。这里以一个实际案例来说明，比如有一个User和一个Article两个模型。一个User可以发表多篇文章，一个Article只能由一个Author并且通过外键进行引用，那么相关的示例代码如下： class User(models.Model): username = models.CharField(max_length = 20) password = models.CharField(max_length = 100) class Article(models.Model): title = models.CharField(max_length = 100) content = models.TextField() author = models.ForeignKey(\"user\",on_delete=models.CASCADE) 以上使用ForeignKey来定义模型之间的关系，即在article的实例中可以通过author属性来操作对应的User模型。这样使用起来非常的方便，代码如下： #models.py from django.db import models # Create your models here. class Category(models.Model): name = models.CharField(max_length=100) class Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() category = models.ForeignKey(\"Category\",on_delete=models.CASCADE) #cascade表示的是级别删除的意思 ForeignKey 表示外键 author = models.ForeignKey(\"frontuser.FrontUser\",on_delete=models.CASCADE,null = True) #外键在其他app中 app.模型的名字 #category: id ,name #1,最新 #article #id,title,category #1,xxx,1 #views.py from django.shortcuts import render from .models import Category,Article from django.http import HttpResponse # Create your views here. def index(request): category = Category(name='最新文章') category.save() article = Article(title='abc',content='123') article.category = category article.save() return HttpResponse('success') #article/urls.py from django.urls import path from . import views app_name = 'article' urlpatterns = [ path('',views.index,name='index'), ] #demo/urls.py from django.urls import path,include urlpatterns = [ path('',include('article.urls')), ] article = Article.objects.first() print(article.category.name) #article表的category表的名字，category做了外键 return HttpResponse('success') 如果模型的外键引用的是本身自己这个模型，那么to参数可以为self，或者是这个模型的名字，在论坛开发中，一般评论都可以进行二级评论，即可以针对另外一个评论进行评论，那么在定义模型的时候就需要使用外键来引用自身。代码如下： class Comment(models.Model): content = models.TextField() origin_comment = models.ForeignKey('self',on_delete=models.CASCADE) 外键删除操作： 如果一个模型使用了外链，那么在对方哪个模型被删掉后，该进行什么样的操作。可以通过on_delete来指定，乐意指定的类型如下： 1、CASCADE：级联操作，如果外链对应的那条数据被删除了，那么这条数据会被删除。 2、PROTECT：受保护。即只要这条数据引用了外键的那条数据，那么既不能删除外链的那条数据。 3、SET_NULL：设置为空，如果外链的那条数据被删除了，那么本条数据上就将这个字段设置为默认值。如果设置这个选项，前提是要指定这个字段可以为空。null = True 4、SET_DEFAULT:设置默认值，如果外链的那条数据被删除了，那么本条数据上就将这个字段设置为默认值，如果设置这个选项，前提是要指定这个字段一个默认值。on_delete = models.SET_DEFAULT,default =Category.objects.get(pk=4)使用id为4的默认值。 5、SET()：如果外键的那条数据被删除了，那么将会获取SET函数中的值来作为这个外键的值，SET函数可以接受一个可以调用的对象（比如函数或者方法），如果可以条用的对象，那么会将这个对象调用后的结果作为值返回回去。on_delete = models.SET(Category.objects.get(pk=4)) 6、DO_NOTHING：不采用任何行为，一切全看数据库级别的约束。 on_delete = models.DO_NOTHING sql的级别操作！ #models.py class Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() category = models.ForeignKey(\"Category\",on_delete=models.CASCADE) #cascade表示的是级别删除的意思 ForeignKey 表示外键 author = models.ForeignKey(\"frontuser.FrontUser\",on_delete=models.CASCADE,null = True) #测试时候的def方法 def delete_view(request): category = Category.objects.get(pk = 1)#删除主键为1的数据 category.delete()#执行删除 return HttpResponse('delete success') 以上这个选项只是Django级别的，数据级别依旧是RESTRICT! django数据库层面 Foreign外键，可以查阅资料了解更多 表关系： 表之间的关系都是通过外键来进行关联的，而表之间的关系，无非就是三种关系：一对一、一对多（多对一）、多对多等。以下将讨论以下三种关系的应用场景及其实现方式。 一对多： 1、应用场景：比如文章和作者之间的关系。一个文章只能由一个作者编写，但是一个作者可以写多篇文章，文章和作者之间的关系就是典型的多对一的关系。 2、实现方式：一对多或者多对一，都是通过ForeignKey来实现的，还是以文章和作者的案例进行讲解。 class User(models.Model): username = models.CharField(max_length = 20) password = models.CharField(max_length = 100) class Article(models.Model): title = models.CharField(max_length = 100) content = models.TextField() author = models.ForeignKey(\"User\",on_delete = models.CASCADE) 那么以后在给Article对象指定author，就可以使用以下代码来完成： article = Article(title = 'abc',content = '123') author = User(username = 'zhiliao',password = '111111') #要先保存到数据库中 auhtor.save() article.author = author article.save() 并且以后如果想要获取某个用户下所有的文章，可以通过article_set来实现，示例代码如下： user = User.objects.first() #获取第一个用户写的所有文章 artilcles = user.article_set.all() for article in articels: print(article) def one_to_many_view(request): article = Article(title= '钢铁是怎样炼成的',content='abc') category = Category.objects.first() author = FrontUser.objects.first() #获取第一条数据 article.category = category article.author = author article.save() return HttpResponse('yes') #数据表如下图 #文章查找 # 2、获取分类下的所有文章 category = Category.objects.first()#获取分类的第一条数据 #RelatedManager #article = category.article_set.first()#获取所以的文章，也可.all() articles = category.article_set.all()#获取所以的文章，也可.all() #因为使用了外键就会生成category.article_set属性 for article in articles: print(article) return HttpResponse('success') 一对一 1、应用场景：比如一个用户表和一个用户信息表。在实际网站中，可能需要保存用户的许多信息，但是有些信息是不经常用的。如果把所有信息都存放到一张表中可能会影响查询效率，因此可以把用户的一些不常用的信息存放到另外一张表中我们叫做UserExtension。但是用户表User和用户信息表UserExtension就是典型的一对一了。 2、实现方式：Django为一对一提供了一个专门的Field叫做OneToOneField来实现一对一操作。示例代码如下： class User(models.Model): username = models.CharField(max_length=20) password = models.CharField(max_length=100) class UserExtension(models.Model): birthday = models.DateTimeField(null=True) school = models.CharField(blank=True,max_length=50) user = models.OneToOneField(\"User\", on_delete=models.CASCADE) 在UserExtension模型上增加了一个一对一的关系映射。其实底层是在UserExtension这个表上增加了一个user_id，来和user表进行关联，并且这个外键数据在表中必须是唯一的，来保证一对一。 一对一： 在Django中一对一是通过models.OneToOneField来实现的，这个OneToOneField其实本质上就是一个外链，只不过这个外键有一个唯一约束(unique key)来实现一对一 2.以后如果想要反向引用，那么是通过引用的模型的名字转换为小写的形式进行访问，比如以下模型： from django.db import models # Create your models here. class FrontUser (models.Model): username = models.CharField(max_length=100) def __str__(self): return \"\"%(self.id,self.school,self.user_id) # views.py def one_to_one_view(request): # user = FrontUser.objects.first() # #print(user.id,user.username)#1 李白 # extension = UserExtension(school ='清华') # extension.user = user # extension.save() #extension = UserExtension.objects.first() #print(extension.user)# UserExtension的对象可以通过user来访问到对应的user对象，并且FrontUser对象可以使用Userextension来访问对应的UserExtension对象.如果不想使用Django默认的引用属性名字，那么可以在OneToOneField中添加一个related_name参数。示例代码如下： #OneToOneField 就相当于外键的作用 user = models.OneToOneField(\"FrontUser\",on_delete=models.CASCADE,related_name='extension') #因为定义了onetoone索引用户只能是一个 def __str__(self): return \"\"%(self.id,self.school,self.user_id) #views.py #在models中定义了related_name= 'extension' print(user.extension)#此时userextension将会报错 那么以后就FrontUser的对象就可以通过Extension属性来访问到对应的UserExtension对象。 多对多： 1、应用场景：比如文章和标签的关系。一篇文章可以有多个标签，一个标签可以被多个文章所引用。因此标签和文章的关系是典型的多对多的关系。 2、实现方式：Django为这种多对多的实现提供了专门的Field。叫做ManyToManyField。还是拿文章和标签为例进行讲解。示例代码如下： class Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() tags = models.ManyToManyField(\"Tag\",related_name=\"articles\") class Tag(models.Model): name = models.CharField(max_length=50) #views.py def many_to_many_view(request): article = Article.objects.first() tag = Tag(name='冷门文章') tag.save() article.tag_set.add(tag) tag = Tag.objects.get(pk=1) article = Article.objects.get(pk=11) tag.article.add(article) #tag里加文章 article = Article.objects.get(pk=11) tags = article.tags.all() for tag in tags: print(tag) return HttpResponse('sucess') 在数据库层面，实际上Django是为这种多对多的关系建立了一个中间表。这个中间表分别定义了两个外键，引用到article和tag两张表的主键。 多对多add属性没有 bulk参数 related_name 和related_query_name: related_name: category = models.ForeignKey(\"Category\",on_delete=models.CASCADE,null = True,related_name='articles') #因为使用了外键就会生成category.article_set属性 #views.py #在models加入related_name ='articles' article_set属性将会失效使用下面的代码 articles = category.articles.all() article = Article(title='aaa',content='123') article.author = FrontUser.objects.first() article.save() category.articles.add(article) category.save() articles = category.articles.all() #查询category_id 为2的所有数据 for article in articles: print(article) 如果想要将文章添加到某个分类中，可以使用以下方式： category = Category.objects.first() article =Article(title = 'bbb',content = 'ccc') article.author = FrontUser.objects.first() category.article_set.add(article,bulk = Flase) #bulk为false就表示自动保存，否则需要自己提前保存 使用bulk = False,那么Django会自动的保存article，而不需要在添加到category之前先保存article 或者是另外一种解决方式是，在添加category_article_set中之前，先将article保存到数据库中，但是如果article_category不能为空，那么就产生一种死循环了，article没有category不能保存，而将article添加到category.article_set中，又需要article之前是已经存在存储到数据库中的。 "},"django/django打造大型企业/第四章：数据库/010ORM查询条件.html":{"url":"django/django打造大型企业/第四章：数据库/010ORM查询条件.html","title":"010ORM查询条件","keywords":"","body":"查询操作 查找是数据库操作中一个非常重要的技术。查询一般就是使用filter、exculde以及get三个方法来实现，我们可以在调用这些方法的时候传递不同的参数来实现查询需求。在ORM层面，这些查询条件都是使用field+__+condition的方式来使用的。以下将那些常用的查询条件来--解释。 #创建数据库 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'orm_lookup_demo', 'HOST':'127.0.0.1', 'PORT':'3306', 'USER':'root', 'PASSWORD':'123456', } } #app需要在installed_app中添加 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'front' ] #在models.py中生成数据模型 from django.db import models class Article(models.Model): title = models.CharField(max_length=200) content = models.TextField() class Meta: db_table = 'article' #如果没有这个类 则生成 front_article数据表 # 有Meta这个类就会生成 article这个名字的表 #执行以下脚本 # python manage.py makemigrations # python manage.py migrate 就会生成 pycharm连接数据库出错 Server returns invalid timezone. Go to 'Advanced' tab and set 'serverTimezone'解决办法如下： 时区错误，MySQL默认的时区是UTC时区，比北京时间晚8个小时。 所以要修改mysql的时长 在mysql的命令模式下，输入： set global time_zone='+8:00'; ##提示错误 点击左边MYSQL https://dev.mysql.com/downloads/connector/j/ 下载 mysql-connector-java-5.1.46的文件 将刚下载好的文件bin.jar结尾的 JDBC.driver就会出现跳出选择框。 在pycharm中添加数据后：Ctrl+Enter 查询条件 exact: 精确的提供条件。如果提供的是一个None，那么在SQL层面就是被解释为NULL，示例代码如下： article = Article.objects.get(id__exact = 14) article = Article.objects.get(id__exact = None) article = Article.objects.filter(id__exact=1) # __exact这个写不写其实是无所谓的 print(article.query)#输出Query语句 #SELECT `article`.`id`, `article`.`title`, `article`.`content` FROM `article` WHERE `article`.`id` = 1 article1 = Article.objects.filter(title__exact='Helloworld') print(article1.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content` FROM `article` WHERE `article`.`title` = helloworld article2 = Article.objects.filter(title__exact=None) print(article2.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content` FROM `article` WHERE `article`.`title` IS NULL 以上的两个查找在翻译为SQL语句为如下： select...from article where id = 14; select...from article where id IS NULL; utf8-bin大小写敏感，utf8-ggeneral_ci大小写不敏感 相对于mysql的 iexact: 使用like进行查找，示例代码如下： article =Article.objects.filter(title__iexact='helloworld') 那么以上的查询就等价于以下的SQL语句： select ... from article where title like 'hello world'; 注意上面这个sql语句，因为mysql中，没有一个叫做ilike的，所有exact和iexact的区别实际上就是LIKE和=的区别，在大部分collation=utf8_general_ci情况下都是一样的(collation是用来对字符串比较的)。 article3 = Article.objects.filter(title__iexact='helloworld') print(article3.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content` FROM `article` WHERE `article`.`title` LIKE helloworld #因为helloworld 前后没有% 所以是精确的查找 exact与iexact他们的区别其实就是LIKE和=的区别，因为exact会被翻译成=，而iexact会被翻译成LIKE。 QuerySet.query:query可以用来查看这个ORM查询语句最终被翻译成SqL语句，但是query只能被用在QuerySet对象上，不能用在普通的ORM模型上，因此如果你的查询语句是通过get来获取数据的，那么就不能使用query，因为get返回的是满足条件的ORM模型，而不是QuerySet。如果你是通过filter等其他返回QuerySet的方法查询的，那么就可以使用Query。 cotains： 大小写敏感，判断某个字段是否包含了某个数据。示例代码如下： articles = Article.objects.filter(title__contains='hello') article = Article.objects.filter(title__contains='hello world') print(article.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content` FROM `article` WHERE `article`.`title` LIKE BINARY %hello world% # LIKE BINARY 表示大小写敏感 print(article) #>]> 在翻译成SQL语句为如下： select ... where title like binary '%hello%' 要注意的是，在使用contains的时候，翻译成的sql语句左右两边是有百分号的，意味着使用的是模糊查询，而exact翻译成sql语句左右两边是没有百分号的，意味着使用的是精确查询。 icontains 大小写不敏感的匹配查询。示例代码如下： article = Article.objects.filter(title__icontains='hello') article1 = Article.objects.filter(title__icontains='Hello') print(article1.query) # SELECT `article`.`id`, `article`.`title`, `article`.`content` FROM `article` WHERE `article`.`title` LIKE %Hello% print(article1) #>]> 在翻译成SQL语句为如下： `article`.`content` FROM `article` WHERE `article`.`title` LIKE %Hello% icontains中的i表示ignore忽略大小写 %Hello% % 表示 前面可以出现任意字符，后面也表示可以出现任意字符 contains和icontains:在被翻译成SQL的时候使用的是%hello%，就是只要整个字符串中出现了hello都能够被找到，而iexact没有百分号，那么意味着只有完全相等的时候才会被匹配到。 in： 提取那些给定的field的值是否在给定的容器中，容器可以为list、tuple或者任何一个可以迭代的对象，包括QuerySet对象：示例代码如下： article = Article.objects.filter(id__in=[1,2,3]) articles = Article.objects.filter(id__in=[1,2,3]) for article in articles: print(article) ''' ''' return HttpResponse('success') 以上代码在翻译成SQL语句为如下: select ... where id in (1,2,3) 当然也可以传递一个QuerySet对象进去，示例代码如下： inner_qs = Article.objects.filter(title__contains = 'hello') categories = Category.objects.filter(article__in=inner_qs) categories=Category.objects.filter(article__id__in=[1,2,3]) #[1,2,3] 可以为列表也可以是元组或者queryset #如果写成article__in也表示article__id__in print(categories.query) #SELECT `category`.`id`, `category`.`name` FROM `category` INNER JOIN `article` ON (`category`.`id` = `article`.`category_id`) WHERE `article`.`id` IN (1, 2, 3) for category in categories: print(category) #Category object (1) #Category object (1) #Category object (2) 如果要判断相关联的表的字段，那么也是通过__来连接。并且在做反向引用的时候，不需要写models_set直接使用模型的名字的小写化就可以了。比如通过分类去查找相应的文章，那么通过article__id__in就可以了，而不是写成article_set__id__in的形式。 当然，如果你不想使用默认的形式，可以在外键定义的时候传递related_query_name来指定反向引用的名字，示例代码如下： class Category(models.Model): name = models.CharField(max_length=100) class Meta: db_table = 'category' class Article(models.Model): title = models.CharField(max_length=200) content = models.TextField() category =models.ForeignKey(\"Category\",on_delete=models.CASCADE,null=True,related_query_name='articles') def __str__(self): return\"\"%(self.title,self.content) class Meta: db_table = 'article' 因为在category的ForeignKey中制定了related_query_name为articles，因此你不能使用article来进行反向查询了，这时候就需要通过article__id__in来进行反向查询。 并且，如果在做反向查询的时候，如果查询的字段就是模型的主键，那么可以省略掉这个字段，直接写成article__in就可以了，不需要这个id了。 以上代码的意思是获取那些文章标题包含hello的所有分类。 将翻译成以下SQL语句，示例代码如下： select ... from category where article.id in (select id from article where title like '%hello%') articles1 = Article.objects.filter(title__icontains='hello') categories1 = Category.objects.filter(articles__in=articles1) print(categories1.query) #SELECT `category`.`id`, `category`.`name` FROM `category` INNER JOIN `article` ON (`category`.`id` = `article`.`category_id`) WHERE `article`.`id` IN (SELECT U0.`id` FROM `article` U0 WHERE U0.`title` LIKE %hello%) for category in categories1: print(category) #Category object (2) in不仅仅可以指定列表/元组，还可以为QuerySet，比如要查询标题中含有hello的虽有分类可以通过以下代码来实现它： articles1 = Article.objects.filter(title__icontains='hello') categories1 = Category.objects.filter(articles__in=articles1) print(categories1.query) #SELECT `category`.`id`, `category`.`name` FROM `category` INNER JOIN `article` ON (`category`.`id` = `article`.`category_id`) WHERE `article`.`id` IN (SELECT U0.`id` FROM `article` U0 WHERE U0.`title` LIKE %hello%) for category in categories1: print(category) #Category object (2) #注意理解 文章反向查询 #反向查询是讲模型名字小写化，比如'article__in',可以通过’related_query_name'来指定自己的方式，而不使用默认的方式。 #反向引用是讲模型名字小写化，然后再加上'_set',比如`article_set`,可以通过'related_name'来指定自己的方式，而不是用默认的方式。 gt gte lt lte: 某个field的值要大于给定的值，示例代码如下： #查找id大于2的所有文章 #gt: greater than 大于 articles = Article.objects.filter(id__gt=2) print(articles) print(articles.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id` FROM `article` WHERE `article`.`id` > 2 #gte:greater than equal 大于等于 articles1 = Article.objects.filter(id__gte=2) print(articles1) print(articles1.query) # lt:lower than 小于 articles2 = Article.objects.filter(id__lt=2) print(articles2) print(articles2.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id` FROM `article` WHERE `article`.`id` startwith: 判断某个字段的值是否以某个值开始的，大小写敏感。示例代码如下： articles = Article.objects.filter(title__startwith = 'hello') 以上代码的意思是提取所有标题以hello字符串开头的文章。 将翻译成以下SQL语句： select ... where title like 'hello%' istartwith: 类似于startwith，但是大小写是不敏感的。 endswith： 判断某个字段的值是否以某个值结束，大小写敏感；示例代码如下： articles = Article.objects.filter(title__endstartwith='world') 以上代码的意思是提取所有标题以world字符串结尾的文章。 将翻译成以下SQL语句： select ... where title like '%world' iendswith #startswith 以什么开头，对大小写敏感 article = Article.objects.filter(title__startswith='hello') print(article) print(article.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id` FROM `article` WHERE `article`.`title` LIKE BINARY hello% # istartswith 以什么开头，对大小写不敏感 i ignore忽略 article1 = Article.objects.filter(title__istartswith='Hello') print(article1) print(article1.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id` FROM `article` WHERE `article`.`title` LIKE Hello% #endswith：以什么结尾，对大小写敏感 article2 = Article.objects.filter(title__endswith='world') print(article2) print(article2.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id` FROM `article` WHERE `article`.`title` LIKE BINARY %world #iendswith：以什么结尾，对大小不敏感 i ignore忽略 article3 = Article.objects.filter(title__iendswith='woRld') print(article3) print(article3.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id` FROM `article` WHERE `article`.`title` LIKE %woRld 时间的过滤条件 range 判断某个field的值是否在给定的区间中，示例代码如下： from django.utils.timezone import make_aware from datetime import datetime 建议开启USE_TE = True TIME_ZONE = 'Asia/Shanghai' range: 可以指定一个时间段，并且时间应该标记为aware时间，不然Django会报警告。示例代码如下： from datetime import datetime from django.utils.timezone import make_aware def index6(request): start_time = make_aware(datetime(year=2020,month=4,day=11,hour=5,minute=0,second=0)) #end_time = datetime(year=2020,month=4,day=11,hour=17,minute=52,second=0) end_time = make_aware(datetime(year=2020,month=4,day=11,hour=17,minute=52,second=0)) articles =Article.objects.filter(create_time__range=(start_time,end_time)) print(articles.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE `article`.`create_time` BETWEEN 2020-04-10 21:00:00 AND 2020-04-11 09:52:00 print(articles) #>]>返回数据 return HttpResponse('index6') date 用年月日来进行过滤，如果想要使用这个过滤条件，那么前提必须要在MYSQL中添加好那些时区文件，如何添加呢？下面有介绍。 https://dev.mysql.com/downloads/timezones.html网址下载`[timezone_2019c_posix.zip](https://downloads.mysql.com/general/timezone_2019c_posix.zip)`文件，将里面的文件替换data下mysql C:\\ProgramData\\MySQL\\MySQL Server 5.7\\Data\\mysql里面的文件，注意备份原mysql里面文件。 def index7(request): articles = Article.objects.filter(create_time__date=datetime(year=2020,month=4,day=11)) print(articles.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE DATE(CONVERT_TZ(`article`.`create_time`, 'UTC', 'Asia/Shanghai')) = 2020-04-10 print(articles) return HttpResponse('index7') 针对某些date或者datetime类型的字段，可以指定date的范围，并且这个时间过滤，还可以使用链式调用。示例代码如下： def index7(request): articles = Article.objects.filter(create_time__date=datetime(year=2020,month=4,day=11)) print(articles.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE DATE(CONVERT_TZ(`article`.`create_time`, 'UTC', 'Asia/Shanghai')) = 2020-04-11 print(articles) return HttpResponse('index7') 以上代码的意思是查找时间为2010/4/11这一天发表的所有文章。SQL语句如下： SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE DATE(CONVERT_TZ(`article`.`create_time`, 'UTC', 'Asia/Shanghai')) = 2020-04-11 注意，因为默认情况下MySQL的表中是没有存储时区相关的信息的，因此我们需要下载一些时区表的文件，然后添加到mysql的配置路径中，如果你用的是windows操作系统，那么在http://dev.mysql.com/downloads/timezones.html下载`timezone_2019c_posix.zip`，然后将下载下来的所有文件拷贝到`C:\\ProgramData\\MySQL\\MySQL Server 5.7\\Data\\mysql`中，如果提示文件名重复，那么选择覆盖即可。 如果用的是linux或者mac系统，那么在命令行中执行以下命令：mysql_tzinfo_to_sql /user/share/zoneinfo | mysql -D mysql -u root -p，然后输入密码，从系统中加载时区文件更新到mysql中。 year 根据年份进行查找，示例代码如下： articles = Article.objects.filter(create_time__date=datetime(year=2020,month=4,day=11)) print(articles.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE DATE(CONVERT_TZ(`article`.`create_time`, 'UTC', 'Asia/Shanghai')) = 2020-04-10 print(articles) articles1 = Article.objects.filter(create_time__year=2020) #articles1 = Article.objects.filter(create_time__year__gte=2020) #gte表示大于等于2020年的都可以 #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE `article`.`create_time` BETWEEN 2019-12-31 16:00:00 AND 2020-12-31 15:59:59.999999 print(articles1.query) print(articles1) month: 同year，根据月份进行查找。 day： 同year，根据日期进行查找 week_day： Django 1.11新增的查找方式，同year根据星期几进行查找，1表示的是星期天，7表示星期六，2-6代表的是星期一到星期五。 articles2 = Article.objects.filter(create_time__week_day=7) print(articles2.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE DAYOFWEEK(CONVERT_TZ(`article`.`create_time`, 'UTC', 'Asia/Shanghai')) = 7 print(articles2) #>, >, >, >]> time 因为秒数后面有小数，所以就要用区间。 start_time = time(hour=21,minute=46,second=21) end_time = time(hour=21,minute=46,second=22) articles3 = Article.objects.filter(create_time__time__range=(start_time,end_time)) print(articles3.query) print(articles3) isnull: 根据值是否为空进行查找，示例代码如下： articles = Article.objects.filter(pub_date__isnull = False) articles = Article.objects.filter(create_time__isnull=False)#True #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE `article`.`create_time` IS NULL print(articles.query) print(articles) return HttpResponse('index8') 以上的代码的意思是获取所有发布日期不为空的文章。 将来翻译成SQL语句如下： select ... where pub_date is not null; regex和iregex: 大小写敏感和大小写不敏感的正则表达式。示例代码如下： articles = Article.objects.filter(title__regex=r'^hello') articles1 = Article.objects.filter(title__regex=r'^hello') #大小写区分 print(articles1.query) #SELECT `article`.`id`, `article`.`title`, `article`.`content`, `article`.`category_id`, `article`.`create_time` FROM `article` WHERE `article`.`title` REGEXP BINARY ^hello print(articles1) 以上代码的意思是提取所有标题以hello字符串开头的文章，将翻译成以下的SQL语句： select ... where title regex binary '^hello'; iregex是大小写不敏感的。 根据关联的表进行查询： 假如现在有两个ORM模型，一个是Article，一个是Category代码如下： class Category(models.Model): ```文章分类 name = models.CharField(max_length = 100) class Article(models.Model): ```文章表``` title = models.CharField(max_length=100,null= True) category = models.ForeignKey(\"Category\",on_delete=models.CASCADE) 比如想要获取文章标题中包含'hello'的所有分类，那么可以通过以下代码来实现： ```python category = Category.objects.filter(article__title__contains(\"hello\")) "},"django/django打造大型企业/第四章：数据库/011ORM聚合函数.html":{"url":"django/django打造大型企业/第四章：数据库/011ORM聚合函数.html","title":"011ORM聚合函数","keywords":"","body":"聚合函数 配置数据库 创建APP 如果你用原生SQL，则可以使用聚合函数来提取数据，比如提取某个商品销售的数量，那么可以使用Count，如果想要知道商品的销售的平均价格，那么可以使用Avg. 聚合函数是通过aggregate方法来实现的。在讲解这些聚合函数用法的时候，都是基于以下的模型对象来实现的。 #models.py from django.db import models class Author(models.Model): '''作者模型''' name = models.CharField(max_length=100) age = models.IntegerField() email = models.EmailField() class Meta: db_table = 'author' class Publisher(models.Model): '''出版社模型''' name = models.CharField(max_length=300) class Meta: db_table = 'publisher' class Book(models.Model): '''图书模型''' name = models.CharField(max_length=300) pages = models.IntegerField() price = models.FloatField() rating = models.FloatField() author = models.ForeignKey(Author,on_delete=models.CASCADE) publisher = models.ForeignKey(Publisher,on_delete=models.CASCADE) class Meta: db_table = 'book' class BookOrder(models.Model): '''图书订单模型''' book = models.ForeignKey(\"Book\",on_delete=models.CASCADE) price = models.FloatField() class Meta: db_table = 'book_order' 1、Avg：求平均值。比如想要获取所有图书的价格平均值，那么可以使用以下代码实现。 from django.db.models import Avg result = Book.objects.aggregate(Avg('price')) print(result) 以上的打印结果是： {\"price__avg\":23} 1、所有的聚合函数都是放在'django.db,models'下面。 2、聚合函数不能够单独的执行，需要放在一些可以执行聚合函数的方法下面去执行。比如aggregate示例代码如下： def index(request): #获取所有图书定价的平均价格 #result = Book.objects.aggregate(Avg(\"price\")) result = Book.objects.aggregate(price_avg = Avg(\"price\")) #price_avg 交做它的别名 print(result)#result 是一个字典类型 #{'price_avg': 97.25} #字典调用方法 如下： print(result['price_avg']) print(connection.queries) #[{'sql': 'SELECT @@SQL_AUTO_IS_NULL', 'time': '0.000'}, {'sql': 'SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED', 'time': '0.000'}, {'sql': 'SELECT AVG(`book`.`price`) AS `price__avg` FROM `book`', 'time': '0.000'}] #django在执行sql语句的时候执行了其他的语句 return HttpResponse('success') 3、聚合函数执行完成后，给这个聚合函数的值个名字，取名字的规则，默认是filed+__+聚合函数名字形成的。比如以上代码形成的名字叫做price_avg。如果不想使用默认的名字，那么可以在使用聚合函数的时候传递关键字参数进去，参数的名字就是聚合函数执行完成的名字。示例代码如下： result = Book.objects.aggregate(price_avg = Avg(\"price\")) 以上传递了关键字参数price_avg = Avg('price')，那么以后Avg聚合函数执行完成的名字就叫做Avg 4、aggregate这个方法不会返回一个QuerySet对象，而是返回一个字典。这个字典中的key就是聚合函数的名字，值就是聚合函数执行后的结果。 aggregate和annotate的区别： def index2(request): #我要获取每一本图书销售的平均价格 #result = Book.objects.aggregate(avg=Avg('bookorder__price')) #print(result)#{'avg': 91.0} #print(connection.queries) #[{'sql': 'SELECT @@SQL_AUTO_IS_NULL', 'time': '0.000'}, {'sql': 'SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED', 'time': '0.000'}, {'sql': 'SELECT AVG(`book_order`.`price`) AS `avg` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`)', 'time': '0.000'}] books = Book.objects.annotate(avg=Avg('bookorder__price')) print(books) #, , , ]> print('+'*40) for book in books: print('%s/%s' % (book.name,book.avg)) ''' 三国演义/89.33333333333333 水浒传/93.5 西游记/None 红楼梦/None ''' print(connection.queries) #{'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, AVG(`book_order`.`price`) AS `avg` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY NULL LIMIT 21' # {'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, AVG(`book_order`.`price`) AS `avg` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY NULL' return HttpResponse('index2') aggregate和annotate的相同和不同： 相同：这两个方法都可以执行聚合函数。 不同： aggregate 返回的是一个字典，在这个字典中存储的是这个聚合函数执行的结果，而annotate返回的是一个QuerySet 对象，并且会在查找的模型上添加一个聚合函数的属性。 aggregate不会做分组，而annotate会使用group by子句进行分组，只有调用了group by子句，才能对每一条数据求聚合函数的值。 Count：用来求某个数据的个数，比如要求所有图书的数量，那么可以使用以下代码： #book表中总共有多少本书，（book表中总共有多少个书） result = Book.objects.aggregate(book_nums=Count('id',distinct=True)) #distinct=True 表示不统计重复的值 print(result) #{'book_nums': 4} print(connection.queries) #[ {'sql': 'SELECT COUNT(`book`.`id`) AS `book_nums` FROM `book`', 'time': '0.031'}] result1 = Author.objects.aggregate(email_nums = Count('email',distinct=True)) #'SELECT COUNT(DISTINCT `book`.`id`) AS `book_nums` FROM `book`', 'time': '0.000'}, {'sql': 'SELECT COUNT(DISTINCT `author`.`email`) AS `email_nums` FROM `author`', 'time': '0.000'} print(result1) print(connection.queries) 并且Count可以传递distinct=True参数，用来剔除那些重复的值，只保留一个。 比如要获取作者表中，不同邮箱的个数，那么这时候可以使用distinct=True。 示例代码如下： result1 = Author.objects.aggregate(email_nums = Count('email',distinct=True)) #'SELECT COUNT(DISTINCT `book`.`id`) AS `book_nums` FROM `book`', 'time': '0.000'}, {'sql': 'SELECT COUNT(DISTINCT `author`.`email`) AS `email_nums` FROM `author`', 'time': '0.00'} #===annotate 先分组 #统计每本书的销量 books = Book.objects.annotate(book_nums=Count('bookorder'))#默认bookorder__id for book in books: print('%s/%s'% (book.name,book.book_nums)) ''' 三国演义/3 水浒传/2 西游记/0 红楼梦/0 ''' print(connection.queries) #{'sql': 'SELECT COUNT(DISTINCT `author`.`email`) AS `email_nums` FROM `author`', 'time': '0.000'}, {'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, COUNT(`book_order`.`id`) AS `book_nums` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY NULL'}] 3、Max和Min：获取指定对象的最大值和最小值。比如想要获取Author表中，最大的年龄和最小的年龄分别是多少，那么可以通过以下代码来实现： from django db.models import Max,Min result = Author.objects.aggregate(Max('age'),Min('age')) 如果最大的年龄是88最小的年龄是18，那么以上的result将为： {'age__max':88,'age__min':18} result = Author.objects.aggregate(max=Max('age'),min = Min('age')) print(result) #{'max': 46, 'min': 28} print(connection.queries) #'sql': 'SELECT MAX(`author`.`age`) AS `max`, MIN(`author`.`age`) AS `min` FROM `author` #获取每一本图书售卖的时候最大的价格和最小的价格 books = Book.objects.annotate(max=Max('bookorder__price'),min =Min('bookorder__price')) for book in books: print('%s/%s/%s'%(book.name,book.max,book.min)) ''' 三国演义/95.0/85.0 水浒传/94.0/93.0 西游记/None/None 红楼梦/None/None ''' print(connection.queries) #'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, MAX(`book_order`.`price`) AS `max`, MIN(`book_order`.`price`) AS `min` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY NULL' 4、Sum：求指定对象的总和。比如要求图书的销售总额，那么可以使用以下代码实现：`` from django db.models import Sum result = Book.objects.annotate(total=Sum(\"bookstore__price\")).values('name','total') def index5(request): #1.求所有图书的销售总额 result = BookOrder.objects.aggregate(total=Sum('price')) print(result) #{'total': 455.0} print(connection.queries) #'SELECT SUM(`book_order`.`price`) AS `total` FROM `book_order`' #求每一本书的销售总额 books = Book.objects.annotate(total=Sum(\"bookorder__price\")) for book in books: print(\"%s/%s\"%(book.name,book.total)) ''' 三国演义/268.0 水浒传/187.0 西游记/None 红楼梦/None ''' print(connection.queries) #'sql': 'SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED', 'time': '0.000'}, {'sql': 'SELECT SUM(`book_order`.`price`) AS `total` FROM `book_order`', 'time': '0.016'}, {'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, SUM(`book_order`.`price`) AS `total` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY NULL' #3、求2020年度每一本图书销售总额 result = BookOrder.objects.filter(create_time__year=2020).aggregate(total=Sum('price')) print(result) #{'total': 455.0} print(connection.queries) #'sql': 'SELECT SUM(`book_order`.`price`) AS `total` FROM `book_order`' #'sql': \"SELECT SUM(`book_order`.`price`) AS `total` FROM `book_order` WHERE `book_order`.`create_time` BETWEEN '2020-01-01 00:00:00' AND '2020-12-31 23:59:59.999999'\" #求每一本图书在2020年度销售总额 books = Book.objects.filter(bookorder__create_time__year=2020).annotate(total=Sum(\"bookorder__price\")) for book in books: print('%s/%s' % (book.name, book.total)) ''' 三国演义/268.0 水浒传/187.0 ''' print(connection.queries) #'sql': \"SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, SUM(`book_order`.`price`) AS `total` FROM `book` INNER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) WHERE `book_order`.`create_time` BETWEEN '2020-01-01 00:00:00' AND '2020-12-31 23:59:59.999999' GROUP BY `book`.`id` ORDER BY NULL\" return HttpResponse('index5') aggregate和annotate方法可以在任何的QuerySet对象上调用，因此只要返回了QuerySet兑现，那么就可以进行链式调用，比如要获取2020度销售总额，可以先过滤年份，再求聚合函数，示例代码如上。 "},"django/django打造大型企业/第四章：数据库/012F表达式和Q表达式.html":{"url":"django/django打造大型企业/第四章：数据库/012F表达式和Q表达式.html","title":"012F表达式和Q表达式","keywords":"","body":"F表达式和Q表达式 F表达式 F表达式是用来优化orm曹组偶数据库的，比如我们要将公司所有员工的薪水都增加1000元，如果按照正常的流程，用该是先从数据库中提取所有的员工工资到python内存中，然后使用python内存中做完运算，之后再保存到数据库中。示例代码如下： employees = Employee.objets.all() for employee in employees: employee.salary+=1000 employee.save() 而我们的F表达式就可以优化这个流程，他可以不需要先把数据从数据库中提取出来，让计算完成后再保存回去，他可以直接执行SQL语句，就将员工的工资增加1000元。示例代码如下： from django.db.models import F Employee.object.update(salary=F(\"salary\")+1000) ################################################ #给每一本图书的售价增加10元 Book.objects.update(price=F('price')+10) print(connection.queries[-1]) return HttpResponse('index6') F表达式并不会马上从数据库中获取数据，而是在生成SQL语句的时候，动态的获取传给F表达式的值。 比如如果想要获取作者中，name和email相同的作者数据。如果不适用F表达式，那么需要使用以下代码来完成： authors = Author.objects.all() for author in authors: if author.name == author.email: print(author) 利用F的应用： authors = Author.objects.filter(name=F('email')) for author in authors: print('%s/%s'%(author.name,author.email)) #wce@qq.com/wce@qq.com print(connection.queries[-1]) #{'sql': 'SELECT `author`.`id`, `author`.`name`, `author`.`age`, `author`.`email` FROM `author` WHERE `author`.`name` = `author`.`email`', 'time': '0.016'} Q表达式： 如果想要实现所有价格高于100元，并且评分达到9.0以上评分的图书。那么可以通过以下代码来实现： books =Book.objects.filter(price__get=100,rating__get=9) 以上这个案例是一个并集查询，可以简单的通过传递多个条件进去来实现。 但是如果想要实现一些复杂的查询语句，比如要查询所有价格低于10，或者是评分低于9分的图书。那就没有办法通过传递多个条件进去实现了。这时候需要使用Q表达式来实现了。示例代码如下： from django.db.models import Q books = Book.objects.filter(Q(price__lte=10)|Q(rating__lte=9)) 以上是进行或运算，当然还可以进行其他的运算，比如与&和~等。一些用Q表达式的例子如下： #3.获取价格低于100元或者评分低于4分的图书 books2 = Book.objects.filter(Q(price__lt=127)|Q(rating__lt=4.85)) for book in books2: print(\"%s/%s/%s\" % (book.name, book.price, book.rating)) ''' 三国演义/128.0/4.8 水浒传/127.0/4.83 西游记/125.0/4.85 ''' Q可以做 与 或 非运算！ #4.价格大于100，并且图书名字中不包含'记'字的图书 books = Book.objects.filter(Q(price__gte=100)&~Q(name__icontains='传')) for book in books: print(\"%s/%s/%s\" % (book.name, book.price, book.rating)) #水浒传/127.0/4.83 如果~ 这是 非 ''' 三国演义/128.0/4.8 西游记/125.0/4.85 红楼梦/129.0/4.9 ''' "},"django/django打造大型企业/第四章：数据库/013Query Set API.html":{"url":"django/django打造大型企业/第四章：数据库/013Query Set API.html","title":"013Query_Set_API","keywords":"","body":"Query Set API 我们通常做查询操作的时候，都是通过模型名字.objects的方式进行操作。其实模型名字.objects是一个django.db.models.manager.Manager对象，而manager这个类是一个\"空壳\"的类，他本身没有任何的属性和方法的，他的方法全部都是通过python动态添加的方式，从QuerySet类中拷贝多来的。示例图如下： 以我们如果想要学习ORM模型的查找操作，必须首先要学会QuerySet上的一些API的使用。 返回新的QuerySet的方法： 在使用QuerySet进行查找操作的时候，可以提供多种操作，比如过滤完后还要根据某个字段进行排序，那么这一系列的操作我们可以通过一个非常流畅的链式调用的方法进行。比如要从文章中获取标题为123，并且提取后要将结果根据发布的时间进行排序，那么可以使用以下方式来完成： articles = Article.objects.filter(title='123').order_by('create_time') #可以先进行过滤 books = Book.objects.filter(id__gte=2) books.filter(id !=3) books.filter(~Q(id=3)) #id等于3然后反转 #可以进行两个filter books = Book.objects.filter(id__gte=2).filter(~Q(id=3)) 可以看到order_by方法是直接在filter执行后调用的。这说明filter返回的对象是一个拥有order_by方法的对象。而这个对象正是一个新的QuerySet对象。因此可以使用order_by方法。 那么以下将介绍在那些会返回新的QuerySet对象的方法。 1、filter：将满足条件的数据提取出来，返回一个新的QuerySet。具体的filter可以提供什么条件查询。请见查询操作章节。 2、exclude：排除满足条件的数据，返回一个新的QuerySet。示例代码如下： Article.objects.exclude(title__contains='hello') #排除掉id为3的数据 books =Book.objects.filter(id__gte=2).exclude(id=3) 以上代码的意思是提取那些标题不包含hello的图书。 3、annotate：给QuerySet中的每个对象都添加一个使用查询表达式（聚合函数、F表达式、Q表达式、Func表达式等）的新字段。示例代码如下： articles = Article.objects.annotate(author_name=F(\"author__name\")) #会调用出图书的作者名字，有外键数据表 books = Book.objects.annotate(author_name=F(\"author__name\")) 以上代码将在每个对象中都添加一个author__name的字段，用来显示这个文章的作者的年龄。 4、order_by：指定将查询的结果根据某个字段进行排序。如果要倒叙排序，那么可以在这个字段的前面加一个负号。示例代码如下： # 根据创建的时间正序排序 articles = Article.objects.order_by(\"create_time\") # 根据创建的时间倒序排序，在字段的前面加一个 - 号 articles = Article.objects.order_by(\"-create_time\") # 根据作者的名字进行排序 articles = Article.objects.order_by(\"author__name\") # 首先根据创建的时间进行排序，如果时间相同，则根据作者的名字进行排序 articles = Article.objects.order_by(\"create_time\",'author__name') #================================================================ #根据create_time从小到大进行排序 orders = BookOrder.objects.order_by('price') for order in orders: print('%s/%s'% (order.id,order.price)) ''' 2/85.0 3/88.0 5/93.0 4/94.0 1/95.0 ''' print(connection.queries[-1]) #'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` ORDER BY `book_order`.`price` ASC' orders = BookOrder.objects.order_by('-price')#从大到小排序 for order in orders: print(order.price) ''' 95.0 94.0 93.0 88.0 85.0 ''' print(connection.queries[-1]) #'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` ORDER BY `book_order`.`price` DESC' #首先根据book_id从大到小排序，如果一样那么根据price从大到小进行排序 orders = BookOrder.objects.order_by('-book_id','-price') for order in orders: print(order.book_id,',',order.price) ''' 2 , 94.0 2 , 93.0 1 , 95.0 1 , 88.0 1 , 85.0 ''' #提取图书数据，根据图书的销量进行排序（从大到小进行排序） books = Book.objects.annotate(order_nums=Count('bookorder__id')).order_by('-order_nums') for book in books: print(book.name,book.order_nums) ''' 三国演义 3 水浒传 2 西游记 0 红楼梦 0 ''' print(connection.queries[-1]) #'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id`, COUNT(`book_order`.`id`) AS `order_nums` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY `order_nums` DESC' return HttpResponse('index3') 一定要注意的一点是，多个order_by，会把前面排序的规则给打乱，而使用后面的排序方式。比如以下代码： articles = Article.objects.order_by(\"create_time\").order_by(\"author__name\") 他会根据作者的名字进行排序，而不是使用文章的创建时间。 values：用来指定在提取数据出来，需要提取哪些字段。默认情况下会把表中所有的字段全部都提取出来，可以使用values来进行指定，并且使用了values方法后，提取出的QuerySet中的数据类型不是模型，而是在values方法中指定的字段和值形成的字典： articles = Article.objects.values(\"title\",'content') for article in articles: print(article) books = Book.objects.values('id','name').all() #queryset里面存储的是 字典 for book in books: print(book['id'],book['name']) ''' 1 三国演义 2 水浒传 3 西游记 4 红楼梦 ''' 以上打印出来的article是类似于{\"title\":\"abc\",\"content\":\"xxx\"}的形式。 如果在values中没有传递任何参数，那么将会返回这个恶模型中所有的属性。 values的返回值同样也是一个QuerySet对象，但是返回值是一个字典类型! 如果我们想要提取的是这个模型上关联的对象的属性，那么也是可以的，查找顺序跟filter的用法是一样的。示例代码如下： books = Book.objects.values('id', 'name',author_name = F('author__name')).all() # queryset里面存储的是 字典 # F表达式经常用于动态的查找 for book in books: print(book) ''' {'id': 1, 'name': '三国演义', 'author__name': '罗贯中'} {'id': 2, 'name': '水浒传', 'author__name': '施耐庵'} {'id': 3, 'name': '西游记', 'author__name': '吴承恩'} {'id': 4, 'name': '红楼梦', 'author__name': '曹雪芹'} 利用F表达式后： {'id': 1, 'name': '三国演义', 'author_name': '罗贯中'} {'id': 2, 'name': '水浒传', 'author_name': '施耐庵'} {'id': 3, 'name': '西游记', 'author_name': '吴承恩'} {'id': 4, 'name': '红楼梦', 'author_name': '曹雪芹'} ''' 以上将会提取author的name字段，如果我们不想要这个名字，想要更改这个名字，那么可以使用关键字参数。F表达式取得名字不能与已有字段重复，否则会出错！示例代码如上！ 在values中也是可以使用聚合函数的，代码如下： #使用count聚合函数 books = Book.objects.values('id','name',order_nums=Count('bookorder__id')) for book in books: print(book) ''' {'id': 1, 'name': '三国演义', 'order_nums': 3} {'id': 2, 'name': '水浒传', 'order_nums': 2} {'id': 3, 'name': '西游记', 'order_nums': 0} {'id': 4, 'name': '红楼梦', 'order_nums': 0} ''' print(connection.queries[-1]) #'SELECT `book`.`id`, `book`.`name`, COUNT(`book_order`.`id`) AS `order_nums` FROM `book` LEFT OUTER JOIN `book_order` ON (`book`.`id` = `book_order`.`book_id`) GROUP BY `book`.`id` ORDER BY NULL' values_list：类似于values。只不过返回的QuerySet中，存储的不是字典，而是元组。示例代码如下： articles = Article.objects.values_list(\"id\",\"title\") print(articles) books = Book.objects.values_list() print(type(books)) # for book in books: print(book) '''返回的是元组数据 (1, '三国演义', 987, 98.0, 4.8, 3, 1) (2, '水浒传', 967, 97.0, 4.83, 4, 1) (3, '西游记', 1004, 95.0, 4.85, 2, 2) (4, '红楼梦', 1007, 99.0, 4.9, 1, 2) ''' print('=' * 50) books = Book.objects.values_list('name',flat=True) #只获取到name这个字段 print(type(books)) # for book in books: print(book) '''返回的是元组数据,如果元组只有一个元素，那么后边就会有一个逗号 ('三国演义',) ('水浒传',) ('西游记',) ('红楼梦',) 使用flat=True后的数据，如果有两个字段就会出现错误 三国演义 水浒传 西游记 红楼梦 ''' 那么在打印articles后，结果为`等。 如果在values_list中只有一个字段。那么你可以传递flat=True`来将结果扁平化。示例代码如下： articles1 = Article.objects.values_list(\"title\") >> articles2 = Article.objects.values_list(\"title\",flat=True) >> 看上面的代码 一定要注意的是，flat只能用在只有一个字段的情况下，否则就会报错！ 7、all：获取这个ORM模型的QuerySet对象。all在实际的应用中使用的比较少！ 这个返回简单的返回一个QuerySet对象，这个QuerySet对象没有经过任何的修改（比如：过滤）等。 def index5(request): books = Book.objects.all() for book in books: print(book)#Book object (1)输出的是一个对象 print(book.id,book.name)#这里可以输出数据 4 红楼梦等 return HttpResponse(\"index5\") 8、select_related：在提取某个模型的数据的同时，也提前将相关联的数据提取出来。比如提取文章数据，可以使用select_related将author信息提取出来，以后再次使用article.author的时候就不需要再次去访问数据库了。可以减少数据库查询的次数。示例代码如下： article = Article.objects.get(pk=1) >> article.author # 重新执行一次查询语句 article = Article.objects.select_related(\"author\").get(pk=2) >> article.author # 不需要重新执行查询语句了 def index6(requeset): #books = Book.objects.all()#应该是book关联的author字段中的名字，此时每次都需要查询语句有点浪费资源 books = Book.objects.select_related(\"author\",\"publisher\")#在一次查询中讲author查询出来了,这个地方只能使用外键的字段 for book in books: #print(book.name) print(book.author.name) print(book.publisher.name) ''' 罗贯中 中国邮电出版社 施耐庵 中国邮电出版社 吴承恩 清华大学出版社 曹雪芹 清华大学出版社 ''' print(connection.queries[-1]) #'SELECT `author`.`id`, `author`.`name`, `author`.`age`, `author`.`email` FROM `author` WHERE `author`.`id` = 1 LIMIT 21' selected_related只能用在一对多或者一对一中，不能用在多对多或者多对一中。只能用在外键关联的对象身上。比如可以提前获取文章的作者，但是不能通过作者获取这个作者的文章，或者是通过某篇文章获取这个文章所有的标签。 9、prefetch_related：这个方法和select_related非常的类似，就是在访问多个表中的数据的时候，减少查询的次数。这个方法是为了解决多对一和多对多的关系的查询问题。比如要获取标题中带有hello字符串的文章以及他的所有标签，示例代码如下： from django.db import connection articles = Article.objects.prefetch_related(\"tag_set\").filter(title__contains='hello') print(articles.query) # 通过这条命令查看在底层的SQL语句 for article in articles: print(\"title:\",article.title) print(article.tag_set.all()) # 通过以下代码可以看出以上代码执行的sql语句 for sql in connection.queries: print(sql) def index7(request): # books = Book.objects.all() # for book in books: # print('='*30) # print(book.name) # orders = book.bookorder_set.all()#sql语句查询的次数多了 # #对象.模型类小写_set.all 访问1对多模型 # for order in orders: # print(order.id) # ''' # 三国演义 # 1 # 2 # 3 # ============================== # 水浒传 # 4 # 5 # ============================== # 西游记 # ============================== # 红楼梦 # ''' print('*'*80) # books = Book.objects.prefetch_related(\"bookorder_set\") # #将所有的book查询出来，更具book ID将订单查询出来！做了两次查询 # for book in books: # print('='*30) # print(book.name) # orders = book.bookorder_set.all()#sql语句查询的次数多了 # #对象.模型类小写_set.all 访问1对多模型 # for order in orders: # print(order.id) # #print(connection.queries) # #{'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id` FROM `book`', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE `book_order`.`book_id` IN (1, 2, 3, 4)', 'time': '0.000'} # # books = Book.objects.prefetch_related('author') # for book in books: # print(book.author.name) # ''' # 罗贯中 # 施耐庵 # 吴承恩 # 曹雪芹 # ''' # print(connection.queries) #'SELECT `author`.`id`, `author`.`name`, `author`.`age`, `author`.`email` FROM `author` WHERE `author`.`id` IN (1, 2, 3, 4)' #=========================================================== #过滤价格大于90元的 #传统做法 # books =Book.objects.prefetch_related('bookorder_set') # #如果使用prefetch_related的时候，就不能使用类似filter产生新sql语句的方法 # for book in books: # print('='*50) # print(book.name) # orders = book.bookorder_set.filter(price__gte=90)#因使用filter，所以prefetch_related失效 # for order in orders: # print(order.id) # print(connection.queries) ''' 三国演义 1 ================================================== 水浒传 4 5 ================================================== 西游记 ================================================== 红楼梦 [{'sql': 'SELECT @@SQL_AUTO_IS_NULL', 'time': '0.000'}, {'sql': 'SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED', 'time': '0.000'}, {'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id` FROM `book`', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE `book_order`.`book_id` IN (1, 2, 3, 4)', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE (`book_order`.`book_id` = 1 AND `book_order`.`price` >= 90.0e0)', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE (`book_order`.`book_id` = 2 AND `book_order`.`price` >= 90.0e0)', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE (`book_order`.`book_id` = 3 AND `book_order`.`price` >= 90.0e0)', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE (`book_order`.`book_id` = 4 AND `book_order`.`price` >= 90.0e0)', 'time': '0.000'}] ''' #解决办法，使用Prefetch类 prefetch = Prefetch('bookorder_set',queryset=BookOrder.objects.filter(price__gte=90)) books = Book.objects.prefetch_related(prefetch) for book in books: print('='*50) print(book.name) orders = book.bookorder_set.all() for order in orders: print(order.id) print(connection.queries) #{'sql': 'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id` FROM `book`', 'time': '0.000'}, {'sql': 'SELECT `book_order`.`id`, `book_order`.`price`, `book_order`.`book_id` FROM `book_order` WHERE (`book_order`.`price` >= 90.0e0 AND `book_order`.`book_id` IN (1, 2, 3, 4))', 'time': '0.000'} return HttpResponse('index7') 但是如果在使用article.tag_set的时候，如果又创建了一个新的QuerySet那么会把之前的SQL优化给破坏掉。比如以下代码： tags = Tag.obejcts.prefetch_related(\"articles\") for tag in tags: articles = tag.articles.filter(title__contains='hello') #因为filter方法会重新生成一个QuerySet，因此会破坏掉之前的sql优化 # 通过以下代码，我们可以看到在使用了filter的，他的sql查询会更多，而没有使用filter的，只有两次sql查询 for sql in connection.queries: print(sql) 那如果确实是想要在查询的时候指定过滤条件该如何做呢，这时候我们可以使用django.db.models.Prefetch来实现，Prefetch这个可以提前定义好queryset。示例代码如下： tags = Tag.objects.prefetch_related(Prefetch(\"articles\",queryset=Article.objects.filter(title__contains='hello'))).all() for tag in tags: articles = tag.articles.all() for article in articles: print(article) for sql in connection.queries: print('='*30) print(sql) 因为使用了Prefetch，即使在查询文章的时候使用了filter，也只会发生两次查询操作。 defer：在一些表中，可能存在很多的字段，但是一些字段的数据量可能是比较庞大的，而此时你又不需要，比如我们在获取文章列表的时候，文章的内容我们是不需要的，因此这时候我们就可以使用defer来过滤掉一些字段。这个字段跟values有点类似，只不过defer返回的不是字典，而是模型。示例代码如下： articles = list(Article.objects.defer(\"title\")) for sql in connection.queries: print('='*30) print(sql) 在看以上代码的sql语句，你就可以看到，查找文章的字段，除了title，其他字段都查找出来了。当然，你也可以使用article.title来获取这个文章的标题，但是会重新执行一个查询的语句。示例代码如下： articles = list(Article.objects.defer(\"title\")) for article in articles: # 因为在上面提取的时候过滤了title # 这个地方重新获取title，将重新向数据库中进行一次查找操作 print(article.title) for sql in connection.queries: print('='*30) print(sql) 10、defer虽然能过滤字段，但是有些字段是不能过滤的，比如id，即使你过滤了，也会提取出来。返回一个QuerySet对象,并且返回一个模型，而不是字典。 books = Book.objects.defer(\"name\") for book in books: print(book.id) #print(book.name)会查询到但是会重新查询数据库了，会浪费资源 print(type(book))# 类的模型 print(connection.queries) #'sql': 'SELECT `book`.`id`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id` FROM `book` #上面的sql语句过滤掉了 book.id语句 11、only：跟defer类似，只不过defer是过滤掉指定的字段，而only是只提取指定的字段。同样会查询id返回一个QuerySet对象,并且返回一个模型，而不是字典。 books = Book.objects.only(\"name\")#只提取一个name for book in books: print(book.id,book.name) print(type(book))# 类的模型 print(connection.queries) # {'sql': 'SELECT `book`.`id`, `book`.`name` FROM `book`', 'time': '0.000'} only和defer两个方法，如果没有指定的字段，后面请求的话，也会重新发起一次请求。是可以查询的，但是会影响资源，要谨慎使用！ 12、get：获取满足条件的数据。这个函数只能返回一条数据，并且如果给的条件有多条数据，那么这个方法会抛出MultipleObjectsReturned错误，如果给的条件没有任何数据，那么就会抛出DoesNotExit错误。所以这个方法在获取数据的时候，只能有且只有一条。 def index9(request): book = Book.objects.get(pk = 2) #满足的条件只能有一个当有多个的时候或者没有值得时候就会报错！ print(book) #Book object (2) #水浒传 print(book.name) #Book object (1) print(connection.queries) #'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id` FROM `book` WHERE `book`.`id` = 1 LIMIT 21' return HttpResponse('index9') 13、create：创建一条数据，并且保存到数据库中。这个方法相当于先用指定的模型创建一个对象，然后再调用这个对象的save方法。示例代码如下： article = Article(title='abc') article.save() # 下面这行代码相当于以上两行代码 article = Article.objects.create(title='abc') #============================================ def index10(request): #publisher = Publisher(name='知了出版社') #publisher.save() #print(connection.queries[2:]) #[{'sql': \"INSERT INTO `publisher` (`name`) VALUES ('知了出版社')\", 'time': '0.032'}] publisher = Publisher.objects.create(name='知了课堂出版社')#相当于上面的两行代码 print(connection.queries[2:]) #[{'sql': \"INSERT INTO `publisher` (`name`) VALUES ('知了课堂出版社')\", 'time': '0.031'}] return HttpResponse('index10') 14、get_or_create：根据某个条件进行查找，如果找到了那么就返回这条数据，如果没有查找到，那么就创建一个。示例代码如下： obj,created= Category.objects.get_or_create(title='默认分类') models.py def publisher_default(): return Publisher.objects.get_or_create(name ='默认的出版社') class Book(models.Model): name = models.CharField(max_length=300) pages = models.IntegerField() price = models.FloatField() rating = models.FloatField() author = models.ForeignKey(Author, models.DO_NOTHING) publisher = models.ForeignKey('Publisher', on_delete=models.SET_DEFAULT,default=publisher_default) views.py def index11(request): result = Publisher.objects.get_or_create(name = '知了出版社') #(, False) 知了出版社存在，就不会创建 print(result) #如果数据不存在 result = Publisher.objects.get_or_create(name='知了ABC出版社') #(, True) print(result) return HttpResponse('index11') 如果有标题等于默认分类的分类，那么就会查找出来，如果没有，则会创建并且存储到数据库中。 这个方法的返回值是一个元组，元组的第一个参数obj是这个对象，第二个参数created代表是否创建的。 15、bulk_create：一次性创建多个数据。示例代码如下： #创建多个出版社 publisher = Publisher.objects.bulk_create( [ Publisher(name = '123出版社'), Publisher(name='abc出版社'), ] ) #注意：如果数据库中存在，同样会继续创建 16、count：获取提取的数据的个数。如果想要知道总共有多少条数据，那么建议使用count，而不是使用len(articles)这种。因为count在底层是使用select count(*)来实现的，这种方式比使用len函数更加的高效。 count = Book.objects.count() print(count)#4 print(connection.queries) #SELECT COUNT(*) AS `__count` FROM `book` 17、first和last：返回QuerySet中的第一条和最后一条数据。 18、aggregate：使用聚合函数。 19、exists：判断某个条件的数据是否存在。如果要判断某个条件的元素是否存在，那么建议使用exists，这比使用count或者直接判断QuerySet更有效得多。示例代码如下： result = Book.objects.filter(name = '三国演义').exists() print(result)#True 如果数据存在则返回True否则返回False print(connection.queries) #\"SELECT (1) AS `a` FROM `book` WHERE `book`.`name` = '三国演义' LIMIT 1\" if Article.objects.filter(title__contains='hello').exists():#效率最高的 print(True) 比使用count更高效： if Article.objects.filter(title__contains='hello').count() > 0: print(True) 也比直接判断QuerySet更高效： if Article.objects.filter(title__contains='hello'): print(True) 20、distinct：去除掉那些重复的数据。这个方法如果底层数据库用的是MySQL，那么不能传递任何的参数。比如想要提取所有销售的价格超过80元的图书，并且删掉那些重复的，那么可以使用distinct来帮我们实现，示例代码如下： books = Book.objects.filter(bookorder__price__gte=80).distinct() 需要注意的是，如果在distinct之前使用了order_by，那么因为order_by会提取order_by中指定的字段，因此再使用distinct就会根据多个字段来进行唯一化，所以就不会把那些重复的数据删掉。示例代码如下： orders = BookOrder.objects.order_by(\"create_time\").values(\"book_id\").distinct() 那么以上代码因为使用了order_by，即使使用了distinct，也会把重复的book_id提取出来。 21、update：执行更新操作，在SQL底层走的也是update命令。比如要将所有category为空的article的article字段都更新为默认的分类。示例代码如下： Article.objects.filter(category__isnull=True).update(category_id=3) def index14(request): #一般de books = Book.objects.all() # for book in books: # book.price = book.price + 5 # book.save() Book.objects.update(price=F('price')+5)#F('price') 获取原来的价格 + 5元 print(connection.queries) #'UPDATE `book` SET `price` = (`book`.`price` + 5)' return HttpResponse('index14') 注意这个方法走的是更新的逻辑。所以更新完成后保存到数据库中不会执行save方法，因此不会更新auto_now设置的字段。 一次性可以把所有的数据都更新完。 22、delete：删除所有满足条件的数据。删除数据的时候，要注意on_delete指定的处理方式。 Author.objects.filter(id__gte=3).delete() 23、切片操作：有时候我们查找数据，有可能只需要其中的一部分。那么这时候可以使用切片操作来帮我们完成。QuerySet使用切片操作就跟列表使用切片操作是一样的。示例代码如下： books = Book.objects.all()[1:3] for book in books: print(book) def index15(request): #0,1 = [0:2] books = Book.objects.get_queryset()[0:2] for book in books: print(book.name) ''' 三国演义 水浒传 ''' print(connection.queries) #'SELECT `book`.`id`, `book`.`name`, `book`.`pages`, `book`.`price`, `book`.`rating`, `book`.`author_id`, `book`.`publisher_id` FROM `book` LIMIT 2' #用all的方法 books = Book.objects.all()[0:3] for book in books: print(book) ''' Book object (1) Book object (2) Book object (3) ''' return HttpResponse('index15') 切片操作并不是把所有数据从数据库中提取出来再做切片操作。而是在数据库层面使用LIMIE和OFFSET来帮我们完成。所以如果只需要取其中一部分的数据的时候，建议大家使用切片操作。 什么时候Django会将QuerySet转换为SQL去执行 生成一个QuerySet对象并不会马上转换为SQL语句去执行。 比如我们获取Book表下所有的图书： books = Book.objects.all() print(connection.queries) 我们可以看到在打印connection.quries的时候打印的是一个空的列表。说明上面的QuerySet并没有真正的执行。 在以下情况下QuerySet会被转换为SQL语句执行： 迭代：在遍历QuerySet对象的时候，会首先先执行这个SQL语句，然后再把这个结果返回进行迭代。比如以下代码就会转换为SQL语句： for book in Book.objects.all(): print(book) 使用步长做切片操作：QuerySet可以类似于列表一样做切片操作。做切片操作本身不会执行SQL语句，但是如果如果在做切片操作的时候提供了步长，那么就会立马执行SQL语句。需要注意的是，做切片后不能再执行filter方法，否则会报错。 调用len函数：调用len函数用来获取QuerySet中总共有多少条数据也会执行SQL语句。 调用list函数：调用list函数用来将一个QuerySet对象转换为list对象也会立马执行SQL语句。 判断：如果对某个QuerySet进行判断，也会立马执行SQL语句。 "},"django/django打造大型企业/第四章：数据库/014ORM作业.html":{"url":"django/django打造大型企业/第四章：数据库/014ORM作业.html","title":"014ORM作业","keywords":"","body":"ORM作业 准备工作 更改语言和时间区域 配置数据库 使用之前学到过的操作实现下面的查询操作 1、查询平均成绩大于60分的id和平均成绩 def index1(request): #1、查询平均成绩大于60分的id和平均成绩 students = Student.objects.annotate(score_avg=Avg('score__number')).filter(score_avg__gt=60).values('id','score_avg') for student in students: print(student) ''' {'id': 1, 'score_avg': 83.33333333333333} {'id': 3, 'score_avg': 91.0} {'id': 4, 'score_avg': 64.75} ''' print(connection.queries[2:]) #'SELECT `student`.`id`, AVG(`score`.`number`) AS `score_avg` FROM `student` LEFT OUTER JOIN `score` ON (`student`.`id` = `score`.`student_id`) GROUP BY `student`.`id` HAVING AVG(`score`.`number`) > 60.0e0 ORDER BY NULL' return HttpResponse('index1') 2、查询所有同学的id、姓名、选课的数量、总成绩 def index2(request): #2、查询所有同学的id、姓名、选课的数量、总成绩 students = Student.objects.annotate(course_nums=Count('score__id'),total=Sum('score__number')).values('id','name','course_nums','total') for student in students: print(student) ''' {'id': 1, 'name': '张三', 'course_nums': 3, 'total': 250.0} {'id': 2, 'name': '李四', 'course_nums': 4, 'total': 178.0} {'id': 3, 'name': '王五', 'course_nums': 4, 'total': 364.0} {'id': 4, 'name': '赵六', 'course_nums': 4, 'total': 259.0} ''' print(connection.queries[2:]) ''' 'SELECT `student`.`id`, `student`.`name`, COUNT(`score`.`id`) AS `course_nums`, SUM(`score`.`number`) AS `total` FROM `student` LEFT OUTER JOIN `score` ON (`student`.`id` = `score`.`student_id`) GROUP BY `student`.`id` ORDER BY NULL' ''' return HttpResponse('index2') 3、查询姓“李”的老师的个数 def index3(request): count = Teacher.objects.filter(name__startswith='李').count() print(count)# 1 姓李的老师只有一个 return HttpResponse('index3') 4、查询没学过“李老师”课的同学的id、姓名 def index4(request): students = Student.objects.exclude(score__course__teacher__name='李老师').values('id','name') for student in students: print(student) #{'id': 1, 'name': '张三'} print(connection.queries) #\"SELECT `student`.`id`, `student`.`name` FROM `student` WHERE NOT (`student`.`id` IN (SELECT U1.`student_id` FROM `score` U1 INNER JOIN `course` U2 ON (U1.`course_id` = U2.`id`) INNER JOIN `teacher` U3 ON (U2.`teacher_id` = U3.`id`) WHERE U3.`name` = '李老师'))\" return HttpResponse('index4') 5、查询学过课程id为2的所有同学的id和姓名 def index5(request): #查询学过课程id为1和2的所有同学的id和姓名 students = Student.objects.filter(score__course__in=[1,2]).values('id','name') for student in students: print(student) ''' {'id': 1, 'name': '张三'} {'id': 1, 'name': '张三'} {'id': 2, 'name': '李四'} {'id': 2, 'name': '李四'} {'id': 3, 'name': '王五'} {'id': 3, 'name': '王五'} {'id': 4, 'name': '赵六'} {'id': 4, 'name': '赵六'} ''' students = Student.objects.filter(score__course__in=[1, 2]).values('id', 'name').distinct() for student in students: print(student) ''' {'id': 1, 'name': '张三'} {'id': 2, 'name': '李四'} {'id': 3, 'name': '王五'} {'id': 4, 'name': '赵六'} ''' print(connection.queries[2:]) return HttpResponse('index5') 6、查询学过‘黄老师’所教的‘所有课’的同学的id和姓名 def index6(request): #查询学过‘黄老师’所教的‘所有课’的同学的id和姓名 #1、先找到每一位学生学习黄老师课程的数量 A #2、在课程表中找到黄老师教的课程的数量 B #3、判断A是否等于B，如果相等，那么意味着这位学生学完黄老师的所有课程 annotate相当于生成一个新的字段 students = Student.objects.annotate(nums = Count(\"score__course\",filter=Q(score__course__teacher__name='李老师'))).filter(nums =Course.objects.filter(teacher__name='李老师').count()).values('id','name') for student in students: print(student) ''' {'id': 1, 'name': '张三'} {'id': 2, 'name': '李四'} {'id': 3, 'name': '王五'} {'id': 4, 'name': '赵六'} ''' print(connection.queries[2:]) #[{'sql': \"SELECT COUNT(*) AS `__count` FROM `course` INNER JOIN `teacher` ON (`course`.`teacher_id` = `teacher`.`id`) WHERE `teacher`.`name` = '黄老师'\", 'time': '0.000'}, {'sql': \"SELECT `student`.`id`, `student`.`name` FROM `student` LEFT OUTER JOIN `score` ON (`student`.`id` = `score`.`student_id`) LEFT OUTER JOIN `course` ON (`score`.`course_id` = `course`.`id`) LEFT OUTER JOIN `teacher` ON (`course`.`teacher_id` = `teacher`.`id`) GROUP BY `student`.`id` HAVING COUNT(CASE WHEN (`teacher`.`name` = '黄老师') THEN `score`.`course_id` ELSE NULL END) = 2 ORDER BY NULL\", 'time': '0.000'}] return HttpResponse('index6') 7、查询所有课程成绩小于60分的同学的id和姓名 def index7(request): #查询所有课程成绩小于60分的同学的id和姓名 students = Student.objects.exclude(score__number__gte=60).values('id','name') for student in students: print(student) #{'id': 2, 'name': '李四'} print(connection.queries) #'SELECT `student`.`id`, `student`.`name` FROM `student` WHERE NOT (`student`.`id` IN (SELECT U1.`student_id` FROM `score` U1 WHERE U1.`number` >= 60.0e0)) return HttpResponse('index7') 8、查询没有学全所有课程的同学id、姓名 def index8(request): #查询没有学全所有课程的同学id、姓名 students = Student.objects.annotate(num = Count(F('score__course'))).filter(num__lt=Course.objects.count()).values('id','name') for student in students: print(student) #{'id': 1, 'name': '张三'} print(connection.queries) #{'sql': 'SELECT COUNT(*) AS `__count` FROM `course`', 'time': '0.000'}, {'sql': 'SELECT `student`.`id`, `student`.`name` FROM `student` LEFT OUTER JOIN `score` ON (`student`.`id` = `score`.`student_id`) GROUP BY `student`.`id` HAVING COUNT(`score`.`course_id`) 9、查询所有学生的姓名、平均分，并且按照平均分从高到低排序 def index9(request): #查询所有学生的姓名、平均分，并且按照平均分从高到低排序 students = Student.objects.annotate(avg = Avg('score__number')).order_by('-avg').values('name','avg') for student in students: print(student) ''' {'name': '王五', 'avg': 91.0} {'name': '张三', 'avg': 83.33333333333333} {'name': '赵六', 'avg': 64.75} {'name': '李四', 'avg': 42.0} ''' print(connection.queries) #'SELECT `student`.`name`, AVG(`score`.`number`) AS `avg` FROM `student` LEFT OUTER JOIN `score` ON (`student`.`id` = `score`.`student_id`) GROUP BY `student`.`id` ORDER BY `avg` DESC' return HttpResponse('index9') 10、查询各科成绩的最高分和最低分，以如下形式显示：课程ID、课程名称、最高分、最低分 def index10(request): #查询各科成绩的最高分和最低分，以如下形式显示：课程ID、课程名称、最高分、最低分 courses = Course.objects.annotate(min =Min(\"score__number\"),max=Max(\"score__number\")).values('id','name','min','max') for course in courses: print(course) ''' {'id': 1, 'name': 'Python', 'min': 40.0, 'max': 104.0} {'id': 2, 'name': '前端', 'min': 40.0, 'max': 90.0} {'id': 3, 'name': 'Java', 'min': 54.0, 'max': 94.0} {'id': 4, 'name': '安卓', 'min': 34.0, 'max': 90.0} ''' print(connection.queries) #{'sql': 'SELECT `course`.`id`, `course`.`name`, MIN(`score`.`number`) AS `min`, MAX(`score`.`number`) AS `max` FROM `course` LEFT OUTER JOIN `score` ON (`course`.`id` = `score`.`course_id`) GROUP BY `course`.`id` ORDER BY NULL', 'time': '0.000'} return HttpResponse('index10') 11、查询每门课程的平均成绩，按照平均分成绩进行排序 def index11(request): #查询每门课程的平均成绩，按照平均分成绩进行排序 courses = Course.objects.annotate(avg = Avg('score__number')).order_by('avg').values('name','avg') for course in courses: print(course) ''' {'name': '安卓', 'avg': 67.66666666666667} {'name': '前端', 'avg': 68.25} {'name': 'Python', 'avg': 70.0} {'name': 'Java', 'avg': 71.25} ''' print(connection.queries) #{'sql': 'SELECT `course`.`name`, AVG(`score`.`number`) AS `avg` FROM `course` LEFT OUTER JOIN `score` ON (`course`.`id` = `score`.`course_id`) GROUP BY `course`.`id` ORDER BY `avg` ASC', 'time': '0.000'} return HttpResponse('index11') 12、统计总共有多少女生，多少男生 def index12(request): #统计总共有多少女生，多少男生 rows = Student.objects.aggregate(male_num=Count('gender',filter=Q(gender =1)),female_num=Count('gender',filter=Q(gender =2))) print(rows) #{'male_num': 2, 'female_num': 2} print(connection.queries) #{'sql': 'SELECT COUNT(CASE WHEN `student`.`gender` = 1 THEN `student`.`gender` ELSE NULL END) AS `male_num`, COUNT(CASE WHEN `student`.`gender` = 2 THEN `student`.`gender` ELSE NULL END) AS `female_num` FROM `student`', 'time': '0.000'} return HttpResponse('index12') 13、将‘黄老师’的每一门课程都在原来的基础之上加5分 def index13(request): #将‘黄老师’的每一门课程都在原来的基础之上加5分 rows = Score.objects.filter(course__teacher__name='黄老师').update(number = F(\"number\")+5) print(rows)#8 print(connection.queries) #{'sql': \"SELECT `score`.`id` FROM `score` INNER JOIN `course` ON (`score`.`course_id` = `course`.`id`) INNER JOIN `teacher` ON (`course`.`teacher_id` = `teacher`.`id`) WHERE `teacher`.`name` = '黄老师'\", 'time': '0.000'}, {'sql': 'UPDATE `score` SET `number` = (`score`.`number` + 5) WHERE `score`.`id` IN (1, 5, 9, 13, 3, 7, 11, 15)', 'time': '0.015'} return HttpResponse('index13') 14、查询两门以上不及格的同学的id、姓名、以及不及格课程数 def index14(request): #查询两门以上不及格的同学的id、姓名、以及不及格课程数 students = Student.objects.annotate(bad_count = Count('score__number',filter=Q(score__number__lt=60))).filter(bad_count__gte=2).values('id','name','bad_count') for student in students: print(student) #{'id': 2, 'name': '李四', 'bad_count': 3} print(connection.queries) #{'sql': 'SELECT `student`.`id`, `student`.`name`, COUNT(CASE WHEN `score`.`number` = 2 ORDER BY NULL', 'time': '0.000'} return HttpResponse('index14') 15、查询每门课的选课人数 def index15(request): #查询每门课的选课人数 courses = Course.objects.annotate(student_nums =Count('score__student')).values('id','name','student_nums') for course in courses: print(course) ''' {'id': 1, 'name': 'Python', 'student_nums': 4} {'id': 2, 'name': '前端', 'student_nums': 4} {'id': 3, 'name': 'Java', 'student_nums': 4} {'id': 4, 'name': '安卓', 'student_nums': 3} ''' print(connection.queries) #{'sql': 'SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED', 'time': '0.000'}, {'sql': 'SELECT `course`.`id`, `course`.`name`, COUNT(`score`.`student_id`) AS `student_nums` FROM `course` LEFT OUTER JOIN `score` ON (`course`.`id` = `score`.`course_id`) GROUP BY `course`.`id` ORDER BY NULL', 'time': '0.000'} return HttpResponse('index15') "},"django/django打造大型企业/第四章：数据库/015ORM模型迁移.html":{"url":"django/django打造大型企业/第四章：数据库/015ORM模型迁移.html","title":"015ORM模型迁移","keywords":"","body":"ORM模型迁移 迁移命令： makemigrations：将模型生成迁移脚本。模型所在的app，必须放在settings.py中的INSTALLED_APPS中。这个命令有以下几个常用选项： app_label：后面可以跟一个或者多个app，那么就只会针对这几个app生成迁移脚本。如果没有任何的app_label，那么会检查INSTALLED_APPS中所有的app下的模型，针对每一个app都生成响应的迁移脚本。python manage.py makemigrations app_name 如果后面没有app_name将会执行所有的app --name：给这个迁移脚本指定一个名字。 python manage.py makemigrations article --name \"remove_article_content_createtime\" --empty：生成一个空的迁移脚本。如果你想写自己的迁移脚本，可以使用这个命令来实现一个空的文件，然后自己再在文件中写迁移脚本。 migrate：将新生成的迁移脚本。映射到数据库中。创建新的表或者修改表的结构。以下一些常用的选项： app_label：将某个app下的迁移脚本映射到数据库中。如果没有指定，那么会将所有在INSTALLED_APPS中的app下的模型都映射到数据库中。 app_label migrationname：将某个app下指定名字的migration文件映射到数据库中。 --fake：可以将指定的迁移脚本名字添加到数据库中。但是并不会把迁移脚本转换为SQL语句，修改数据库中的表。 数据库中没有但代码中有 python manage.py migrate article --fake --fake-initial：将第一次生成的迁移文件版本号记录在数据库中。但并不会真正的执行迁移脚本。 python manage.py migrate article --fake-init 执行migrate命令的时候报错的解决办法： 原因： 执行migrate命令会报错的原因是，数据库的'django_migrations'表中的迁移版本记录和代码中的迁移脚本不一致导致的。 解决办法： 使用--fake参数，首先对比数据库中迁移脚本和代码中的迁移脚本。然后找到那个不同，之后在使用--fake,将代码中迁移脚本添加到django_migrations中，但是并不会执行sql语句，这样就可以避免每次执行migrate的时候，都执行一些重复的迁移脚本。 终极解决方案 如果代码中迁移脚本和数据库中的迁移脚本实在太多，就是搞不清了。那么这时候就可以使用终极解决方案： 1、终极解决方案原理：就是将之前的那些迁移脚本都不用了，重新来过，要将出问题的app下的所有模型的字段，和数据库中相对应表的字段保持一致。重新映射。 2、将出问题的app下的所有模型，都和数据库中的表保持一致。 3、将出问题app下的所有迁移脚本文件都删掉，再在django_migrations将出问题的app相关的迁移记录都删掉。 4、使用makemigrations重新将模型生成一个迁移脚本。 5、使用migrate --fake-init参数，将刚刚生成的迁移脚本，标记为已经完成（因为这些模型相对应的表，其实都已经在数据库中存在，不需要重新填写。 showmigrations：查看某个app下的迁移文件。如果后面没有app，那么将查看INSTALLED_APPS中所有的迁移文件。 sqlmigrate：查看某个迁移文件在映射到数据库中的时候，转换的SQL语句。 migrations中的迁移版本和数据库中的迁移版本对不上怎么办？ 找到哪里不一致，然后使用python manage.py --fake [版本名字]，将这个版本标记为已经映射。 删除指定app下migrations和数据库表django_migrations中和这个app相关的版本号，然后将模型中的字段和数据库中的字段保持一致，再使用命令python manage.py makemigrations重新生成一个初始化的迁移脚本，之后再使用命令python manage.py makemigrations --fake-initial来将这个初始化的迁移脚本标记为已经映射。以后再修改就没有问题了。 更多关于迁移脚本的。请查看官方文档：https://docs.djangoproject.com/en/2.0/topics/migrations/ 根据已有的表自动生成模型： 在实际开发中，有些时候可能数据库已经存在了。如果我们用Django来开发一个网站，读取的是之前已经存在的数据库中的数据。那么该如何将模型与数据库中的表映射呢？根据旧的数据库生成对应的ORM模型，需要以下几个步骤： Django给我们提供了一个inspectdb的命令，可以非常方便的将已经存在的表，自动的生成模型。想要使用inspectdb自动将表生成模型。首先需要在settings.py中配置好数据库相关信息。不然就找不到数据库。示例代码如下： DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': \"migrations_demo\", 'HOST': '127.0.0.1', 'PORT': '3306', 'USER': 'root', 'PASSWORD': 'root' } } 比如有以下表： article表： tag表： article_tag表： front_user表： 那么通过python manage.py inspectdb，就会将表转换为模型后的代码，显示在终端： from django.db import models class ArticleArticle(models.Model): title = models.CharField(max_length=100) content = models.TextField(blank=True, null=True) create_time = models.DateTimeField(blank=True, null=True) author = models.ForeignKey('FrontUserFrontuser', models.DO_NOTHING, blank=True, null=True) class Meta: managed = False db_table = 'article_article' class ArticleArticleTags(models.Model): article = models.ForeignKey(ArticleArticle, models.DO_NOTHING) tag = models.ForeignKey('ArticleTag', models.DO_NOTHING) class Meta: managed = False db_table = 'article_article_tags' unique_together = (('article', 'tag'),) class ArticleTag(models.Model): name = models.CharField(max_length=100) class Meta: managed = False db_table = 'article_tag' class FrontUserFrontuser(models.Model): username = models.CharField(max_length=100) telephone = models.CharField(max_length=11) class Meta: managed = False db_table = 'front_user_frontuser' 以上代码只是显示在终端。如果想要保存到文件中。那么可以使用>重定向输出到指定的文件。比如让他输出到models.py文件中。示例命令如下： python manage.py inspectdb > models.py 以上的命令，只能在终端执行，不能在pycharm->Tools->Run manage.py Task...中使用。 如果只是想要转换一个表为模型。那么可以指定表的名字。示例命令如下： python manage.py inspectdb article_article > models.py 修正模型：新生成的ORM模型有些地方可能不太适合使用。比如模型的名字，表之间的关系等等。那么以下选项还需要重新配置一下： 模型名：自动生成的模型，是根据表的名字生成的，可能不是你想要的。这时候模型的名字你可以改成任何你想要的。 模型所属app：根据自己的需要，将相应的模型放在对应的app中。放在同一个app中也是没有任何问题的。只是不方便管理。 模型外键引用：将所有使用ForeignKey的地方，模型引用都改成字符串。这样不会产生模型顺序的问题。另外，如果引用的模型已经移动到其他的app中了，那么还要加上这个app的前缀。 让Django管理模型：将Meta下的managed=False删掉，如果保留这个，那么以后这个模型有任何的修改，使用migrate都不会映射到数据库中。 当有多对多的时候，应该也要修正模型。将中间表注视了，然后使用ManyToManyField来实现多对多。并且，使用ManyToManyField生成的中间表的名字可能和数据库中那个中间表的名字不一致，这时候肯定就不能正常连接了。那么可以通过db_table来指定中间表的名字。示例代码如下： class Article(models.Model): title = models.CharField(max_length=100, blank=True, null=True) content = models.TextField(blank=True, null=True) author = models.ForeignKey('front.User', models.SET_NULL, blank=True, null=True) # 使用ManyToManyField模型到表，生成的中间表的规则是：article_tags # 但现在已经存在的表的名字叫做：article_tag # 可以使用db_table，指定中间表的名字 tags = models.ManyToManyField(\"Tag\",db_table='article_tag') class Meta: db_table = 'article' 表名：切记不要修改表的名字。不然映射到数据库中，会发生找不到对应表的错误。 执行命令python manage.py makemigrations生成初始化的迁移脚本。方便后面通过ORM来管理表。这时候还需要执行命令python manage.py migrate --fake-initial，因为如果不使用--fake-initial，那么会将迁移脚本会映射到数据库中。这时候迁移脚本会新创建表，而这个表之前是已经存在了的，所以肯定会报错。此时我们只要将这个0001-initial的状态修改为已经映射，而不真正执行映射，下次再migrate的时候，就会忽略他。 将Django的核心表映射到数据库中：Django中还有一些核心的表也是需要创建的。不然有些功能是用不了的。比如auth相关表。如果这个数据库之前就是使用Django开发的，那么这些表就已经存在了。可以不用管了。如果之前这个数据库不是使用Django开发的，那么应该使用migrate命令将Django中的核心模型映射到数据库中。 验证数据表 def index(request): # article = Article(title='abc',content='1234') # author = User.objects.create(username='zhiliao',password='12334') # article.author = author # article.save() article =Article.objects.first() tag1 = Tag.objects.create(name='python') tag2 = Tag.objects.create(name='php') article.tags.add(tag1,tag2) article.save() return HttpResponse('success') "},"django/django打造大型企业/第五章：高级视图/5.1 第一节：限制请求method.html":{"url":"django/django打造大型企业/第五章：高级视图/5.1 第一节：限制请求method.html","title":"5.1 第一节：限制请求method","keywords":"","body":"限制请求Method 常用的请求method： ET请求：GET请求一般用来向服务器索取数据，但不会向服务器提交数据，不会对服务器的状态进行更改。比如向服务器获取某篇文章的详情。 POST请求：POST请求一般是用来向服务器提交数据，会对服务器的状态进行更改。比如提交一篇文章给服务器。 限制请求装饰器： Django内置的视图装饰器可以给视图提供一些限制。比如这个视图只能通过GET的method访问等。以下将介绍一些常用的内置视图装饰器。 django.http.decorators.http.require_http_methods：这个装饰器需要传递一个允许访问的方法的列表。比如只能通过GET的方式访问。那么示例代码如下： from django.views.decorators.http import require_http_methods @require_http_methods([\"GET\"]) def my_view(request): pass django.views.decorators.http.require_GET：这个装饰器相当于是require_http_methods(['GET'])的简写形式，只允许使用GET的method来访问视图。示例代码如下： from django.views.decorators.http import require_GET @require_GET def my_view(request): pass django.views.decorators.http.require_POST：这个装饰器相当于是require_http_methods(['POST'])的简写形式，只允许使用POST的method来访问视图。示例代码如下： from django.views.decorators.http import require_POST @require_POST def my_view(request): pass django.views.decorators.http.require_safe：这个装饰器相当于是require_http_methods(['GET','HEAD'])的简写形式，只允许使用相对安全的方式来访问视图。因为GET和HEAD不会对服务器产生增删改的行为。因此是一种相对安全的请求方式。示例代码如下： from django.views.decorators.http import require_safe @require_safe def my_view(request): pass "},"django/django打造大型企业/第五章：高级视图/5.2 第二节：页面重定向.html":{"url":"django/django打造大型企业/第五章：高级视图/5.2 第二节：页面重定向.html","title":"5.2 第二节：页面重定向","keywords":"","body":"重定向 重定向分为永久性重定向和暂时性重定向，在页面上体现的操作就是浏览器会从一个页面自动跳转到另外一个页面。比如用户访问了一个需要权限的页面，但是该用户当前并没有登录，因此我们应该给他重定向到登录页面。 永久性重定向：http的状态码是301，多用于旧网址被废弃了要转到一个新的网址确保用户的访问，最经典的就是京东网站，你输入www.jingdong.com的时候，会被重定向到www.jd.com，因为jingdong.com这个网址已经被废弃了，被改成jd.com，所以这种情况下应该用永久重定向。 暂时性重定向：http的状态码是302，表示页面的暂时性跳转。比如访问一个需要权限的网址，如果当前用户没有登录，应该重定向到登录页面，这种情况下，应该用暂时性重定向。 在Django中，重定向是使用redirect(to, *args, permanent=False, **kwargs)来实现的。to是一个url，permanent代表的是这个重定向是否是一个永久的重定向，默认是False。关于重定向的使用。请看以下例子： ![202053180513](C:/Users/Administrator/Desktop/202053180513.giffrom django.shortcuts import reverse,redirect def profile(request): if request.GET.get(\"username\"): return HttpResponse(\"%s，欢迎来到个人中心页面！\") else: return redirect(reverse(\"user:login\")) #from django.shortcuts import render,redirect,reverse from django.http import HttpResponse # Create your views here. def index(request): #如果没有登录，那么就重定向到注册页面 #如果在URL中传递了username参数，那么久认为是登录了，否则就没有 #/?username=xxx #request.GET 获取的是一个字典，get是方法 username = request.GET.get(\"username\") if username: return HttpResponse(f'您的用户名为：{username}') else: return redirect(reverse('signup')) #reverse('signup') 翻转到signup名字的url地址 def signup(request): return HttpResponse('注册页') 301与302状态码？ 301是永久性的重定向，302是临时性的重定向。 "},"django/django打造大型企业/第五章：高级视图/5.3 第三节：HttpRequst对象.html":{"url":"django/django打造大型企业/第五章：高级视图/5.3 第三节：HttpRequst对象.html","title":"5.3 第三节：HttpRequst对象","keywords":"","body":"WSGIRequest对象 Django在接收到http请求之后，会根据http请求携带的参数以及报文信息创建一个WSGIRequest对象，并且作为视图函数第一个参数传给视图函数。也就是我们经常看到的request参数。在这个对象上我们可以找到客户端上传上来的所有信息。这个对象的完整路径是django.core.handlers.wsgi.WSGIRequest。 WSGIRequest对象常用属性和方法： WSGIRequest对象常用属性： WSGIRequest对象上大部分的属性都是只读的。因为这些属性是从客户端上传上来的，没必要做任何的修改。以下将对一些常用的属性进行讲解： path：请求服务器的完整“路径”，但不包含域名和参数。比如http://www.baidu.com/xxx/yyy/，那么path就是/xxx/yyy/。 print(request.path) #访问http://127.0.0.1:8000/login/ 返回：/login/ method：代表当前请求的http方法。比如是GET还是POST。 print(request.method)#GET GET：一个django.http.request.QueryDict对象。操作起来类似于字典。这个属性中包含了所有以?xxx=xxx的方式上传上来的参数。 print(request.GET['username']) #访问http://127.0.0.1:8000/login/?username=topljd #topljd POST：也是一个django.http.request.QueryDict对象。这个属性中包含了所有以POST方式上传上来的参数。FoemData传输数据 FILES：也是一个django.http.request.QueryDict对象。这个属性中包含了所有上传的文件。 COOKIES：一个标准的Python字典，包含所有的cookie，键值对都是字符串类型。 session：一个类似于字典的对象。用来操作服务器的session。 META：存储的客户端发送上来的所有header信息。 for key,values in request.META.items(): print(key,',',values) ''' ALLUSERSPROFILE , C:\\ProgramData APPDATA , C:\\Users\\Administrator\\AppData\\Roaming COMMONPROGRAMFILES , C:\\Program Files\\Common Files COMMONPROGRAMFILES(X86) , C:\\Program Files (x86)\\Common Files COMMONPROGRAMW6432 , C:\\Program Files\\Common Files COMPUTERNAME , DESKTOP-O619S1I COMSPEC , C:\\Windows\\system32\\cmd.exe DJANGO_SETTINGS_MODULE , wsgirequest.settings DRIVERDATA , C:\\Windows\\System32\\Drivers\\DriverData FPS_BROWSER_APP_PROFILE_STRING , Internet Explorer FPS_BROWSER_USER_PROFILE_STRING , Default HOMEDRIVE , C: HOMEPATH , \\Users\\Administrator IDEA_INITIAL_DIRECTORY , d:\\Program Files\\JetBrains\\PyCharm 2020.1\\bin LOCALAPPDATA , C:\\Users\\Administrator\\AppData\\Local LOGONSERVER , \\\\DESKTOP-O619S1I NUMBER_OF_PROCESSORS , 4 ONEDRIVE , C:\\Users\\Administrator\\OneDrive OS , Windows_NT PATH , G:\\ENV\\django_env\\Scripts;D:\\Program Files\\Python38\\Scripts\\;D:\\Program Files\\Python38\\;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;d:\\Program Files\\Git\\cmd;D:\\Program Files\\nodejs\\;C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Administrator\\AppData\\Roaming\\npm PATHEXT , .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW PROCESSOR_ARCHITECTURE , AMD64 PROCESSOR_IDENTIFIER , Intel64 Family 6 Model 42 Stepping 7, GenuineIntel PROCESSOR_LEVEL , 6 PROCESSOR_REVISION , 2a07 PROGRAMDATA , C:\\ProgramData PROGRAMFILES , C:\\Program Files PROGRAMFILES(X86) , C:\\Program Files (x86) PROGRAMW6432 , C:\\Program Files PROMPT , (django_env) $P$G PSMODULEPATH , C:\\Program Files\\WindowsPowerShell\\Modules;C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules PUBLIC , C:\\Users\\Public PYCHARM_DISPLAY_PORT , 63342 PYCHARM_HOSTED , 1 PYTHONIOENCODING , UTF-8 PYTHONPATH , G:\\django\\wsgirequest;D:\\Program Files\\JetBrains\\PyCharm 2020.1\\plugins\\python\\helpers\\pycharm_matplotlib_backend;D:\\Program Files\\JetBrains\\PyCharm 2020.1\\plugins\\python\\helpers\\pycharm_display PYTHONUNBUFFERED , 1 SESSIONNAME , Console SYSTEMDRIVE , C: SYSTEMROOT , C:\\Windows TEMP , C:\\Users\\ADMINI~1\\AppData\\Local\\Temp TMP , C:\\Users\\ADMINI~1\\AppData\\Local\\Temp USERDOMAIN , DESKTOP-O619S1I USERDOMAIN_ROAMINGPROFILE , DESKTOP-O619S1I USERNAME , Administrator USERPROFILE , C:\\Users\\Administrator VIRTUAL_ENV , G:\\ENV\\django_env WINDIR , C:\\Windows WORKON_HOME , G:\\ENV _OLD_VIRTUAL_PATH , D:\\Program Files\\Python38\\Scripts\\;D:\\Program Files\\Python38\\;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;d:\\Program Files\\Git\\cmd;D:\\Program Files\\nodejs\\;C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Administrator\\AppData\\Roaming\\npm _OLD_VIRTUAL_PROMPT , $P$G RUN_MAIN , true SERVER_NAME , activate.navicat.com GATEWAY_INTERFACE , CGI/1.1 SERVER_PORT , 8000 REMOTE_HOST , CONTENT_LENGTH , SCRIPT_NAME , SERVER_PROTOCOL , HTTP/1.1 SERVER_SOFTWARE , WSGIServer/0.2 REQUEST_METHOD , GET PATH_INFO , /login/ QUERY_STRING , username=topljd REMOTE_ADDR , 127.0.0.1 CONTENT_TYPE , text/plain HTTP_HOST , 127.0.0.1:8000 HTTP_CONNECTION , keep-alive HTTP_CACHE_CONTROL , max-age=0 HTTP_UPGRADE_INSECURE_REQUESTS , 1 HTTP_USER_AGENT , Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36 HTTP_ACCEPT , text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 HTTP_SEC_FETCH_SITE , none HTTP_SEC_FETCH_MODE , navigate HTTP_SEC_FETCH_USER , ?1 HTTP_SEC_FETCH_DEST , document HTTP_ACCEPT_ENCODING , gzip, deflate, br HTTP_ACCEPT_LANGUAGE , zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 wsgi.input , wsgi.errors , ' mode='w' encoding='utf-8'> wsgi.version , (1, 0) wsgi.run_once , False wsgi.url_scheme , http wsgi.multithread , True wsgi.multiprocess , False wsgi.file_wrapper , ''' CONTENT_LENGTH：请求的正文的长度（是一个字符串）。 CONTENT_TYPE：请求的正文的MIME类型。 HTTP_ACCEPT：响应可接收的Content-Type。 HTTP_ACCEPT_ENCODING：响应可接收的编码。 HTTP_ACCEPT_LANGUAGE： 响应可接收的语言。 HTTP_HOST：客户端发送的HOST值。 HTTP_REFERER：在访问这个页面上一个页面的url。 QUERY_STRING：单个字符串形式的查询字符串（未解析过的形式）。 REMOTE_ADDR：客户端的IP地址。如果服务器使用了nginx做反向代理或者负载均衡，那么这个值返回的是127.0.0.1，这时候可以使用HTTP_X_FORWARDED_FOR来获取，所以获取ip地址的代码片段如下： if request.META.has_key('HTTP_X_FORWARDED_FOR'): ip = request.META['HTTP_X_FORWARDED_FOR'] else: ip = request.META['REMOTE_ADDR'] REMOTE_HOST：客户端的主机名。 REQUEST_METHOD：请求方法。一个字符串类似于GET或者POST。 SERVER_NAME：服务器域名。 SERVER_PORT：服务器端口号，是一个字符串类型。 WSGIRequest对象常用方法： is_secure()：是否是采用https协议。 print(request.is_secure()) #False is_ajax()：是否采用ajax发送的请求。原理就是判断请求头中是否存在X-Requested-With:XMLHttpRequest。 print(request.is_ajax()) #False get_host()：服务器的域名。如果在访问的时候还有端口号，那么会加上端口号。比如www.baidu.com:9000。 print(request.get_host()) #127.0.0.1:8000 get_full_path()：返回完整的path。如果有查询字符串，还会加上查询字符串。比如/music/bands/?print=True。 print(request.get_full_path()) #访问http://127.0.0.1:8000/login/?username=topljd #返回 /login/?username=topljd get_raw_uri()：获取请求的完整url。 #返回整个URL地址 print(request.get_raw_uri()) #http://127.0.0.1:8000/login/?username=topljd QueryDict对象： 我们平时用的request.GET和request.POST都是QueryDict对象，这个对象继承自dict，因此用法跟dict相差无几。其中用得比较多的是get方法和getlist方法。 print(type(request.GET)) print(type(request.POST)) ''' ''' get方法：用来获取指定key的值，如果没有这个key，那么会返回None。 #username = request.GET['username'] #上面这个方法没有值就会报错，下面这个直接返回None #username = request.GET.get('uwername') username =request.GET.get('username',default='topljd') #topljd 如果没有username值，就默认返回topljd print(username) getlist方法：如果浏览器上传上来的key对应的值有多个，那么就需要通过这个方法获取. from django.views.decorators.http import require_http_methods @require_http_methods(['GET','POST']) def add_article(request): if request.method =='GET': return render(request,'add_article.html') else: title = request.POST.get('title') content = request.POST.get('content') tags = request.POST.getlist('tags') print(f'title:{title},content{content},tags:{tags}') ''' title:今日，为他们深切哀悼,contentbbb,tags:['python', 'Django'] ''' return HttpResponse('success') add article 标题 内容 标签 Python Django Flask "},"django/django打造大型企业/第五章：高级视图/5.4 第四节：HttpResponse对象.html":{"url":"django/django打造大型企业/第五章：高级视图/5.4 第四节：HttpResponse对象.html","title":"5.4 第四节：HttpResponse对象","keywords":"","body":"HttpResponse对象 Django服务器接收到客户端发送过来的请求后，会将提交上来的这些数据封装成一个HttpRequest对象传给视图函数。那么视图函数在处理完相关的逻辑后，也需要返回一个响应给浏览器。而这个响应，我们必须返回HttpResponseBase或者他的子类的对象。而HttpResponse则是HttpResponseBase用得最多的子类。那么接下来就来介绍一下HttpResponse及其子类。 常用属性： 1、content：返回的内容。 # response = HttpResponse() # response.content='知了课堂' response = HttpResponse('知了课堂1') 2、status_code：返回的HTTP响应状态码。 response.status_code = 400 3、content_type：返回的数据的MIME类型，默认为text/html。浏览器会根据这个属性，来显示数据。如果是text/html，那么就会解析这个字符串，如果text/plain，那么就会显示一个纯文本。常用的Content-Type 如下： text/html（默认的，html文件） text/plain（纯文本） text/css（css文件） text/javascript（js文件） multipart/form-data（文件提交） application/json（json传输） application/xml（xml文件） 设置请求头：response['X-Access-Token'] = 'xxxx'。 response = HttpResponse('知了课堂',content_type='text/plain;charset=utf-8') #知了课堂 被当做普通的代码处理 #请求头 response['PASSWORD']='zhile' 常用方法： set_cookie：用来设置cookie信息。后面讲到授权的时候会着重讲到。 delete_cookie：用来删除cookie信息。 write：HttpResponse是一个类似于文件的对象，可以用来写入数据到数据体（content）中。 response.write('知了') #知了课堂知了 #用来写入content中 JsonResponse类： 用来对象dump成json字符串，然后返回将json字符串封装成Response对象返回给浏览器。并且他的Content-Type是application/json。示例代码如下： from django.http import JsonResponse def index(request): return JsonResponse({\"username\":\"zhiliao\",\"age\":18}) ###手打代码 from django.http import JsonResponse import json def jsonresponse_view(request): person ={ 'username':'zhiliao', 'age':18, 'height':170 } person_str = json.dumps(person) response = HttpResponse(person_str,content_type='application/json') #return response #{\"username\": \"zhiliao\", \"age\": 18, \"height\": 170} #下面的代码是上面代码的缩写 response = JsonResponse(person) return response #{\"username\": \"zhiliao\", \"age\": 18, \"height\": 170} 默认情况下JsonResponse只能对字典进行dump，如果想要对非字典的数据进行dump，那么需要给JsonResponse传递一个safe=False参数。示例代码如下： from django.http import JsonResponse def index(request): persons = ['张三','李四','王五'] return HttpResponse(persons) 以上代码会报错，应该在使用HttpResponse的时候，传入一个safe=False参数，示例代码如下： return HttpResponse(persons,safe=False) ###手打代码 from django.http import JsonResponse import json def jsonresponse_view(request): person =[ { 'username': 'zhiliao', 'age': 18, 'height': 170 }, { 'username': 'zhiliao', 'age': 20, 'height': 172 } ] person_str = json.dumps(person) response = HttpResponse(person_str,content_type='application/json') #return response #{\"username\": \"zhiliao\", \"age\": 18, \"height\": 170} #下面的代码是上面代码的缩写 response = JsonResponse(person,safe=False) return response #[{\"username\": \"zhiliao\", \"age\": 18, \"height\": 170}, {\"username\": \"zhiliao\", \"age\": 20, \"height\": 172}] "},"django/django打造大型企业/第五章：高级视图/5.5 第五节：生成csv文件.html":{"url":"django/django打造大型企业/第五章：高级视图/5.5 第五节：生成csv文件.html","title":"5.5 第五节：生成csv文件","keywords":"","body":"生成scv文件 有时候我们做的网站，需要将一些数据，生成有一个CSV文件给浏览器，并且是作为附件的形式下载下来。以下将讲解如何生成CSV文件。 生成小的CSV文件： 这里将用一个生成小的CSV文件为例，来把生成CSV文件的技术要点讲到位。我们用Python内置的csv模块来处理csv文件，并且使用HttpResponse来将csv文件返回回去。示例代码如下： import csv from django.http import HttpResponse def csv_view(request): response = HttpResponse(content_type='text/csv') response['Content-Disposition'] = 'attachment; filename=\"somefilename.csv\"' writer = csv.writer(response) writer.writerow(['username', 'age', 'height', 'weight']) writer.writerow(['zhiliao', '18', '180', '110']) return response ##手打代码 def index(request): response = HttpResponse(content_type='text/csv') response['Content-Disposition']=\"attachment;filename=abc.csv\" #指定为附件，并且下载名为abc.csv ''' #with open('xxx.csv') as fp: #csv.write(fp) ''' write = csv.writer(response)#write 句柄或者对象 write.writerow(['username','age']) write.writerow(['zhiliao','18']) return response 这里再来对每个部分的代码进行解释： 我们在初始化HttpResponse的时候，指定了Content-Type为text/csv，这将告诉浏览器，这是一个csv格式的文件而不是一个HTML格式的文件，如果用默认值，默认值就是html，那么浏览器将把csv格式的文件按照html格式输出，这肯定不是我们想要的。 第二个我们还在response中添加一个Content-Disposition头，这个东西是用来告诉浏览器该如何处理这个文件，我们给这个头的值设置为attachment;，那么浏览器将不会对这个文件进行显示，而是作为附件的形式下载，第二个filename=\"somefilename.csv\"是用来指定这个csv文件的名字。 我们使用csv模块的writer方法，将相应的数据写入到response中。 将csv文件定义成模板： 我们还可以将csv格式的文件定义成模板，然后使用Django内置的模板系统，并给这个模板传入一个Context对象，这样模板系统就会根据传入的Context对象，生成具体的csv文件。示例代码如下： 模板文件： {% for row in data %}\"{{ row.0|addslashes }}\", \"{{ row.1|addslashes }}\", \"{{ row.2|addslashes }}\", \"{{ row.3|addslashes }}\", \"{{ row.4|addslashes }}\" {% endfor %} 视图函数： from django.http import HttpResponse from django.template import loader, Context def some_view(request): response = HttpResponse(content_type='text/csv') response['Content-Disposition'] = 'attachment; filename=\"somefilename.csv\"' csv_data = ( ('First row', 'Foo', 'Bar', 'Baz'), ('Second row', 'A', 'B', 'C', '\"Testing\"', \"Here's a quote\"), ) t = loader.get_template('my_template_name.txt') response.write(t.render({\"data\": csv_data})) return response ###手工代理 def template_views_csv(request): response = HttpResponse(content_type='text/csv') response['Content-Disposition'] = \"attachment;filename=123.csv\" context = { 'rows':[ ['username','age'], ['zhiliao',18], ] } template = loader.get_template('abc.txt') csv_template = template.render(context)#加载内容 response.content = csv_template return response 生成大的CSV文件： 以上的例子是生成的一个小的csv文件，如果想要生成大型的csv文件，那么以上方式将有可能会发生超时的情况（服务器要生成一个大型csv文件，需要的时间可能会超过浏览器默认的超时时间）。这时候我们可以借助另外一个类，叫做StreamingHttpResponse对象，这个对象是将响应的数据作为一个流返回给客户端，而不是作为一个整体返回。示例代码如下： class Echo: \"\"\" 定义一个可以执行写操作的类，以后调用csv.writer的时候，就会执行这个方法 \"\"\" def write(self, value): return value def large_csv(request): rows = ([\"Row {}\".format(idx), str(idx)] for idx in range(655360)) pseudo_buffer = Echo() writer = csv.writer(pseudo_buffer) response = StreamingHttpResponse((writer.writerow(row) for row in rows),content_type=\"text/csv\") response['Content-Disposition'] = 'attachment; filename=\"somefilename.csv\"' return response 这里我们构建了一个非常大的数据集rows，并且将其变成一个迭代器。然后因为StreamingHttpResponse的第一个参数只能是一个生成器，因此我们使用圆括号(writer.writerow(row) for row in rows)，并且因为我们要写的文件是csv格式的文件，因此需要调用writer.writerow将row变成一个csv格式的字符串。而调用writer.writerow又需要一个中间的容器，因此这里我们定义了一个非常简单的类Echo，这个类只实现一个write方法，以后在执行csv.writer(pseudo_buffer)的时候，就会调用Echo.writer方法。 注意：StreamingHttpResponse会启动一个进程来和客户端保持长连接，所以会很消耗资源。所以如果不是特殊要求，尽量少用这种方法。 关于StreamingHttpResponse： 这个类是专门用来处理流数据的。使得在处理一些大型文件的时候，不会因为服务器处理时间过长而到时连接超时。这个类不是继承自HttpResponse，并且跟HttpResponse对比有以下几点区别： 这个类没有属性content，相反是streaming_content。 这个类的streaming_content必须是一个可以迭代的对象。 这个类没有write方法，如果给这个类的对象写入数据将会报错。 注意：StreamingHttpResponse会启动一个进程来和客户端保持长连接，所以会很消耗资源。所以如果不是特殊要求，尽量少用这种方法。 def laege_csv_view(request): #response = StreamingHttpResponse(content_type = 'text/csv') #response['Content-Disposition'] = \"attachment;filename=large.csv\" #rows = ('Row {},{}\\n'.format(row,row) for row in range(0,10000)) #print(type(rows)) # #response.streaming_content=(\"username,age\\n\",\"zhiliao,18\\n\",\"zhiliao1,18\\n\") #response = HttpResponse('sucess') #response.streaming_content = rows #return response response =HttpResponse(content_type='text/csv') response['Content-Disposition'] = 'attachment;filename = \"large.csv\"' write = csv.writer(response) for row in range(0,10000): write.writerow(['Row{}'.format(row),'{}'.format(row)]) return response "},"django/django打造大型企业/第五章：高级视图/5.6 第六节：类视图.html":{"url":"django/django打造大型企业/第五章：高级视图/5.6 第六节：类视图.html","title":"5.6 第六节：类视图","keywords":"","body":"类视图 在写视图的时候，Django除了使用功能作为视图，也可以使用类作为视图。使用类视图可以使用类的一些特性，而继承等。 视图： django.views.generic.base.View是主要的类视图，所有的类视图都是继承自他。如果我们写自己的类视图，也可以继承自他。然后再根据当前请求的method，来实现不同的方法。某种这样的视图只能使用get的方式来请求，那么就可以在这个类中定义get(self,request,*args,**kwargs)方法。以此类推，如果只需要实现post方法，那么就只需要在类中实现post(self,request,*args,**kwargs)。示例代码如下： from django.views import View class BookDetailView(View): def get(self,request,*args,**kwargs): return render(request,'detail.html') #手打代码 from django.http import HttpResponse from django.shortcuts import render from django.views.generic import View def index(request): return HttpResponse('index') #输入 http://127.0.0.1:8000/book/ 同样会显示 book_list class BookListView(View): def get(self,request,*args,**kwargs): #**kwargs 所有的关键字字段 return HttpResponse('book_list') 类视图写完后，还应该在urls.py中进行映射，映射的时候就需要调用View的类方法as_view()来进行转换。示例代码如下： urlpatterns = [ path(\"detail//\",views.BookDetailView.as_view(),name='detail') ] #手打代码 class AddBookView(View): def get(self,request,*args,**kwargs): return render(request,'add_book.html') def post(self,request,*args,**kwargs): #使用post提交的时候需要将csrf验证关闭掉 book_name = request.POST.get('name') book_author = request.POST.get('author') print('name:{},author:{}'.format(book_name,book_author)) return HttpResponse('success') 除了get方法，View还支持以下方法['get','post','put','patch','delete','head','options','trace']。 如果用户访问了View中没有定义的方法。比如你的类视图只支持get方法，而出现了post方法，那么就会把这个请求转发给http_method_not_allowed(request,*args,**kwargs)。示例代码如下： class AddBookView(View): def post(self,request,*args,**kwargs): return HttpResponse(\"书籍添加成功！\") def http_method_not_allowed(self, request, *args, **kwargs): return HttpResponse(\"您当前采用的method是：%s，本视图只支持使用post请求！\" % request.method) urls.py中的映射如下： path(\"addbook/\",views.AddBookView.as_view(),name='add_book') 如果你在浏览器中访问addbook/，因为浏览器访问采用的是get方法，而addbook只支持post方法，因此以上视图会返回您当前采用的method是：GET，本视图只支持使用post请求！。 其实不管是get请求还是post请求，都会走dispatch(request,*args,**kwargs)方法，所以如果实现这个方法，将能够对所有请求都处理到。 #手打代码 class BookDetailView(View): def get(self,request,book_id): print('图书的id是：%s' %book_id) return HttpResponse('bookdetailview') def http_method_not_allowed(self, request, *args, **kwargs): return HttpResponse('不支持get以外的其他请求') #类似图首先会请求dispath方法，然后在根据不同的请求分配给其他方法 def dispath(self,request,*args,**kwargs): print('dispath') return super(BookDetailView, self).dispath(request,*args,**kwargs) TemplateView： django.views.generic.base.TemplateView，这个类视图是专门用来返回模版的。在这个类中，有两个属性是经常需要用到的，一个是template_name，这个属性是用来存储模版的路径，TemplateView会自动的渲染这个变量指向的模版。另外一个是get_context_data，这个方法是用来返回上下文数据的，也就是在给模版传的参数的。示例代码如下： #手打代码 from django.views.generic import TemplateView #如果渲染不需要使用传递参数，那么建议在urls中使用TemplateView path('about/', TemplateView.as_view(template_name='about.html')), #上面两个代码直接在url映射文件中，就可以直接打开about模板文件 '''模板文件 Title 这是关于我们的页面{{ phone }} ''' #urls.py path('about/', views.AboutView.as_view(template_name='about.html')), #views.py class AboutView(TemplateView): template_name= 'about.html' def get_context_data(self,**kwargs): context ={ 'phone':'0523-8888888' } return context #以上这一段是需要设计参数的方法 from django.views.generic.base import TemplateView class HomePageView(TemplateView): template_name = \"home.html\" def get_context_data(self, **kwargs): context = super().get_context_data(**kwargs) context['username'] = \"黄勇\" return context 在urls.py中的映射代码如下： from django.urls import path from myapp.views import HomePageView urlpatterns = [ path('', HomePageView.as_view(), name='home'), ] 如果在模版中不需要传递任何参数，那么可以直接只在urls.py中使用TemplateView来渲染模版。示例代码如下： from django.urls import path from django.views.generic import TemplateView urlpatterns = [ path('about/', TemplateView.as_view(template_name=\"about.html\")), ] ListView： 在网站开发中，经常会出现需要列出某个表中的一些数据作为列表展示出来。比如文章列表，图书列表等等。在Django中可以使用ListView来帮我们快速实现这种需求。示例代码如下： class ArticleListView(ListView): model = Article template_name = 'article_list.html' paginate_by = 10 #表示一页当中要显示多少条数据 context_object_name = 'articles' ordering = 'create_time'#排序的方式 page_kwarg = 'page' #翻页参数的名字 def get_context_data(self, **kwargs): context = super(ArticleListView, self).get_context_data(**kwargs) print(context) return context def get_queryset(self): #获取数据的方法 return Article.objects.filter(id__lte=89) #手打代码 class ArticleListView(ListView): model = Article template_name = 'article_list.html' context_object_name ='articles' paginate_by = 10 ordering = 'create_time' page_kwarg = 'p' def get_context_data(self, **kwargs): #首先调用父类的方法 context = super(ArticleListView, self).get_context_data(*kwargs) context['username'] = 'zhiliao' print('='* 30) print(context) ''' {'paginator': , 'page_obj': , 'is_paginated': True, 'object_list': , , , , , , , , , ]>, 'articles': , , , , , , , , , ]>, 'view': , 'username': 'zhiliao'} ''' print('='*30) return context 对以上代码进行解释： 首先ArticleListView是继承自ListView。 model：重写model类属性，指定这个列表是给哪个模型的。 template_name：指定这个列表的模板。 paginate_by：指定这个列表一页中展示多少条数据。 context_object_name：指定这个列表模型在模板中的参数名称。 ordering：指定这个列表的排序方式。 page_kwarg：获取第几页的数据的参数名称。默认是page。 get_context_data：获取上下文的数据。 def get_context_data(self, **kwargs): #首先调用父类的方法 context = super(ArticleListView, self).get_context_data(*kwargs) context['username'] = 'zhiliao' print('='* 30) print(context) ''' {'paginator': , 'page_obj': , 'is_paginated': True, 'object_list': , , , , , , , , , ]>, 'articles': , , , , , , , , , ]>, 'view': , 'username': 'zhiliao'} ''' print('='*30) return context get_queryset：如果你提取数据的时候，并不是要把所有数据都返回，那么你可以重写这个方法。将一些不需要展示的数据给过滤掉。 def get_queryset(self): return Article.objects.filter(id__lte=9) 注意这些参数字段不要出现问题 Paginator和Page类： Paginator和Page类都是用来做分页的。他们在Django中的路径为django.core.paginator.Paginator和django.core.paginator.Page。以下对这两个类的常用属性和方法做解释： Paginator常用属性和方法： count：总共有多少条数据。 num_pages：总共有多少页。 page_range：页面的区间。比如有三页，那么就range(1,4)。 Page常用属性和方法： has_next：是否还有下一页。 has_previous：是否还有上一页。 next_page_number：下一页的页码。 previous_page_number：上一页的页码。 number：当前页。 start_index：当前这一页的第一条数据的索引值。 end_index：当前这一页的最后一条数据的索引值。 #模板 articles {% for article in articles %} {{ article.title }} {% endfor %} {# 上一页 #} {% if page_obj.has_previous %} 上一页 {% else %} 上一页 {% endif %} {# 中间页码 #} {% for page in paginator.page_range %} {% if page == page_obj.number %} {{ page }} {% else %} {{ page }} {% endif %} {% endfor %} {# 下一页 #} {% if page_obj.has_next %} 下一页 {% else %} 下一页 {% endif %} #views.py from django.shortcuts import render,redirect,reverse from .models import Article from django.http import HttpResponse from django.views.generic import ListView,View from django.core.paginator import Paginator,Page from django.utils.decorators import method_decorator # Create your views here. def add_article(request): articles =[] print(articles) for x in range(0,102): article = Article(title='标题：%s'%x,content='内容：%s'%x) articles.append(article) Article.objects.bulk_create(articles) return HttpResponse('success') class ArticleListView(ListView): model = Article template_name = 'article_list.html' context_object_name ='articles' paginate_by = 10 ordering = 'create_time' page_kwarg = 'p' def get_context_data(self, **kwargs): #首先调用父类的方法 context = super(ArticleListView, self).get_context_data(*kwargs) context['username'] = 'zhiliao' paginator = context.get('paginator')#获取这个类 page_obj = context.get('page_obj') print(page_obj.has_next())#False print(paginator.count)#会打印出总计102条 print(paginator.num_pages)#总计有11页 print(paginator.page_range)#range(1, 12) pagination_data = self.get_pagination_data(paginator,page_obj) context.update(pagination_data)#将字段自动放入context字典中 return context #def get_queryset(self): #return Article.objects.filter(id__lte=9) #只会返回9以内的数据 #自定义的函数 def get_pagination_data(self,paginator,page_obj,around_count=2): #获取当前的页码 current_page = page_obj.number left_pages = range(current_page-around_count,current_page)#左边两条数据 right_pages = range(current_page+1,current_page+around_count+1)#右边的两条数据 return { 'left_pages':left_pages, 'right_pages':right_pages, } #model.py from django.db import models # Create your models here. class Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() create_time =models.DateTimeField(auto_now_add=True) 比较完整版的 #模板 articles {% for article in articles %} {{ article.title }} {% endfor %} {# 上一页 #} {% if page_obj.has_previous %} 上一页 {% else %} 上一页 {% endif %} {% if left_has_more %} 1 ... {% endif %} {# 左边页码 #} {% for left_page in left_pages %} {{ left_page }} {% endfor %} {# 当前页码 #} {{ current_page }} {# 右边的代码 #} {% for right_page in right_pages %} {{ right_page }} {% endfor %} {% if right_has_more %} ... {{ paginator.num_pages }} {% endif %} {# 下一页 #} {% if page_obj.has_next %} 下一页 {% else %} 下一页 {% endif %} #view.py from django.shortcuts import render,redirect,reverse from .models import Article from django.http import HttpResponse from django.views.generic import ListView,View from django.core.paginator import Paginator,Page from django.utils.decorators import method_decorator # Create your views here. def add_article(request): articles =[] print(articles) for x in range(0,102): article = Article(title='标题：%s'%x,content='内容：%s'%x) articles.append(article) Article.objects.bulk_create(articles) return HttpResponse('success') class ArticleListView(ListView): model = Article template_name = 'article_list.html' context_object_name ='articles' paginate_by = 10 ordering = 'create_time' page_kwarg = 'p' def get_context_data(self, **kwargs): #首先调用父类的方法 context = super(ArticleListView, self).get_context_data(*kwargs) context['username'] = 'zhiliao' paginator = context.get('paginator')#获取这个类 page_obj = context.get('page_obj') print(page_obj.has_next())#False print(paginator.count)#会打印出总计102条 print(paginator.num_pages)#总计有11页 print(paginator.page_range)#range(1, 12) pagination_data = self.get_pagination_data(paginator,page_obj) context.update(pagination_data)#将字段自动放入context字典中 return context #def get_queryset(self): #return Article.objects.filter(id__lte=9) #只会返回9以内的数据 #自定义的函数 def get_pagination_data(self,paginator,page_obj,around_count=2): #获取当前的页码 current_page = page_obj.number num_pages = paginator.num_pages left_has_more = False right_has_more = False if current_page = (num_pages -around_count-1): right_pages = range(current_page+1,num_pages+1) else: right_has_more = True right_pages = range(current_page+1,current_page+around_count+1)#右边的两条数据 return { 'left_pages':left_pages, 'right_pages':right_pages, 'current_page':current_page, 'left_has_more':left_has_more, 'right_has_more':right_has_more, } 给类视图添加装饰器： 在开发中，有时候需要给一些视图添加装饰器。如果用函数视图那么非常简单，只要在函数的上面写上装饰器就可以了。但是如果想要给类添加装饰器，那么可以通过以下两种方式来实现： 装饰dispatch方法： from django.utils.decorators import method_decorator def login_required(func): def wrapper(request,*args,**kwargs): if request.GET.get(\"username\"): return func(request,*args,**kwargs) else: return redirect(reverse('index')) return wrapper class IndexView(View): def get(self,request,*args,**kwargs): return HttpResponse(\"index\") @method_decorator(login_required) def dispatch(self, request, *args, **kwargs): super(IndexView, self).dispatch(request,*args,**kwargs) #手打代码 from django.shortcuts import render,redirect,reverse from .models import Article from django.http import HttpResponse from django.views.generic import ListView,View from django.core.paginator import Paginator,Page from django.utils.decorators import method_decorator #登录验证 def login_required(func): def wrapper(request,*args,**kwargs): #?username=zhiliao username = request.GET.get('username') if username: return func(request,*args,**kwargs) else: return redirect(reverse('article:login')) return wrapper class ProfileView(View): def get(self,request): return HttpResponse('个人中心界面') @method_decorator(login_required)#装饰器 def dispatch(self, request, *args, **kwargs): #调用父类 return super(ProfileView,self).dispatch(request,*args,**kwargs) def login(request): return HttpResponse('login') 直接装饰在整个类上： from django.utils.decorators import method_decorator def login_required(func): def wrapper(request,*args,**kwargs): if request.GET.get(\"username\"): return func(request,*args,**kwargs) else: return redirect(reverse('login')) return wrapper @method_decorator(login_required,name='dispatch') class IndexView(View): def get(self,request,*args,**kwargs): return HttpResponse(\"index\") def dispatch(self, request, *args, **kwargs): super(IndexView, self).dispatch(request,*args,**kwargs) #手打代码 def login_required(func): def wrapper(request,*args,**kwargs): #?username=zhiliao username = request.GET.get('username') if username: return func(request,*args,**kwargs) else: return redirect(reverse('article:login')) return wrapper @method_decorator(login_required,name='dispatch')#装饰器 class ProfileView(View): def get(self,request): return HttpResponse('个人中心界面') # @method_decorator(login_required)#装饰器 # def dispatch(self, request, *args, **kwargs): # #调用父类 # return super(ProfileView,self).dispatch(request,*args,**kwargs) def login(request): return HttpResponse('login') 如果有多个装饰器可以使用列表装饰。 @method_decorator([login_required],name='dispatch')#装饰器 "},"django/django打造大型企业/第五章：高级视图/5.7 第七节：错误处理.html":{"url":"django/django打造大型企业/第五章：高级视图/5.7 第七节：错误处理.html","title":"5.7 第七节：错误处理","keywords":"","body":"错误处理 在一些网站开发中。经常会需要捕获一些错误，然后将这些错误返回比较优美的界面，或者是将这个错误的请求做一些日志保存。那么我们本节就来讲讲如何实现。 常用的错误码： 404：服务器没有指定的url。 403：没有权限访问相关的数据。 405：请求的method错误。 400：bad request，请求的参数错误。 500：服务器内部错误，一般是代码出bug了。 502：一般部署的时候见得比较多，一般是nginx启动了，然后uwsgi有问题。 错误处理的时候，必须将settings里的debug改为false 自定义错误模板： 在碰到比如404，500错误的时候，想要返回自己定义的模板。那么可以直接在templates文件夹下创建相应错误代码的html模板文件。那么以后在发生相应错误后，会将指定的模板返回回去。 错误处理的解决方案： 对于404和500这种自动抛出的错误。我们可以直接在templates文件夹下新建相应错误代码的模板文件。而对于其他的错误，我们可以专门定义一个app，用来处理这些错误。 "}}